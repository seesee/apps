<!DOCTYPE html>
<!-- 2025.08.07.31 -->
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <title>Activity Tracker</title>
    <style>
        * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    color: #333;
}

/* Fix HR overflow on constrained screens */
hr {
    margin: 15px 0;
    border: none;
    border-top: 1px solid #e2e8f0;
    box-sizing: border-box;
    max-width: 100%;
}

.template-overlay hr {
    margin: 10px 0;
    max-width: calc(100% - 20px);
}

.modal hr {
    margin: 15px 0;
    max-width: calc(100% - 20px);
}

/* Improved heading spacing throughout the UI */
h2 {
    margin-bottom: 20px;
    padding-bottom: 8px;
}

h3 {
    margin-bottom: 16px;
    padding-bottom: 6px;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

.header {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 15px;
    padding: 20px;
    margin-bottom: 20px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

.nav {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 15px;
    flex-wrap: wrap;
    gap: 10px;
}

.nav-left {
    display: flex;
    gap: 15px;
    flex-shrink: 0;
}

.nav-right {
    display: flex;
    gap: 10px;
    flex-shrink: 0;
}

.nav-btn {
    padding: 10px 20px;
    border: none;
    background: #667eea;
    color: white;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: 500;
}

.nav-btn:hover {
    background: #5a67d8;
    transform: translateY(-2px);
}

.nav-btn.active {
    background: #4c51bf;
    box-shadow: 0 4px 15px rgba(76, 81, 191, 0.4);
}

/* Burger Menu */
.burger-anchor {
    position: absolute;
    top: 0;
    right: 0;
    width: 1px;
    height: 1px;
    pointer-events: none;
    visibility: hidden;
}

.burger-menu {
    position: fixed;
    z-index: 1000;
}

.burger-btn {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    width: 40px;
    height: 40px;
    background: #667eea;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    padding: 8px;
}

.burger-btn:hover {
    background: #5a67d8;
    transform: translateY(-2px);
}

.burger-line {
    width: 20px;
    height: 2px;
    background: white;
    margin: 2px 0;
    transition: all 0.3s ease;
    border-radius: 1px;
}

.burger-dropdown {
    position: absolute;
    top: 100%;
    right: 0;
    margin-top: 4px;
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(20px);
    border-radius: 8px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
    z-index: 1001;
    min-width: 180px;
    overflow: hidden;
}

.burger-item {
    display: block;
    width: 100%;
    padding: 12px 16px;
    background: none;
    border: none;
    text-align: left;
    color: #4a5568;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.burger-emoji {
    margin-right: 8px;
}

.burger-text {
    /* Text styling can be added here if needed */
}

.burger-item:hover {
    background: #f7fafc;
    color: #2d3748;
}

/* Dark mode styles for burger menu */
.dark-mode .burger-dropdown {
    background: rgba(26, 32, 44, 0.9);
    backdrop-filter: blur(20px);
    border: 1px solid #4a5568;
}

.dark-mode .burger-item {
    color: #e2e8f0;
}

.dark-mode .burger-item:hover {
    background: #4a5568;
    color: #f7fafc;
}

.burger-separator {
    height: 1px;
    background: #e2e8f0;
    margin: 8px 0;
}

.dark-mode .burger-separator {
    background: #4a5568;
}

.section {
    display: none;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 15px;
    padding: 30px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

.section.active {
    display: block;
}

.form-group {
    margin-bottom: 20px;
}

.form-group-row {
    display: flex;
    gap: 15px;
    margin-bottom: 20px;
}

.form-group-row .form-group {
    flex: 1;
    margin-bottom: 0;
}

/* Todo Section Styles */
.todo-filters {
    background: #f8f9fa;
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 20px;
    border: 1px solid #e2e8f0;
}

/* Notes Section Styles */
.notes-filters {
    background: #f8f9fa;
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 20px;
    border: 1px solid #e2e8f0;
}

.filter-row {
    display: flex;
    gap: 20px;
    align-items: center;
    flex-wrap: wrap;
}

.filter-group {
    display: flex;
    align-items: center;
    gap: 10px;
}

.filter-group label {
    font-weight: 600;
    color: #4a5568;
    margin: 0;
    white-space: nowrap;
}

.filter-group select {
    padding: 8px 12px;
    border: 2px solid #e2e8f0;
    border-radius: 6px;
    font-size: 14px;
    background: white;
    min-width: 150px;
}

.filter-group input {
    padding: 8px 12px;
    border: 2px solid #e2e8f0;
    border-radius: 6px;
    font-size: 14px;
    background: white;
    min-width: 150px;
    transition: border-color 0.3s ease;
}

.filter-group input:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.todo-stats {
    margin-bottom: 15px;
    padding: 10px 0;
    color: #666;
    font-size: 14px;
}

.todo-list {
    min-height: 200px;
}

.todo-item {
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 15px;
    transition: all 0.2s ease;
    position: relative;
}

.todo-item.todo-incomplete {
    border: 1px solid #9b2c2c !important;
}

.todo-item.todo-overdue {
    background: #fef5f5;
    border: 1px solid #7b2d2d !important;
}

.todo-item:hover {
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.todo-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 10px;
}

.todo-content {
    flex: 1;
}

.todo-activity {
    font-size: 16px;
    font-weight: 600;
    color: #2d3748;
    margin-bottom: 5px;
}

.todo-description {
    color: #718096;
    font-size: 14px;
    margin-bottom: 10px;
    line-height: 1.4;
}

.todo-meta {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    font-size: 12px;
    color: #a0aec0;
    margin-bottom: 10px;
}

.todo-tags {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    margin-bottom: 10px;
}

.todo-tag {
    background: #38a169;
    color: white;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

.todo-tag:hover {
    background: #2f855a;
    transform: scale(1.05);
}

.todo-actions {
    display: flex;
    gap: 8px;
    align-items: center;
}

.todo-pagination, .entries-pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    margin-top: 30px;
    padding: 20px 0;
}

/* Consistent pagination button sizing */
.todo-pagination .nav-btn,
.entries-pagination .nav-btn,
.search-pagination .nav-btn,
.notes-pagination .nav-btn,
.report-navigation .nav-btn {
    min-width: 120px;
    text-align: center;
}

.empty-state {
    text-align: center;
    color: #a0aec0;
    font-style: italic;
    padding: 40px 20px;
}

/* Global Search Styles */
.global-search {
    margin: 20px 0;
    max-width: 600px;
    margin-left: auto;
    margin-right: auto;
}

@media (max-width: 768px) {
    .global-search {
        margin: 15px 0;
        max-width: 100%;
    }
}

.search-container {
    position: relative;
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
}

#globalSearch {
    flex: 1;
    padding: 15px 20px;
    border: 2px solid #e2e8f0;
    border-radius: 25px;
    font-size: 16px;
    background: white;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
    transition: all 0.3s ease;
}

.hashtag-browser-btn {
    padding: 12px;
    background: #667eea;
    color: white;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    font-size: 16px;
    transition: all 0.3s ease;
    flex-shrink: 0;
}

.hashtag-browser-btn:hover {
    background: #5a67d8;
    transform: scale(1.05);
}

/* Hashtag cloud styling */
#hashtagBrowserModal .hashtag-cloud {
    padding: 20px;
    line-height: 1.8;
    text-align: center;
    max-height: 400px;
    overflow-y: auto;
}

.hashtag-cloud-item {
    display: inline-block;
    margin: 5px 8px;
    padding: 4px 12px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-decoration: none;
    white-space: nowrap;
    font-weight: 500;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.hashtag-cloud-item:hover {
    transform: scale(1.1) translateY(-2px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    background: linear-gradient(135deg, #5a67d8 0%, #667eea 100%);
}

/* Dark mode hashtag cloud */
.dark-mode .hashtag-cloud-item {
    background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
    color: #f7fafc;
}

.dark-mode .hashtag-cloud-item:hover {
    background: linear-gradient(135deg, #5b21b6 0%, #4f46e5 100%);
    box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
}

#globalSearch:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1), 0 4px 20px rgba(0, 0, 0, 0.1);
}

.search-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: white;
    border: 2px solid #e2e8f0;
    border-top: none;
    border-radius: 0 0 15px 15px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    max-height: 400px;
    overflow-y: auto;
}

.search-suggestion {
    padding: 12px 20px;
    cursor: pointer;
    border-bottom: 1px solid #f7fafc;
    transition: background-color 0.2s ease;
}

.search-suggestion:hover {
    background: #f7fafc;
}

.search-suggestion.selected {
    background: #667eea;
    color: white;
}

.search-suggestion-activity {
    font-weight: 600;
    margin-bottom: 4px;
}

.search-suggestion-meta {
    font-size: 12px;
    color: #a0aec0;
}

.search-suggestion.selected .search-suggestion-meta {
    color: rgba(255, 255, 255, 0.8);
}

.search-hashtag {
    background: #667eea;
    color: white;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 500;
    margin-right: 4px;
}

/* Search Controls */
.search-controls {
    background: #f8f9fa;
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 20px;
    border: 1px solid #e2e8f0;
}

.search-info {
    margin-bottom: 15px;
    font-size: 14px;
    color: #666;
}

.search-options {
    display: flex;
    gap: 20px;
    align-items: center;
    flex-wrap: wrap;
}

.search-results-list {
    min-height: 200px;
}

.search-result-item {
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 15px;
    transition: all 0.2s ease;
}

.search-result-item:hover {
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.search-result-item.result-todo {
    border: 1px solid #9b2c2c !important;
}

.search-result-item.result-completed {
    border: 1px solid #38a169 !important;
}

.search-result-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 10px;
}

.search-result-content {
    flex: 1;
}

.search-result-activity {
    font-size: 16px;
    font-weight: 600;
    color: #2d3748;
    margin-bottom: 5px;
}

.search-result-description {
    color: #718096;
    font-size: 14px;
    margin-bottom: 10px;
    line-height: 1.4;
}

.search-result-tags {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    margin-bottom: 10px;
}

.search-result-tag {
    background: #38a169;
    color: white;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

.search-result-tag:hover {
    background: #2f855a;
    transform: scale(1.05);
}

.search-result-meta {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    font-size: 12px;
    color: #a0aec0;
    margin-bottom: 10px;
}

.search-result-actions {
    display: flex;
    gap: 8px;
    align-items: center;
}

.search-pagination, .notes-pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    margin-top: 30px;
    padding: 20px 0;
}

.form-group label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
    color: #4a5568;
}

.form-group input,
.form-group select,
.form-group textarea {
    width: 100%;
    padding: 12px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    font-size: 16px;
    transition: border-color 0.3s ease;
}

.form-group input:focus,
.form-group select:focus,
.form-group textarea:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.form-group-buttons {
    margin-top: 32px; /* Align with other form groups that have labels */
}

.btn {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    font-size: 16px;
    transition: all 0.3s ease;
    margin-right: 10px;
    margin-bottom: 10px;
}

.btn-small {
    padding: 6px 12px;
    font-size: 12px;
    margin-right: 5px;
    margin-bottom: 5px;
}

.due-date-quick-sets {
    display: flex;
    gap: 12px;
    margin-top: 8px;
    flex-wrap: wrap;
}

.due-date-group {
    display: flex;
    gap: 4px;
    flex: 1;
}

/* Make due date buttons within groups equal width */
.due-date-group .btn-quick-set {
    flex: 1;
    min-width: 0;
    text-align: center;
}

/* Form actions split layout */
.form-actions-split {
    display: flex;
    gap: 8px;
    margin-top: 16px;
    width: 100%;
    box-sizing: border-box;
    margin-left: 0;
    margin-right: 0;
}

.form-actions-split .btn {
    flex: 1;
    min-width: 0; /* Allow buttons to shrink */
    text-align: center;
    box-sizing: border-box;
    margin-right: 0; /* Override default button margin */
    margin-bottom: 0; /* Override default button margin */
}

.todo-quick-set {
    display: flex;
    gap: 8px;
    margin-top: 8px;
    flex-wrap: wrap;
}

.btn-quick-set {
    padding: 8px 12px;
    font-size: 14px;
    background: #e2e8f0;
    color: #4a5568;
    border: 1px solid #cbd5e0;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
}

/* Make todo/note buttons match description textarea width */
.todo-quick-set .btn-quick-set {
    flex: 1;
    min-width: 0;
    text-align: center;
}

.btn-quick-set:hover {
    background: #cbd5e0;
    border-color: #a0aec0;
}

.btn-quick-set.active {
    background: #38a169;
    color: white;
    border-color: #2f855a;
}

.btn-quick-set.active:hover {
    background: #2f855a;
    border-color: #276749;
}

.btn-primary {
    background: #667eea;
    color: white;
}

.btn-primary:hover {
    background: #5a67d8;
    transform: translateY(-2px);
}

.btn-secondary {
    background: #718096;
    color: white;
}

.btn-secondary:hover {
    background: #4a5568;
}

.btn-danger {
    background: #e53e3e;
    color: white;
}

.btn-danger:hover {
    background: #c53030;
}

.btn-success {
    background: #667eea;
    color: white;
}

.btn-success:hover {
    background: #5a67d8;
}

.btn-outline {
    background: transparent;
    border: 2px solid #667eea;
    color: #667eea;
}

.btn-outline:hover {
    background: #667eea;
    color: white;
    transform: translateY(-2px);
}

.btn-warning {
    background: #ed8936;
    color: white;
}

.btn-warning:hover {
    background: #dd6b20;
}

.entries-list {
    margin-top: 30px;
}

.entry-item {
    background: #f7fafc;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 15px;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
}

.entry-content {
    flex: 1;
}

.entry-time {
    font-weight: 600;
    color: #667eea;
    margin-bottom: 5px;
}

.entry-activity {
    font-size: 18px;
    margin-bottom: 5px;
}

.entry-description {
    color: #718096;
    font-size: 14px;
}

/* Markdown in descriptions should be more compact */
.entry-description .md-paragraph {
    margin: 5px 0;
}

.entry-description .md-list {
    margin: 5px 0;
    padding-left: 20px;
}

.entry-description .md-blockquote {
    margin: 8px 0;
    padding: 5px 10px;
    font-size: 13px;
}

.entry-description .md-code {
    font-size: 12px;
}

.entry-actions {
    display: flex;
    gap: 10px;
}

/* Todo entry styles */
.entry-item.entry-todo {
    border: 1px solid #9b2c2c !important;
}

.entry-item.entry-overdue {
    background: #fef5f5;
    border-color: #7b2d2d !important;
}

.entry-tags {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    margin-top: 8px;
}

.entry-tag {
    background: #38a169;
    color: white;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

.entry-tag:hover {
    background: #2f855a;
    transform: scale(1.05);
}

/* Inline hashtag links */
.hashtag-link {
    color: #38a169;
    text-decoration: none;
    font-weight: 500;
    transition: color 0.2s ease;
}

.hashtag-link:hover {
    color: #2f855a;
    text-decoration: underline;
}

.external-link {
    color: #3182ce;
    text-decoration: none;
    font-weight: 500;
    transition: color 0.2s ease;
}

.external-link:hover {
    color: #2b6cb0;
    text-decoration: underline;
}

.entry-due-date {
    font-size: 12px;
    color: #a0aec0;
    margin-top: 5px;
}

.entry-todo-indicator {
    font-size: 12px;
    color: #f56565;
    margin-left: 10px;
}

.entry-note-indicator {
    font-size: 12px;
    color: #3182ce;
    margin-left: 10px;
}

.settings-buttons-section {
    margin-bottom: 30px;
}

.settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 25px;
    margin-bottom: 30px;
}

.data-management-section {
    margin-bottom: 30px;
}

.data-management-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 20px;
}

.about-section {
    margin-bottom: 30px;
}

.settings-section {
    background: #f7fafc;
    padding: 20px;
    border-radius: 8px;
    border: 1px solid #e2e8f0;
}

.settings-section h3 {
    margin-bottom: 8px;
    color: #2d3748;
}

.settings-description {
    font-size: 14px;
    color: #718096;
    margin-bottom: 20px;
    margin-top: 0;
}

.settings-toggles {
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid #e2e8f0;
}

.time-inputs {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
}

.activity-days-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
}

.settings-card {
    background: #ffffff;
    border: 2px solid #e2e8f0;
    border-radius: 12px;
    padding: 24px;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.settings-card:hover {
    border-color: #667eea;
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.15);
    transform: translateY(-2px);
}

.settings-card h3 {
    margin-bottom: 8px;
    color: #2d3748;
    font-size: 18px;
}

.card-description {
    font-size: 14px;
    color: #718096;
    margin-bottom: 20px;
    line-height: 1.5;
}

.card-actions {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
}

.about-section .debug-info {
    margin-top: 0;
}

.checkbox-group {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
}

.checkbox-group input[type="checkbox"] {
    width: auto;
    margin-right: 10px;
}

.notification-status {
    padding: 10px;
    border-radius: 8px;
    margin-bottom: 20px;
    text-align: center;
    font-weight: 600;
}

.notification-enabled {
    background: #c6f6d5;
    color: #22543d;
}

.notification-disabled {
    background: #fed7d7;
    color: #742a2a;
}

.notification-warning {
    background: #fef5e7;
    color: #744210;
}

.report-filters {
    background: #f7fafc;
    padding: 20px;
    border-radius: 8px;
    margin-bottom: 20px;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    align-items: end;
}

.report-summary {
    background: #e6fffa;
    padding: 20px;
    border-radius: 8px;
    margin-bottom: 20px;
    border-left: 4px solid #38b2ac;
}

.report-navigation {
    display: flex;
    gap: 10px;
    align-items: center;
    margin-bottom: 20px;
}

.week-display {
    background: #f7fafc;
    padding: 10px 15px;
    border-radius: 8px;
    font-weight: 600;
    min-width: 200px;
    text-align: center;
}

.download-section {
    background: #f0fff4;
    padding: 20px;
    border-radius: 8px;
    margin-top: 20px;
    border-left: 4px solid #38a169;
}

/* Modal styles moved to improved version below */

.status-indicator {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-right: 8px;
}

.status-active {
    background: #48bb78;
}

.status-inactive {
    background: #f56565;
}

.reminder-buttons {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.backup-buttons {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.debug-info {
    background: #f7fafc;
    padding: 20px 24px;
    border-radius: 8px;
    margin-top: 15px;
    font-family: monospace;
    font-size: 14px;
    border-left: 4px solid #667eea;
    line-height: 1.6;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

/* Pause Context Menu Styles */
.pause-context-menu {
    position: fixed;
    z-index: 10000;
    background: #fff;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    padding: 8px 0;
    min-width: 150px;
    font-size: 14px;
    color: #4a5568;
}

.pause-context-menu-item {
    padding: 8px 16px;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.pause-context-menu-item:hover {
    background-color: #f7fafc;
}

/* Markdown rendering styles */
.markdown-preview {
    background: #f7fafc;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    padding: 20px;
    margin: 15px 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    line-height: 1.6;
}

.markdown-preview .md-h1 {
    color: #2d3748;
    border-bottom: 2px solid #667eea;
    padding-bottom: 10px;
    margin: 20px 0 15px 0;
}

.markdown-preview .md-h2 {
    color: #2d3748;
    border-bottom: 1px solid #e2e8f0;
    padding-bottom: 5px;
    margin: 18px 0 12px 0;
}

.markdown-preview .md-h3 {
    color: #4a5568;
    margin: 15px 0 10px 0;
}

.markdown-preview .md-blockquote {
    border-left: 4px solid #667eea;
    padding-left: 15px;
    margin: 15px 0;
    color: #718096;
    font-style: italic;
    background: rgba(102, 126, 234, 0.05);
    padding: 10px 15px;
    border-radius: 0 4px 4px 0;
}

.markdown-preview .md-code {
    background: #edf2f7;
    padding: 2px 6px;
    border-radius: 4px;
    font-family: 'Monaco', 'Consolas', monospace;
    font-size: 14px;
}

.markdown-preview .md-list {
    margin: 10px 0;
    padding-left: 30px;
}

.markdown-preview .md-paragraph {
    margin: 10px 0;
}

.markdown-preview .md-hr {
    border: none;
    border-top: 1px solid #e2e8f0;
    margin: 20px 0;
}

.markdown-preview .md-preview-more {
    color: #718096;
    font-style: italic;
    text-align: center;
    margin: 15px 0 5px 0;
}

/* Compact markdown styles for inline use */
.md-paragraph {
    margin: 8px 0;
}

.md-paragraph:first-child {
    margin-top: 0;
}

.md-paragraph:last-child {
    margin-bottom: 0;
}

.md-list {
    margin: 8px 0;
}

.md-list li {
    margin: 3px 0;
}

.md-blockquote {
    margin: 8px 0;
}

.report-format-tabs {
    display: flex;
    margin-bottom: 15px;
    border-bottom: 1px solid #e2e8f0;
}

.format-tab {
    padding: 10px 20px;
    border: none;
    background: none;
    cursor: pointer;
    font-weight: 600;
    color: #718096;
    border-bottom: 2px solid transparent;
    transition: all 0.3s ease;
}

.format-tab:hover {
    color: #4a5568;
}

.format-tab.active {
    color: #667eea;
    border-bottom-color: #667eea;
}

.report-preview-container {
    margin-top: 20px;
    background: #f7fafc;
    border-radius: 8px;
    padding: 20px;
    border: 1px solid #e2e8f0;
}

.report-preview-content {
    margin-top: 10px;
    background: white;
    padding: 15px;
    border-radius: 5px;
    border: 1px solid #e2e8f0;
    max-height: 500px;
    overflow-y: auto;
    white-space: pre-wrap;
    font-family: monospace;
}

.dark-mode .report-preview-container {
    background: #2d3748;
    border-color: #4a5568;
}

.dark-mode .report-preview-content {
    background: #1a202c;
    border-color: #4a5568;
    color: #e2e8f0;
}

/* Ensure transitions work smoothly for pause button */
.nav-btn {
    transition: all 0.3s ease, background 1s ease-out;
}

/* Fixed width for pause button to prevent wiggling */
#pauseButton {
    min-width: 180px;
    text-align: center;
}

/* Pomodoro button styling */
.pomodoro-btn {
    background: #f56565 !important;
    min-width: 160px;
    text-align: center;
}
.pomodoro-btn:hover {
    background: #e53e3e !important;
}
.pomodoro-btn.active {
    background: #c53030 !important;
    animation: pulse 2s infinite;
}
.pomodoro-btn.breaking {
    background: #0891b2 !important;
}
.pomodoro-btn.breaking:hover {
    background: #0e7490 !important;
}

/* Responsive layout with natural wrapping */
@media (max-width: 640px) {
    .container {
        padding: 10px;
    }
    
    /* Allow natural wrapping but keep flex direction row */
    .nav {
        justify-content: space-around;
        gap: 8px;
    }
    
    .nav-left, .nav-right {
        flex-wrap: wrap;
        gap: 8px;
    }
    
    /* Make nav buttons more compact but maintain readability */
    .nav-btn {
        padding: 8px 12px;
        font-size: 13px;
        min-width: auto;
        max-width: 150px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    #pauseButton {
        min-width: 90px;
        max-width: 140px;
    }
    
    .pomodoro-btn {
        min-width: 80px;
        max-width: 120px;
    }
    
    .entry-item {
        flex-direction: column;
        gap: 15px;
        padding: 15px;
    }
    
    .entry-actions {
        align-self: flex-end;
        flex-wrap: wrap;
        gap: 6px;
    }
    
    .entry-actions .btn {
        padding: 6px 10px;
        font-size: 12px;
    }

    .report-navigation {
        flex-wrap: wrap;
        gap: 10px;
        padding: 15px;
    }

    .week-display {
        min-width: 120px;
        font-size: 14px;
        padding: 8px 12px;
    }

    .settings-grid {
        grid-template-columns: 1fr;
        gap: 15px;
    }

    .data-management-grid {
        grid-template-columns: 1fr;
        gap: 15px;
    }

    .time-inputs {
        grid-template-columns: 1fr;
        gap: 10px;
    }

    .activity-days-grid {
        grid-template-columns: 1fr;
        gap: 6px;
    }

    .reminder-buttons {
        justify-content: center;
        gap: 8px;
    }

    .card-actions {
        justify-content: center;
        gap: 8px;
        flex-wrap: wrap;
    }
    
    .card-actions .btn {
        font-size: 13px;
        padding: 8px 12px;
    }
    
    /* Form improvements for mobile */
    .form-group-row {
        flex-direction: column;
        gap: 10px;
    }
    
    .form-group input,
    .form-group select,
    .form-group textarea {
        font-size: 16px; /* Prevents zoom on iOS */
    }
    
    /* Due date quick sets wrap better on mobile */
    .due-date-quick-sets {
        justify-content: center;
    }
    
    .todo-quick-set {
        justify-content: center;
    }
    
    /* Search improvements - allow natural wrapping */
    .search-container {
        gap: 8px;
        justify-content: center;
    }
    
    #globalSearch {
        min-width: 200px;
        max-width: 300px;
        font-size: 16px; /* Prevents zoom on iOS */
    }
    
    .hashtag-browser-btn {
        padding: 12px 14px;
        flex-shrink: 0;
    }
    
    /* Filter improvements */
    .filter-row {
        flex-direction: column;
        gap: 10px;
        align-items: stretch;
    }
    
    .filter-group {
        justify-content: space-between;
    }
    
    .filter-group select {
        min-width: 120px;
    }
    
    /* Todo and entry tag improvements */
    .todo-tags,
    .entry-tags {
        justify-content: flex-start;
    }
    
    /* Pagination improvements */
    .todo-pagination,
    .entries-pagination,
    .search-pagination {
        flex-wrap: wrap;
        gap: 10px;
        padding: 15px 0;
    }
    
    /* Settings card improvements */
    .settings-card {
        padding: 20px 15px;
    }
    
    .settings-card h3 {
        font-size: 1rem;
    }
    
    /* Status banner improvements */
    .status-banner {
        margin: 0 auto 15px auto;
        padding: 15px;
    }
    
    .status-section {
        flex-direction: column;
        gap: 10px;
        align-items: stretch;
        padding: 12px;
    }
    
    .status-info {
        flex-direction: column;
        gap: 10px;
        align-items: stretch;
    }
    
    .status-controls {
        justify-content: center;
    }
}

/* Intermediate breakpoint for medium screens */
@media (max-width: 900px) and (min-width: 641px) {
    /* Slightly reduce button padding while maintaining consistency */
    .nav-btn {
        padding: 9px 18px;
        font-size: 14px;
    }
    
    #pauseButton {
        min-width: 120px;
    }
    
    /* Optimize search container */
    .search-container {
        gap: 8px;
    }
    
    #globalSearch {
        min-width: 180px;
    }
    
    .hashtag-browser-btn {
        padding: 12px 14px;
    }
}

/* Additional mobile improvements for very small screens */
@media (max-width: 480px) {
    .container {
        padding: 8px;
    }
    
    /* Very narrow screens - keep wrapping natural */
    .search-container {
        justify-content: center;
        gap: 8px;
    }
    
    #globalSearch {
        min-width: 120px;
        max-width: 180px;
    }
    
    .nav-btn {
        padding: 6px 10px;
        font-size: 12px;
        max-width: 120px;
    }
    
    #pauseButton {
        max-width: 100px;
    }
    
    .hashtag-browser-btn {
        padding: 10px 12px;
    }
    
    .header,
    .section {
        border-radius: 10px;
        margin-bottom: 15px;
    }
    
    .nav-btn {
        padding: 6px 10px;
        font-size: 13px;
    }
    
    #pauseButton {
        min-width: 100px;
    }
    
    .pomodoro-btn {
        min-width: 90px;
    }
    
    /* Make modals take full width on very small screens */
    .modal-content {
        width: 95%;
        max-width: none;
        margin: 10px;
    }
    
    .edit-modal-content {
        width: 95%;
        max-width: none;
    }
    
    .modal-header {
        padding: 15px 20px;
    }
    
    .modal-header h3 {
        font-size: 1.1rem;
    }
    
    .modal-body {
        padding: 20px;
    }
    
    /* Compact entry items */
    .entry-item {
        padding: 12px;
    }
    
    .entry-activity {
        font-size: 16px;
    }
    
    .entry-description {
        font-size: 13px;
    }
    
    /* Compact todo items */
    .todo-item {
        padding: 15px;
    }
    
    .todo-activity {
        font-size: 15px;
    }
    
    .todo-description {
        font-size: 13px;
    }
    
    /* Better button sizing for small screens */
    .btn {
        padding: 10px 16px;
        font-size: 14px;
        margin-right: 8px;
        margin-bottom: 8px;
    }
    
    .btn-small {
        padding: 6px 10px;
        font-size: 12px;
        margin-right: 4px;
        margin-bottom: 4px;
    }
    
    .btn-quick-set {
        padding: 8px 12px;
        font-size: 12px;
    }
    
    /* Compact forms */
    .form-group {
        margin-bottom: 15px;
    }
    
    .form-group label {
        margin-bottom: 6px;
        font-size: 14px;
    }
    
    .form-group input,
    .form-group select,
    .form-group textarea {
        padding: 10px;
    }
    
    /* Compact settings cards */
    .settings-card {
        padding: 15px 12px;
    }
    
    .settings-card h3 {
        font-size: 0.95rem;
        margin-bottom: 6px;
    }
    
    .card-description {
        font-size: 13px;
        margin-bottom: 15px;
    }
    
    /* Compact debug info */
    .debug-info {
        padding: 12px;
        font-size: 12px;
    }
    
    /* Better hashtag cloud on mobile */
    .hashtag-cloud-item {
        margin: 3px 4px;
        padding: 3px 8px;
        font-size: 12px;
    }
    
    /* Notification improvements for mobile */
    .notification-stack {
        right: 10px;
        top: 10px;
    }
    
    .notification-toast {
        max-width: calc(100vw - 40px);
        padding: 10px 15px;
        font-size: 14px;
    }
    
    /* Report improvements */
    .report-preview-content {
        font-size: 11px;
        padding: 12px;
    }
    
    .week-display {
        min-width: 100px;
        font-size: 13px;
        padding: 6px 10px;
    }
}

/* Touch-friendly improvements for mobile */
@media (max-width: 768px) {
    /* Larger touch targets */
    .btn, button, .nav-btn {
        min-height: 44px;
        min-width: 44px;
    }
    
    .btn-quick-set {
        min-height: 36px;
        min-width: 36px;
    }
    
    /* Better touch targets for checkboxes */
    .checkbox-group {
        margin: 10px 0;
    }
    
    .checkbox-group input[type="checkbox"] {
        width: 18px;
        height: 18px;
        margin-right: 12px;
    }
    
    .checkbox-group label {
        padding: 8px 0;
        cursor: pointer;
    }
    
    /* Touch-friendly tag interactions */
    .todo-tag,
    .entry-tag,
    .search-result-tag,
    .hashtag-cloud-item {
        min-height: 32px;
        padding: 6px 12px;
        margin: 4px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
    }
    
    /* Better spacing for touch */
    .entry-actions .btn,
    .todo-actions .btn {
        margin: 4px;
        min-height: 36px;
        min-width: 60px;
    }
    
    /* Modal close button larger for touch */
    .btn-close {
        width: 44px;
        height: 44px;
        font-size: 20px;
        top: 10px;
        right: 10px;
    }
    
    /* Better pagination for touch */
    .todo-pagination .btn,
    .entries-pagination .btn,
    .search-pagination .btn {
        min-height: 44px;
        min-width: 44px;
        margin: 4px;
    }
}

/* Prevent text selection on UI elements */
.nav-btn,
.btn,
.btn-quick-set,
.todo-tag,
.entry-tag,
.hashtag-cloud-item {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

/* Better focus states for keyboard and touch navigation */
@media (max-width: 768px) {
    .btn:focus,
    .nav-btn:focus,
    input:focus,
    select:focus,
    textarea:focus {
        outline: 2px solid #667eea;
        outline-offset: 2px;
    }
    
    /* Remove webkit tap highlight */
    .btn,
    .nav-btn,
    .btn-quick-set,
    .todo-tag,
    .entry-tag {
        -webkit-tap-highlight-color: transparent;
    }
}

/* Dark Mode Styles */
body.dark-mode {
    background: linear-gradient(135deg, #1a1f3a 0%, #2d1b4e 50%, #1a0b2e 100%);
    color: #e2e8f0;
}

.dark-mode .header,
.dark-mode .section {
    background: rgba(45, 55, 72, 0.85);
    backdrop-filter: blur(10px);
    color: #e2e8f0;
}

.dark-mode .form-group label {
    color: #a0aec0;
}

.dark-mode .form-group input,
.dark-mode .form-group select,
.dark-mode .form-group textarea {
    background: #2d3748;
    border-color: #4a5568;
    color: #e2e8f0;
}

.dark-mode .form-group input:focus,
.dark-mode .form-group select:focus,
.dark-mode .form-group textarea:focus {
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
}

.dark-mode .entry-item {
    background: #2d3748;
    border-color: #4a5568;
}

.dark-mode .entry-description {
    color: #a0aec0;
}

.dark-mode .entry-item.entry-overdue {
    background: #2d1b1e;
}

.dark-mode .entry-due-date {
    color: #718096;
}

.dark-mode .entry-todo-indicator {
    color: #fc8181;
}

.dark-mode .entry-note-indicator {
    color: #63b3ed;
}

/* Dark mode pause context menu */
.dark-mode .pause-context-menu {
    background: #2d3748;
    border-color: #4a5568;
    color: #e2e8f0;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

.dark-mode .pause-context-menu-item:hover {
    background-color: #1a202c;
}

.dark-mode .hashtag-link {
    color: #68d391;
}

.dark-mode .hashtag-link:hover {
    color: #9ae6b4;
}

.dark-mode .external-link {
    color: #63b3ed;
}

.dark-mode .external-link:hover {
    color: #90cdf4;
}

/* Dark mode todo styles */
.dark-mode .todo-filters {
    background: #1a202c;
    border-color: #4a5568;
}

/* Dark mode notes styles */
.dark-mode .notes-filters {
    background: #1a202c;
    border-color: #4a5568;
}

.dark-mode .filter-group label {
    color: #a0aec0;
}

.dark-mode .filter-group select {
    background: #2d3748;
    border-color: #4a5568;
    color: #e2e8f0;
}

.dark-mode .filter-group input {
    background: #2d3748;
    border-color: #4a5568;
    color: #e2e8f0;
}

.dark-mode .filter-group input:focus {
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
}

.dark-mode .todo-stats {
    color: #a0aec0;
}

.dark-mode .todo-item {
    background: #2d3748;
    border-color: #4a5568;
}

.dark-mode .todo-item.todo-incomplete {
    border-color: #e53e3e;
}

.dark-mode .todo-item.todo-overdue {
    background: #2d1b1e;
    border-color: #c53030;
}

.dark-mode .todo-activity {
    color: #e2e8f0;
}

.dark-mode .todo-description {
    color: #a0aec0;
}

.dark-mode .todo-meta {
    color: #718096;
}

.dark-mode .empty-state {
    color: #718096;
}

/* Dark mode search styles */
.dark-mode #globalSearch {
    background: #2d3748;
    border-color: #4a5568;
    color: #e2e8f0;
}

.dark-mode #globalSearch:focus {
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2), 0 4px 20px rgba(0, 0, 0, 0.3);
}

.dark-mode .search-results {
    background: #2d3748;
    border-color: #4a5568;
}

.dark-mode .search-suggestion {
    border-bottom-color: #1a202c;
}

.dark-mode .search-suggestion:hover {
    background: #1a202c;
}

.dark-mode .search-suggestion-meta {
    color: #718096;
}

.dark-mode .search-controls {
    background: #1a202c;
    border-color: #4a5568;
}

.dark-mode .search-info {
    color: #a0aec0;
}

.dark-mode .search-result-item {
    background: #2d3748;
    border-color: #4a5568;
}

.dark-mode .search-result-activity {
    color: #e2e8f0;
}

.dark-mode .search-result-description {
    color: #a0aec0;
}

.dark-mode .search-result-meta {
    color: #718096;
}

.dark-mode .btn-quick-set {
    background: #4a5568;
    color: #a0aec0;
    border-color: #2d3748;
}

.dark-mode .btn-quick-set:hover {
    background: #2d3748;
    border-color: #1a202c;
}

.dark-mode .btn-quick-set.active {
    background: #38a169;
    color: white;
    border-color: #2f855a;
}

.dark-mode .btn-quick-set.active:hover {
    background: #2f855a;
    border-color: #276749;
}

.dark-mode .settings-section {
    background: #1a202c;
    border-color: #4a5568;
}

.dark-mode .settings-section h3 {
    color: #e2e8f0;
}

.dark-mode .settings-description {
    color: #a0aec0;
}

.dark-mode .settings-toggles {
    border-top-color: #4a5568;
}

.dark-mode .settings-card {
    background: #2d3748;
    border-color: #4a5568;
}

.dark-mode .settings-card:hover {
    border-color: #667eea;
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.25);
}

.dark-mode .settings-card h3 {
    color: #e2e8f0;
}

.dark-mode .card-description {
    color: #a0aec0;
}

.dark-mode .report-filters {
    background: #2d3748;
}

.dark-mode .week-display {
    background: #2d3748;
    color: #e2e8f0;
}

.dark-mode .report-summary {
    background: #2c5282;
    color: #bee3f8;
    border-left-color: #63b3ed;
}

.dark-mode .download-section {
    background: #22543d;
    color: #f0fff4;
    border-left-color: #68d391;
}

.dark-mode .download-section label {
    color: #c6f6d5;
}

.dark-mode .debug-info {
    background: #1a202c;
    border-left-color: #667eea;
}

.dark-mode .markdown-preview {
    background: #1a202c;
    border-color: #4a5568;
}

.dark-mode .markdown-preview .md-h1,
.dark-mode .markdown-preview .md-h2,
.dark-mode .markdown-preview .md-h3 {
    color: #e2e8f0;
}

.dark-mode .markdown-preview .md-blockquote {
    color: #a0aec0;
    background: rgba(102, 126, 234, 0.1);
    border-left-color: #667eea;
}

.dark-mode .markdown-preview .md-code {
    background: #2d3748;
    color: #e2e8f0;
}

.dark-mode .format-tab {
    color: #a0aec0;
}

.dark-mode .format-tab:hover {
    color: #e2e8f0;
}

.dark-mode .format-tab.active {
    color: #667eea;
    border-bottom-color: #667eea;
}

.dark-mode .preview-format-tabs {
    border-color: #4a5568;
}

.dark-mode .preview-tab {
    background: #2d3748;
    color: #a0aec0;
}

.dark-mode .preview-tab:hover {
    background: #1a202c;
    color: #e2e8f0;
}

.dark-mode .preview-tab.active {
    background: #667eea;
    color: white;
}

.dark-mode .template-editor-tabs {
    border-bottom-color: #4a5568;
}

.dark-mode .template-tab {
    color: #a0aec0;
}

.dark-mode .template-tab:hover {
    color: #e2e8f0;
    background: #1a202c;
}

.dark-mode .template-tab.active {
    color: #667eea;
    border-bottom-color: #667eea;
    background: #3d4852;
}

/* Template Management Overlay */
.template-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 2000;
    backdrop-filter: blur(5px);
}

.template-overlay.active {
    display: flex;
    align-items: center;
    justify-content: center;
}

.template-overlay-content {
    background: white;
    border-radius: 15px;
    width: 95%;
    max-width: 1400px;
    height: 90%;
    max-height: 900px;
    display: flex;
    flex-direction: column;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
}

.template-manager-header {
    padding: 15px 20px;
    border-bottom: 1px solid #e2e8f0;
    display: flex;
    align-items: center;
    border-radius: 15px 15px 0 0;
    flex-shrink: 0;
    background: #f8f9fa;
}

.template-manager-header h2 {
    margin: 0;
    color: #2d3748;
    font-size: 1.25rem;
    flex: 1;
}

.template-manager-actions {
    display: flex;
    gap: 10px;
    align-items: center;
}

.template-manager-actions .btn {
    font-size: 0.875rem;
    padding: 8px 16px;
}

.btn-close {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: #718096;
    padding: 5px 10px;
    border-radius: 5px;
    transition: all 0.2s ease;
}

.btn-close:hover {
    background: #f7fafc;
    color: #2d3748;
}

.template-manager-body {
    flex: 1;
    display: grid;
    grid-template-columns: 300px 1fr;
    min-height: 0;
    overflow: hidden;
}

.template-list-panel {
    border-right: 1px solid #e2e8f0;
    padding: 20px;
    display: flex;
    flex-direction: column;
    background: #f7fafc;
    overflow-y: auto;
}

.template-list-panel h3 {
    margin: 0 0 15px 0;
    color: #2d3748;
}

.template-list {
    flex: 1;
    overflow-y: auto;
    margin-bottom: 15px;
}

.template-list-item {
    padding: 12px 15px;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    margin-bottom: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    background: white;
}

.template-list-item:hover {
    border-color: #667eea;
    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1);
}

.template-list-item.active {
    border-color: #667eea;
    background: #f0f2ff;
    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
}

.template-list-item.default::after {
    content: " (Default)";
    color: #38a169;
    font-weight: 600;
    font-size: 12px;
}

.template-list-item-name {
    font-weight: 600;
    color: #2d3748;
    margin-bottom: 2px;
}

.template-list-item-desc {
    font-size: 12px;
    color: #718096;
}

.template-list-item-type {
    font-size: 11px;
    color: #667eea;
    text-transform: uppercase;
    font-weight: 600;
    margin-top: 4px;
}

.template-list-actions {
    display: flex;
    gap: 10px;
}

.template-editor-panel {
    padding: 20px;
    display: flex;
    flex-direction: column;
    min-height: 0;
    overflow: hidden;
}

.template-editor-tabs {
    display: flex;
    border-bottom: 1px solid #e2e8f0;
    margin-bottom: 20px;
    margin-top: 15px;
}

.template-tab {
    padding: 10px 20px;
    border: none;
    background: none;
    cursor: pointer;
    font-weight: 600;
    color: #718096;
    border-bottom: 2px solid transparent;
    transition: all 0.3s ease;
}

.template-tab:hover {
    color: #4a5568;
    background: #f7fafc;
}

.template-tab.active {
    color: #667eea;
    border-bottom-color: #667eea;
    background: #f0f2ff;
}

.template-editor-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

.template-editor-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.template-editor-header h3 {
    margin: 0;
    color: #2d3748;
}

.template-editor-actions {
    display: flex;
    gap: 10px;
}

.template-editor-form {
    flex: 1;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
}

.template-editor-form #templateContent {
    font-family: 'Monaco', 'Consolas', monospace;
    font-size: 13px;
    resize: vertical;
    min-height: 200px;
}

.template-preview-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

.template-preview-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.template-preview-controls {
    display: flex;
    align-items: center;
    gap: 15px;
}

.preview-format-tabs {
    display: flex;
    border: 1px solid #e2e8f0;
    border-radius: 6px;
    overflow: hidden;
}

.preview-tab {
    padding: 6px 12px;
    border: none;
    background: white;
    cursor: pointer;
    font-size: 12px;
    font-weight: 600;
    color: #718096;
    transition: all 0.2s ease;
}

.preview-tab:hover {
    background: #f7fafc;
    color: #4a5568;
}

.preview-tab.active {
    background: #667eea;
    color: white;
}

.report-preview-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.report-preview-header h3 {
    margin: 0;
}

.template-preview-header h4 {
    margin: 0;
    color: #2d3748;
}

.btn-small {
    padding: 6px 12px;
    font-size: 14px;
}

.template-preview-content {
    flex: 1;
    background: #f7fafc;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    padding: 15px;
    overflow-y: auto;
    font-family: monospace;
    font-size: 12px;
    white-space: pre-wrap;
}

.template-preview-placeholder {
    color: #718096;
    font-style: italic;
    text-align: center;
    margin-top: 50px;
}

.template-manager-footer {
    padding: 20px 30px;
    border-top: 1px solid #e2e8f0;
    display: flex;
    justify-content: flex-end;
    gap: 15px;
    border-radius: 0 0 15px 15px;
}

.template-management-preview {
    margin-top: 15px;
}

.template-preview-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 15px;
    margin-bottom: 20px;
}

.template-preview-card {
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    padding: 15px;
    transition: all 0.2s ease;
}

.template-preview-card:hover {
    border-color: #667eea;
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
}

.template-preview-card.default {
    border-color: #38a169;
    background: #f0fff4;
}

.template-preview-card-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 10px;
}

.template-preview-card-name {
    font-weight: 600;
    color: #2d3748;
    margin-bottom: 2px;
}

.template-preview-card-type {
    font-size: 11px;
    color: #667eea;
    text-transform: uppercase;
    font-weight: 600;
    background: #e6f3ff;
    padding: 2px 6px;
    border-radius: 3px;
}

.template-preview-card-desc {
    font-size: 13px;
    color: #718096;
    margin-bottom: 10px;
}

.template-preview-card-sample {
    background: #f7fafc;
    border: 1px solid #e2e8f0;
    border-radius: 4px;
    padding: 8px;
    font-family: monospace;
    font-size: 11px;
    max-height: 60px;
    overflow: hidden;
    position: relative;
}

.template-preview-card-sample::after {
    content: "";
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 20px;
    background: linear-gradient(transparent, #f7fafc);
}

.template-actions {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

/* Dark Mode Styles for Template Manager */
.dark-mode .template-overlay-content {
    background: #2d3748;
}

.dark-mode .template-manager-header {
    border-bottom-color: #4a5568;
    background: #1a202c;
}

.dark-mode .template-manager-header h2 {
    color: #e2e8f0;
}

.dark-mode .btn-close {
    color: #a0aec0;
}

.dark-mode .btn-close:hover {
    background: #1a202c;
    color: #e2e8f0;
}

.dark-mode .template-list-panel {
    background: #1a202c;
    border-right-color: #4a5568;
}

.dark-mode .template-list-panel h3 {
    color: #e2e8f0;
}

.dark-mode .template-list-item {
    background: #2d3748;
    border-color: #4a5568;
}

.dark-mode .template-list-item:hover {
    border-color: #667eea;
    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
}

.dark-mode .template-list-item.active {
    background: #3d4852;
}

.dark-mode .template-list-item-name {
    color: #e2e8f0;
}

.dark-mode .template-list-item-desc {
    color: #a0aec0;
}

.dark-mode .template-editor-header h3 {
    color: #e2e8f0;
}

.dark-mode .template-preview-header h4 {
    color: #e2e8f0;
}

.dark-mode .template-preview-content {
    background: #1a202c;
    border-color: #4a5568;
    color: #e2e8f0;
}

.dark-mode .template-manager-footer {
    border-top-color: #4a5568;
}

.dark-mode .template-preview-card {
    background: #2d3748;
    border-color: #4a5568;
}

.dark-mode .template-preview-card-name {
    color: #e2e8f0;
}

.dark-mode .template-preview-card-desc {
    color: #a0aec0;
}

.dark-mode .template-preview-card-sample {
    background: #1a202c;
    border-color: #4a5568;
    color: #e2e8f0;
}

.dark-mode .template-preview-card-sample::after {
    background: linear-gradient(transparent, #1a202c);
}

/* Toast Animation */
@keyframes slideInToastDown {
    0% {
        transform: translateX(400px) translateY(-100%);
        opacity: 0;
    }
    50% {
        transform: translateX(400px) translateY(0);
        opacity: 0.7;
    }
    100% {
        transform: translateX(0) translateY(0);
        opacity: 1;
    }
}

.notification-toast.removing {
    animation: slideOutToast 0.3s ease-in forwards;
}

@keyframes slideOutToast {
    0% {
        transform: translateX(0) translateY(0);
        opacity: 1;
    }
    100% {
        transform: translateX(400px) translateY(0);
        opacity: 0;
    }
}

/* Additional button styles */
.btn-info {
    background: #3182ce;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: 500;
}

.btn-info:hover {
    background: #2c5282;
    transform: translateY(-1px);
}

.btn-small {
    padding: 6px 12px;
    font-size: 0.875rem;
}

/* Reports Grid Layout */
.reports-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-bottom: 20px;
}

.reports-section {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.reports-section h3 {
    margin: 0 0 16px 0;
    padding-bottom: 6px;
    color: #4a5568;
    font-size: 1.1rem;
    font-weight: 600;
}

.report-navigation-section {
    margin-bottom: 20px;
}

.report-templates-section {
    margin-top: 30px;
    padding-top: 20px;
    border-top: 1px solid #e2e8f0;
}

.report-templates-section .settings-card {
    max-width: none; /* Allow full width in reports section */
}

.report-navigation-section .report-navigation {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    border: 1px solid rgba(255, 255, 255, 0.2);
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 20px;
}

.week-display {
    font-weight: 600;
    color: #4a5568;
    text-align: center;
    flex: 1;
}

/* Dark mode for navigation */
.dark-mode .report-navigation-section .report-navigation {
    background: #2d3748;
    color: #e2e8f0;
    border-color: #4a5568;
}

.dark-mode .week-display {
    color: #cbd5e0;
}

.report-actions,
.download-actions {
    margin-top: 15px;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.preview-controls {
    display: flex;
    align-items: center;
    gap: 15px;
}

/* Copy Report Button Styling */
.btn-copy-report {
    background: #38a169;
    color: white;
    border: 2px solid transparent;
    padding: 6px 12px;
    font-size: 0.875rem;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: 500;
}

.btn-copy-report:hover {
    background: #2f855a;
    transform: translateY(-1px);
}

/* Dark mode for reports */
.dark-mode .reports-section {
    background: #2d3748;
    color: #e2e8f0;
    border-color: #4a5568;
}

.dark-mode .reports-section h3 {
    color: #cbd5e0;
}

.dark-mode .report-templates-section {
    border-top-color: #4a5568;
}

/* Workspace Manager Styles */
.workspace-manager-content {
    max-width: 600px;
    width: 90vw;
}

.current-workspace {
    margin-bottom: 24px;
    padding: 16px;
    background: #f7fafc;
    border-radius: 8px;
    border-left: 4px solid #667eea;
}

.workspace-description {
    color: #718096;
    font-size: 0.9rem;
    margin: 8px 0 0 0;
}

.workspace-list-section {
    margin-bottom: 24px;
}

.workspace-list {
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    overflow: hidden;
}

.workspace-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    border-bottom: 1px solid #e2e8f0;
    transition: background-color 0.2s ease;
}

.workspace-item:last-child {
    border-bottom: none;
}

.workspace-item:hover {
    background: #f7fafc;
}

.workspace-item.current {
    background: #e6fffa;
    border-left: 4px solid #38b2ac;
}

.workspace-item .workspace-info {
    display: flex;
    align-items: center;
    gap: 12px;
}

.workspace-name {
    font-weight: 600;
    color: #2d3748;
}

.current-badge {
    background: #38b2ac;
    color: white;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.75rem;
    font-weight: 500;
}

.workspace-actions {
    border-top: 1px solid #e2e8f0;
    padding-top: 20px;  
    margin-top: 8px;
}

.workspace-item .workspace-actions {
    display: flex;
    gap: 8px;
    align-items: center;
    border-top: none;
    padding-top: 0;
    margin-top: 0;
}

.create-workspace {
    display: flex;
    gap: 12px;
    align-items: center;
    margin-bottom: 16px;
}

.create-workspace input {
    flex: 1;
    min-width: 200px;
    padding: 10px 12px;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    font-size: 14px;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
    background: white;
}

.create-workspace input:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.create-workspace input::placeholder {
    color: #9ca3af;
}

.empty-state {
    text-align: center;
    color: #718096;
    padding: 32px 16px;
    font-style: italic;
}

/* Dark mode workspace styles */
.dark-mode .current-workspace {
    background: #2d3748;
    border-left-color: #667eea;
}

.dark-mode .workspace-list {
    border-color: #4a5568;
}

.dark-mode .workspace-item {
    border-bottom-color: #4a5568;
}

.dark-mode .workspace-item:hover {
    background: #2d3748;
}

.dark-mode .workspace-item.current {
    background: #234e52;
    border-left-color: #38b2ac;
}

.dark-mode .workspace-name {
    color: #e2e8f0;
}

.dark-mode .workspace-description {
    color: #a0aec0;
}

.dark-mode .empty-state {
    color: #a0aec0;
}

.dark-mode .create-workspace input {
    background: #2d3748;
    border-color: #4a5568;
    color: #e2e8f0;
}

.dark-mode .create-workspace input:focus {
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
}

.dark-mode .create-workspace input::placeholder {
    color: #718096;
}

.dark-mode .workspace-actions {
    border-top-color: #4a5568;
}

@media (max-width: 768px) {
    .reports-grid {
        grid-template-columns: 1fr;
    }
    
    .settings-grid-three-col {
        grid-template-columns: 1fr !important;
        gap: 15px;
    }
    
    .settings-grid-four-col {
        grid-template-columns: 1fr !important;
        gap: 15px;
    }
    
    /* Fix date/time picker width on mobile */
    input[type="date"],
    input[type="datetime-local"],
    input[type="time"] {
        max-width: calc(100% - 20px);
        width: 100%;
        box-sizing: border-box;
    }
    
    /* Increase font sizes for better mobile readability */
    body {
        font-size: 16px;
    }
    
    .btn, button {
        font-size: 16px;
    }
    
    .nav-btn {
        font-size: 15px;
    }
    
    input, textarea, select {
        font-size: 16px;
    }
    
    .activity-list-item {
        font-size: 15px;
    }
    
    .activity-list-item .timestamp {
        font-size: 14px;
    }
    
    .settings-section h3 {
        font-size: 20px;
    }
    
    .settings-section p {
        font-size: 15px;
    }
    
    label {
        font-size: 15px;
    }
}

/* Settings Grid Two Column */
.settings-grid-two-col {
    grid-template-columns: 1fr 1fr !important;
}

.settings-grid-three-col {
    grid-template-columns: 1fr 1fr 1fr !important;
    gap: 20px;
}

.settings-grid-four-col {
    grid-template-columns: 1fr 1fr !important;
    gap: 20px;
}

.general-settings {
    background: rgba(59, 130, 246, 0.05);
    border: 1px solid rgba(59, 130, 246, 0.2);
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 30px;
}

.general-settings h3 {
    color: #2563eb;
    margin-bottom: 8px;
}

.dark-mode .general-settings {
    background: rgba(59, 130, 246, 0.1);
    border-color: rgba(59, 130, 246, 0.3);
}

.dark-mode .general-settings h3 {
    color: #60a5fa;
}

/* Schedule Section Styling */
.schedule-section {
    margin-bottom: 20px;
}

.schedule-section h4 {
    margin: 0 0 12px 0;
    padding-bottom: 4px;
    color: #4a5568;
    font-size: 1rem;
    font-weight: 600;
}

.dark-mode .schedule-section h4 {
    color: #cbd5e0;
}

/* Pomodoro Section */
.pomodoro-section {
    margin-bottom: 20px;
}

.pomodoro-settings {
    margin-top: 15px;
}

.pomodoro-config {
    margin-top: 15px;
    padding: 15px;
    background: rgba(255, 255, 255, 0.5);
    border-radius: 8px;
    border-left: 4px solid #667eea;
}

.dark-mode .pomodoro-config {
    background: rgba(0, 0, 0, 0.2);
    border-left-color: #764ba2;
}

.pomodoro-timers {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin-bottom: 15px;
}

.pomodoro-options {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

/* Enhanced Pomodoro Status Section */
.pomodoro-status-section {
    margin-bottom: 20px;
    padding: 15px;
    background: rgba(0, 0, 0, 0.05);
    border-radius: 8px;
    text-align: center;
}
.dark-mode .pomodoro-status-section {
    background: rgba(255, 255, 255, 0.05);
}

.pomodoro-status {
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 10px;
    padding: 8px 12px;
    border-radius: 6px;
    transition: all 0.3s ease;
}
.pomodoro-status.disabled {
    color: #6b7280;
    background: rgba(107, 114, 128, 0.1);
}
.pomodoro-status.ready {
    color: #059669;
    background: rgba(5, 150, 105, 0.1);
}
.pomodoro-status.working {
    color: #dc2626;
    background: rgba(220, 38, 38, 0.1);
    animation: pulse 2s infinite;
}
.pomodoro-status.breaking {
    color: #0891b2;
    background: rgba(8, 145, 178, 0.1);
}

.pomodoro-status.paused {
    color: #f59e0b;
    background: rgba(245, 158, 11, 0.1);
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

/* Pomodoro Banner Styles */
.pomodoro-banner {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 15px 20px;
    margin: 0 -20px 20px -20px;
    text-align: center;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.pomodoro-banner-content {
    max-width: 1200px;
    margin: 0 auto;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
}

.pomodoro-banner-controls {
    display: flex;
    align-items: center;
    gap: 10px;
}

.pomodoro-pause-btn {
    background: rgba(255, 255, 255, 0.2);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 8px 16px;
    border-radius: 6px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.pomodoro-pause-btn:hover {
    background: rgba(255, 255, 255, 0.3);
    border-color: rgba(255, 255, 255, 0.5);
}

.pomodoro-pause-btn:active {
    background: rgba(255, 255, 255, 0.1);
}

.pomodoro-timer {
    display: flex;
    align-items: center;
    gap: 15px;
    font-size: 18px;
    font-weight: 600;
}

#pomodoroTimeRemaining {
    font-family: 'Courier New', monospace;
    font-size: 24px;
    font-weight: bold;
    background: rgba(255,255,255,0.2);
    padding: 8px 16px;
    border-radius: 8px;
    min-width: 80px;
}

/* Dark mode pomodoro styling */
.dark-mode .session-number {
    color: #a5b4fc;
}

.dark-mode .countdown-timer {
    background: #374151 !important;
    border-color: #4b5563;
}

.dark-mode .work-title {
    color: #f3f4f6;
}

.dark-mode .work-desc {
    color: #9ca3af;
}


/* Reminder Banner Styles */
.reminder-banner {
    background: linear-gradient(135deg, #059669 0%, #047857 100%);
    color: white;
    padding: 15px 20px;
    margin: 0 -20px 20px -20px;
    text-align: center;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.reminder-banner-content {
    max-width: 1200px;
    margin: 0 auto;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
}

.reminder-timer {
    display: flex;
    align-items: center;
    gap: 10px;
}

#reminderTimeRemaining {
    font-size: 20px;
    font-weight: bold;
    background: rgba(255, 255, 255, 0.2);
    padding: 8px 12px;
    border-radius: 8px;
    min-width: 80px;
}

.reminder-status {
    font-size: 16px;
    opacity: 0.9;
}

/* Dark mode reminder banner */
.dark-mode .reminder-banner {
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
}

/* Combined Status Banner - matches header style */
.status-banner {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 15px;
    padding: 20px;
    margin: 0 auto 20px auto;
    max-width: 1200px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    border: 1px solid rgba(0, 0, 0, 0.08);
}

.status-banner-content {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.status-section {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding: 16px;
    border-radius: 12px;
    transition: all 0.2s ease;
    gap: 16px;
}

.status-section:first-child:last-child {
    /* Only one section active */
    border-radius: 10px;
}

/* Pomodoro section styling */
#pomodoroStatusSection {
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
    border: 1px solid rgba(102, 126, 234, 0.2);
}

.pomodoro-bar {
    flex: 1;
}

.pomodoro-active-bar {
    display: flex;
    align-items: center;
    gap: 16px;
    height: 48px;
    padding: 8px 0;
}

.pomodoro-tomato {
    font-size: 32px;
    line-height: 1;
    flex-shrink: 0;
}

.session-number {
    font-size: 32px;
    font-weight: 700;
    color: #667eea;
    flex-shrink: 0;
    min-width: 48px;
}

.countdown-timer {
    background: #1f2937 !important;
    color: #ffffff !important;
    padding: 8px 16px;
    border-radius: 8px;
    font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
    font-size: 18px;
    font-weight: 600;
    flex-shrink: 0;
    min-width: 80px;
    text-align: center;
    border: 1px solid #374151;
}

.work-item {
    flex: 1;
    min-width: 0;
    margin-left: 8px;
}

.work-title {
    font-size: 16px;
    font-weight: 500;
    color: #374151;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.work-desc {
    font-size: 14px;
    color: #6b7280;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-top: 2px;
}

/* Reminder section styling */
#reminderStatusSection {
    background: linear-gradient(135deg, rgba(5, 150, 105, 0.1) 0%, rgba(4, 120, 87, 0.1) 100%);
    border: 1px solid rgba(5, 150, 105, 0.2);
}

.status-info {
    display: flex;
    align-items: flex-start;
    gap: 20px;
    flex: 1;
    min-width: 0; /* Allow text truncation */
}

.status-label {
    font-size: 16px;
    font-weight: 500;
    color: #374151;
}

/* Legacy styles - keeping for compatibility with other parts */
.status-timer {
    display: flex;
    flex-direction: column;
    gap: 8px;
    min-width: 0;
}

/* Mobile responsiveness */
@media (max-width: 768px) {
    .pomodoro-active-bar {
        gap: 12px;
        height: 44px;
    }
    
    .pomodoro-tomato {
        font-size: 24px;
    }
    
    .session-number {
        font-size: 24px;
        min-width: 36px;
    }
    
    .countdown-timer {
        font-size: 16px;
        padding: 6px 12px;
        min-width: 70px;
    }
    
    .work-title {
        font-size: 15px;
    }
    
    .work-desc {
        font-size: 13px;
    }
}

@media (max-width: 480px) {
    .pomodoro-active-bar {
        gap: 8px;
        flex-wrap: wrap;
        height: auto;
        padding: 8px 0;
    }
    
    .work-item {
        flex-basis: 100%;
        margin-left: 0;
        margin-top: 8px;
    }
}

.status-controls {
    display: flex;
    align-items: center;
    gap: 10px;
}

.status-button {
    background: rgba(102, 126, 234, 0.1);
    color: #667eea;
    border: 1px solid rgba(102, 126, 234, 0.3);
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

.status-button:hover {
    background: rgba(102, 126, 234, 0.2);
    border-color: rgba(102, 126, 234, 0.4);
}

.status-button:active {
    background: rgba(102, 126, 234, 0.3);
}

/* Dark mode status banner */
.dark-mode .status-banner {
    background: rgba(31, 41, 55, 0.95);
    border-color: rgba(255, 255, 255, 0.1);
}

.dark-mode .status-label {
    color: #e5e7eb;
}

.dark-mode #pomodoroStatusSection {
    background: linear-gradient(135deg, rgba(79, 70, 229, 0.2) 0%, rgba(124, 58, 237, 0.2) 100%);
    border-color: rgba(79, 70, 229, 0.3);
}

.dark-mode #reminderStatusSection {
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.2) 0%, rgba(5, 150, 105, 0.2) 100%);
    border-color: rgba(16, 185, 129, 0.3);
}

.dark-mode .status-button {
    background: rgba(79, 70, 229, 0.2);
    color: #a78bfa;
    border-color: rgba(79, 70, 229, 0.4);
}

.dark-mode .status-button:hover {
    background: rgba(79, 70, 229, 0.3);
    border-color: rgba(79, 70, 229, 0.5);
}

.pomodoro-controls {
    display: flex;
    justify-content: center;
    gap: 10px;
}

.pomodoro-hint {
    font-size: 12px;
    color: #6b7280;
    margin: 8px 0 0 0;
    font-style: italic;
}
.dark-mode .pomodoro-hint {
    color: #9ca3af;
}

/* Pomodoro Configuration Sections */
.pomodoro-config h4 {
    color: #374151;
    font-size: 14px;
    font-weight: 600;
    margin: 20px 0 10px 0;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    padding-bottom: 5px;
}
.dark-mode .pomodoro-config h4 {
    color: #d1d5db;
    border-bottom-color: rgba(255, 255, 255, 0.1);
}

.pomodoro-sounds {
    margin-bottom: 15px;
}
.pomodoro-sounds .form-group {
    margin-bottom: 10px;
}

.pomodoro-announce-sounds {
    margin-bottom: 15px;
}
.pomodoro-announce-sounds .form-group {
    margin-bottom: 10px;
}

.pomodoro-session-management {
    margin-top: 20px;
    padding: 15px;
    background: rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    border-left: 4px solid #ed8936;
}

.dark-mode .pomodoro-session-management {
    background: rgba(0, 0, 0, 0.1);
    border-left-color: #f56565;
}

.pomodoro-session-management h5 {
    color: #374151;
    font-size: 14px;
    font-weight: 600;
    margin: 0 0 15px 0;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.dark-mode .pomodoro-session-management h5 {
    color: #d1d5db;
}

.session-actions {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

@media (max-width: 768px) {
    .settings-grid-two-col {
        grid-template-columns: 1fr !important;
    }
    
    .pomodoro-timers {
        grid-template-columns: 1fr;
    }
}

/* Modal improvements */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    z-index: 1000;
    align-items: center;
    justify-content: center;
}

.modal[style*="block"] {
    display: flex !important;
}

.modal-content {
    background: white;
    padding: 0;
    border-radius: 15px;
    max-width: 500px;
    width: 90%;
    max-height: 90vh;
    overflow: hidden;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    position: relative;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px 30px;
    border-bottom: 1px solid #e2e8f0;
    background: #f8f9fa;
}

.modal-header h3 {
    margin: 0;
    color: #2d3748;
    font-size: 1.25rem;
}

.modal-body {
    padding: 30px;
    overflow-y: auto;
    max-height: calc(90vh - 140px);
}

.btn-close {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: #718096;
    padding: 5px 10px;
    border-radius: 5px;
    transition: all 0.2s ease;
    position: absolute;
    top: 15px;
    right: 15px;
    width: 35px;
    height: 35px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.btn-close:hover {
    background: #f7fafc;
    color: #2d3748;
}

/* Template Guide Modal */
.template-guide-content {
    max-width: 800px;
    max-height: 90vh;
    display: flex;
    flex-direction: column;
}

.template-guide-content .modal-body {
    overflow-y: auto;
    flex: 1;
}

/* Edit Modal */
.edit-modal-content {
    max-width: 650px;
    width: 95%;
}

@media (max-width: 768px) {
    .edit-modal-content {
        max-width: 500px;
        width: 90%;
    }
}

/* About Modal */
.about-modal-content {
    max-width: 800px;
}

/* User Guide Modal */
#userGuideModal .modal-content {
    max-width: 800px;
}

.about-section {
    margin-bottom: 25px;
}

/* Version History Styling */
.version-current {
    background: #f7fafc;
    padding: 12px 16px;
    border-radius: 8px;
    margin-bottom: 16px;
    border-left: 4px solid #667eea;
}

.version-history-list {
    max-height: 300px;
    overflow-y: auto;
}

.version-entry {
    padding: 12px 0;
    border-bottom: 1px solid #e2e8f0;
}

.version-entry:last-child {
    border-bottom: none;
}

.version-entry.current {
    background: #f0fff4;
    border-radius: 6px;
    padding: 12px;
    margin-bottom: 8px;
}

.version-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
}

.version-number {
    font-family: 'Monaco', 'Menlo', monospace;
    font-weight: 600;
    color: #4c51bf;
    font-size: 0.9em;
}

.version-date {
    color: #718096;
    font-size: 0.85em;
}

.version-summary {
    color: #4a5568;
    line-height: 1.4;
    font-size: 0.9em;
}

/* Dark mode version history */
.dark-mode .version-current {
    background: #2d3748;
    border-left-color: #667eea;
    color: #e2e8f0;
}

.dark-mode .version-entry {
    border-bottom-color: #4a5568;
}

.dark-mode .version-entry.current {
    background: #1a202c;
    color: #e2e8f0;
}

.dark-mode .version-number {
    color: #a78bfa;
}

.dark-mode .version-date {
    color: #a0aec0;
}

.dark-mode .version-summary {
    color: #cbd5e0;
}

.dark-mode .version-history-list h5 {
    color: #e2e8f0 !important;
}

.about-section h4 {
    color: #4a5568;
    margin: 0 0 15px 0;
    font-size: 1.1rem;
    font-weight: 600;
}

.diagnostic-buttons {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.diagnostic-buttons .btn {
    font-size: 0.875rem;
}

.about-section p {
    margin-bottom: 10px;
    line-height: 1.6;
}

/* User Guide Modal */
.user-guide-content {
    max-width: 700px;
}

.guide-section {
    margin-bottom: 30px;
    padding-bottom: 20px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.08);
}

.guide-section:last-child {
    border-bottom: none;
    margin-bottom: 0;
}

.guide-section h4 {
    color: #2d3748;
    margin: 0 0 12px 0;
    font-size: 1.1rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 8px;
}

.guide-section p {
    margin-bottom: 15px;
    line-height: 1.6;
    color: #4a5568;
}

.guide-section ul {
    margin: 0;
    padding-left: 20px;
    line-height: 1.7;
}

.guide-section li {
    margin-bottom: 8px;
    color: #4a5568;
}

.guide-section kbd {
    background: #f7fafc;
    border: 1px solid #e2e8f0;
    border-radius: 4px;
    padding: 2px 6px;
    font-family: monospace;
    font-size: 0.875rem;
    color: #2d3748;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

/* Dark mode user guide styles */
.dark-mode .guide-section {
    border-bottom-color: rgba(255, 255, 255, 0.1);
}

.dark-mode .guide-section h4 {
    color: #e2e8f0;
}

.dark-mode .guide-section p,
.dark-mode .guide-section li {
    color: #a0aec0;
}

.dark-mode .guide-section kbd {
    background: #4a5568;
    border-color: #718096;
    color: #e2e8f0;
}

.about-section ul {
    margin: 10px 0;
    padding-left: 20px;
}

.about-section li {
    margin-bottom: 5px;
    line-height: 1.5;
}

.template-guide-content h4 {
    color: #4a5568;
    margin: 20px 0 10px 0;
    font-size: 1.1rem;
}

.template-guide-content pre {
    background: #f7fafc;
    padding: 15px;
    border-radius: 6px;
    overflow-x: auto;
    margin: 10px 0;
}

.template-guide-content code {
    background: #edf2f7;
    padding: 2px 6px;
    border-radius: 3px;
    font-family: 'Monaco', 'Menlo', monospace;
    font-size: 0.875rem;
}

.template-guide-content pre code {
    background: none;
    padding: 0;
}

/* Dark mode modal styles */
.dark-mode .modal-content {
    background: #2d3748;
}

.dark-mode .modal-header {
    background: #1a202c;
    border-bottom-color: #4a5568;
}

.dark-mode .modal-header h3 {
    color: #e2e8f0;
}

.dark-mode .btn-close {
    color: #a0aec0;
}

.dark-mode .btn-close:hover {
    background: #1a202c;
    color: #e2e8f0;
}

.dark-mode .about-section h4,
.dark-mode .template-guide-content h4 {
    color: #cbd5e0;
}

.dark-mode .template-guide-content pre {
    background: #1a202c;
    color: #e2e8f0;
}

.dark-mode .template-guide-content code {
    background: #2d3748;
    color: #e2e8f0;
}

/* Dark Mode Input Icon Fixes */
.dark-mode input[type="date"],
.dark-mode input[type="datetime-local"],
.dark-mode input[type="time"] {
    color-scheme: dark;
    background-color: #2d3748;
    border-color: #4a5568;
    color: #e2e8f0;
}

/* Modern approach using color-scheme for date/time inputs */
input[type="date"],
input[type="datetime-local"],
input[type="time"] {
    color-scheme: light;
}

.dark-mode input[type="date"],
.dark-mode input[type="datetime-local"],
.dark-mode input[type="time"] {
    color-scheme: dark;
}

/* Alternative approach with custom background for calendar icons */
input[type="date"]::-webkit-calendar-picker-indicator,
input[type="datetime-local"]::-webkit-calendar-picker-indicator,
input[type="time"]::-webkit-calendar-picker-indicator {
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.2s ease;
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='%23333' d='M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5zM2 2a1 1 0 0 0-1 1v1h14V3a1 1 0 0 0-1-1H2zm13 3H1v9a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V5z'/%3e%3c/svg%3e");
    background-size: 16px 16px;
    background-repeat: no-repeat;
    background-position: center;
    width: 20px;
    height: 20px;
}

input[type="time"]::-webkit-calendar-picker-indicator {
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='%23333' d='M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z'/%3e%3cpath fill='%23333' d='M7.5 3a.5.5 0 0 1 .5.5v5.21l3.248 1.856a.5.5 0 0 1-.496.868L7.5 9.5a.5.5 0 0 1-.5-.5V3.5a.5.5 0 0 1 .5-.5z'/%3e%3c/svg%3e");
}

input[type="date"]::-webkit-calendar-picker-indicator:hover,
input[type="datetime-local"]::-webkit-calendar-picker-indicator:hover,
input[type="time"]::-webkit-calendar-picker-indicator:hover {
    opacity: 1;
}

/* Dark mode custom icons */
.dark-mode input[type="date"]::-webkit-calendar-picker-indicator,
.dark-mode input[type="datetime-local"]::-webkit-calendar-picker-indicator {
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='%23ffffff' d='M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5zM2 2a1 1 0 0 0-1 1v1h14V3a1 1 0 0 0-1-1H2zm13 3H1v9a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V5z'/%3e%3c/svg%3e");
    opacity: 0.8;
}

.dark-mode input[type="time"]::-webkit-calendar-picker-indicator {
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='%23ffffff' d='M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z'/%3e%3cpath fill='%23ffffff' d='M7.5 3a.5.5 0 0 1 .5.5v5.21l3.248 1.856a.5.5 0 0 1-.496.868L7.5 9.5a.5.5 0 0 1-.5-.5V3.5a.5.5 0 0 1 .5-.5z'/%3e%3c/svg%3e");
    opacity: 0.8;
}

.dark-mode input[type="date"]::-webkit-calendar-picker-indicator:hover,
.dark-mode input[type="datetime-local"]::-webkit-calendar-picker-indicator:hover,
.dark-mode input[type="time"]::-webkit-calendar-picker-indicator:hover {
    opacity: 1;
}

/* Firefox support - using custom background */
input[type="date"]::-moz-calendar-picker-indicator,
input[type="datetime-local"]::-moz-calendar-picker-indicator,
input[type="time"]::-moz-calendar-picker-indicator {
    cursor: pointer;
    opacity: 0.7;
    width: 20px;
    height: 20px;
}

.dark-mode input[type="date"]::-moz-calendar-picker-indicator,
.dark-mode input[type="datetime-local"]::-moz-calendar-picker-indicator,
.dark-mode input[type="time"]::-moz-calendar-picker-indicator {
    opacity: 0.8;
}

/* Debug color testing - development mode palette overrides */
body.debug-palette-override {
    --primary-color: #e40303;
    --secondary-color: #ff8c00;
    --accent-color: #ffed00;
    --success-color: #008018;
    --info-color: #0078d4;
    --warning-color: #732982;
    --bg-color: #f8f9fa;
    --text-color: #2d3748;
    --border-color: #e2e8f0;
}

body.debug-palette-override.dark-mode {
    --primary-color: #e40303;
    --secondary-color: #ff8c00;
    --accent-color: #ffed00;
    --success-color: #008018;
    --info-color: #0078d4;
    --warning-color: #732982;
    --bg-color: #1a202c;
    --text-color: #e2e8f0;
    --border-color: #4a5568;
}

/* Apply debug palette colors to buttons and elements */
body.debug-palette-override .btn {
    background: linear-gradient(45deg, var(--primary-color), var(--secondary-color), var(--accent-color), var(--success-color), var(--info-color), var(--warning-color));
    background-size: 300% 300%;
    animation: rainbow-shift 3s ease infinite;
    color: white;
    border: none;
}

body.debug-palette-override .header {
    background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--accent-color), var(--success-color), var(--info-color), var(--warning-color));
    animation: rainbow-shift 4s ease infinite;
}

body.debug-palette-override .hashtag-link {
    color: var(--accent-color);
}

body.debug-palette-override .entry-item {
    border-left: 4px solid var(--primary-color);
}

@keyframes rainbow-shift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

/* Notification Stack */
.notification-stack {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 9999;
    pointer-events: none;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.notification-toast {
    background: rgba(45, 55, 72, 0.95);
    backdrop-filter: blur(10px);
    color: white;
    padding: 12px 20px;
    border-radius: 8px;
    max-width: 350px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    pointer-events: auto;
    cursor: pointer;
    transition: all 0.3s ease;
    transform: translateX(400px) translateY(-100%);
    opacity: 0;
    animation: slideInToastDown 0.4s ease-out forwards;
}

.notification-toast.notification-success {
    background: rgba(56, 161, 105, 0.95);
    border-left: 4px solid #38a169;
}

.notification-toast.notification-error {
    background: rgba(229, 62, 62, 0.95);
    border-left: 4px solid #e53e3e;
}

.notification-toast.notification-warning {
    background: rgba(237, 137, 54, 0.95);
    border-left: 4px solid #ed8936;
}

.notification-toast.notification-info {
    background: rgba(49, 130, 206, 0.95);
    border-left: 4px solid #3182ce;
}

.notification-toast.removing {
    animation: slideOut 0.3s ease forwards;
}

.notification-toast:hover {
    transform: translateX(-5px);
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
}

/* Undo button styling within notifications (both toast and utils notifications) */
.notification-toast .undo-btn,
div[style*="position: fixed"][style*="top: 20px"][style*="right: 20px"] .undo-btn {
    background: rgba(255, 255, 255, 0.2);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    margin-left: 8px;
    transition: all 0.2s ease;
}

.notification-toast .undo-btn:hover,
div[style*="position: fixed"][style*="top: 20px"][style*="right: 20px"] .undo-btn:hover {
    background: rgba(255, 255, 255, 0.3);
    border-color: rgba(255, 255, 255, 0.5);
    transform: translateY(-1px);
}

@keyframes slideIn {
    from {
        transform: translateX(400px);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideOut {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(400px);
        opacity: 0;
    }
}

/* Responsive adjustments */
@media (max-width: 1200px) {
    .template-manager-body {
        grid-template-columns: 250px 1fr;
    }
}

@media (max-width: 768px) {
    .template-overlay-content {
        width: 98%;
        height: 95%;
    }
    
    .template-manager-body {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
    }
    
    .template-list-panel {
        border-right: none;
        border-bottom: 1px solid #e2e8f0;
        max-height: 200px;
    }
    
    .template-preview-panel {
        height: 150px;
    }
}

/* Confirmation Dialog Layout Improvements */
.confirmation-content {
    margin-bottom: 20px;
}

.confirmation-content p {
    margin: 0;
    font-size: 16px;
    line-height: 1.5;
    color: #2d3748;
}

.confirmation-options {
    background: #f8f9fa;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    padding: 15px;
    margin: 25px 0;
}

.confirmation-options .checkbox-group {
    margin: 0;
    display: flex;
    align-items: flex-start;
    gap: 10px;
}

.confirmation-options .checkbox-group input[type="checkbox"] {
    margin: 3px 0 0 0;
    width: auto;
    flex-shrink: 0;
}

.confirmation-options .checkbox-group label {
    margin: 0;
    font-size: 14px;
    color: #4a5568;
    line-height: 1.4;
    cursor: pointer;
}

/* Dark mode confirmation dialog styles */
.dark-mode .confirmation-content p {
    color: #e2e8f0;
}

.dark-mode .confirmation-options {
    background: #1a202c;
    border-color: #4a5568;
}

.dark-mode .confirmation-options .checkbox-group label {
    color: #a0aec0;
}

/* Copyright Section Styles */
.copyright-section {
    margin-top: 30px;
    margin-bottom: 0;
}

.copyright-card {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 16px;
    padding: 24px;
    color: white;
    text-align: center;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.copyright-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
    flex-wrap: wrap;
    gap: 12px;
}

.copyright-header h4 {
    margin: 0;
    font-size: 20px;
    font-weight: 600;
    color: white;
}

.copyright-badge {
    background: rgba(255, 255, 255, 0.2);
    padding: 6px 12px;
    border-radius: 20px;
    font-size: 13px;
    font-weight: 500;
    backdrop-filter: blur(10px);
}

.copyright-author {
    margin-bottom: 16px;
}

.copyright-author p {
    margin: 0;
    font-size: 15px;
    opacity: 0.9;
}

.author-link {
    color: #fbbf24;
    text-decoration: none;
    font-weight: 600;
    transition: all 0.2s ease;
    border-bottom: 1px solid rgba(251, 191, 36, 0.4);
}

.author-link:hover {
    color: #fcd34d;
    border-bottom-color: #fcd34d;
    text-shadow: 0 0 8px rgba(251, 191, 36, 0.3);
}

.copyright-description {
    margin-bottom: 20px;
}

.copyright-description p {
    margin: 0;
    font-size: 14px;
    line-height: 1.6;
    opacity: 0.85;
}

.copyright-actions {
    margin-bottom: 16px;
}

.github-button {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background: rgba(255, 255, 255, 0.15);
    color: white;
    text-decoration: none;
    padding: 12px 20px;
    border-radius: 25px;
    font-weight: 500;
    font-size: 14px;
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
}

.github-button:hover {
    background: rgba(255, 255, 255, 0.25);
    transform: translateY(-2px);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    text-decoration: none;
    color: white;
}

.github-icon {
    font-size: 16px;
}

.copyright-footer {
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    padding-top: 16px;
}

.privacy-note {
    margin: 0;
    font-size: 12px;
    opacity: 0.7;
    font-style: italic;
}

/* Dark mode copyright styles */
.dark-mode .copyright-card {
    background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
    border-color: rgba(255, 255, 255, 0.1);
}

.dark-mode .copyright-badge {
    background: rgba(255, 255, 255, 0.1);
}

.dark-mode .author-link {
    color: #fbbf24;
    border-bottom-color: rgba(251, 191, 36, 0.4);
}

.dark-mode .author-link:hover {
    color: #fcd34d;
    border-bottom-color: #fcd34d;
}

.dark-mode .github-button {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.2);
}

.dark-mode .github-button:hover {
    background: rgba(255, 255, 255, 0.2);
}

.dark-mode .copyright-footer {
    border-top-color: rgba(255, 255, 255, 0.1);
}

/* Notification Permission Modal Styles */
.notification-permission-content {
    max-width: 600px;
    margin: 5vh auto;
}

.notification-permission-info p {
    font-size: 16px;
    line-height: 1.6;
    color: #374151;
    margin-bottom: 20px;
}

.permission-options {
    display: grid;
    gap: 20px;
    margin: 30px 0;
}

.permission-option {
    padding: 20px;
    border: 2px solid #e5e7eb;
    border-radius: 12px;
    background: #f9fafb;
}

.permission-option h4 {
    font-size: 18px;
    margin: 0 0 10px 0;
    color: #111827;
}

.permission-option p {
    font-size: 14px;
    color: #6b7280;
    margin: 0;
    line-height: 1.5;
}

.permission-clickable {
    cursor: pointer;
    transition: all 0.2s ease;
}

.permission-clickable:hover {
    border-color: #3b82f6;
    background: #eff6ff;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

.permission-note {
    font-size: 14px !important;
    color: #6b7280 !important;
    text-align: center;
    margin-top: 25px !important;
}

/* Dark mode notification permission styles */
.dark-mode .notification-permission-info p {
    color: #d1d5db;
}

.dark-mode .permission-option {
    background: #374151;
    border-color: #4b5563;
}

.dark-mode .permission-option h4 {
    color: #f3f4f6;
}

.dark-mode .permission-option p {
    color: #9ca3af;
}

.dark-mode .permission-note {
    color: #9ca3af !important;
}

.dark-mode .permission-clickable:hover {
    border-color: #60a5fa;
    background: #1e3a8a;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

/* Diagnostics Section Styles */
.diagnostics-container {
    margin-top: 20px;
}

.diagnostic-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 25px;
    margin-top: 20px;
}

.diagnostic-card {
    background: #f8fafc;
    border: 1px solid #e2e8f0;
    border-radius: 12px;
    padding: 20px;
    transition: all 0.3s ease;
}

.diagnostic-card:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    transform: translateY(-2px);
}

.diagnostic-card.dangerous {
    border-color: #fed7d7;
    background: #fffaf0;
}

.diagnostic-card h4 {
    margin: 0 0 12px 0;
    color: #2d3748;
    font-size: 16px;
    font-weight: 600;
}

.diagnostic-warning {
    color: #d69e2e;
    font-size: 13px;
    margin: 0 0 15px 0;
    font-weight: 500;
}

.diagnostic-buttons {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.diagnostic-btn {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 16px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s ease;
    text-align: left;
    justify-content: flex-start;
}

.diagnostic-btn .btn-icon {
    font-size: 16px;
    line-height: 1;
}

.diagnostic-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}

/* Dark mode styles for diagnostics */
.dark-mode .diagnostic-card {
    background: #2d3748;
    border-color: #4a5568;
}

.dark-mode .diagnostic-card:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.dark-mode .diagnostic-card.dangerous {
    border-color: #c53030;
    background: #3c2415;
}

.dark-mode .diagnostic-card h4 {
    color: #e2e8f0;
}

.dark-mode .diagnostic-warning {
    color: #ed8936;
}

/* Activity Hours Info Modal Styles */
.activity-hours-info {
    margin-bottom: 25px;
}

.activity-hours-info p {
    margin: 0 0 16px 0;
    line-height: 1.6;
    color: #4a5568;
}

.activity-hours-info p:last-child {
    margin-bottom: 0;
}

.activity-hours-info ul {
    margin: 16px 0;
    padding-left: 24px;
}

.activity-hours-info li {
    margin: 8px 0;
    line-height: 1.5;
    color: #4a5568;
}

.activity-hours-info strong {
    color: #2d3748;
    font-weight: 600;
}

/* Dark mode styles for activity hours info */
.dark-mode .activity-hours-info p,
.dark-mode .activity-hours-info li {
    color: #cbd5e0;
}

.dark-mode .activity-hours-info strong {
    color: #e2e8f0;
}

/* Overdue Alert System Styles */
.alert-btn {
    background: #e53e3e !important;
    color: white !important;
    animation: alertPulse 2s ease-in-out infinite;
    border: 1px solid #c53030 !important;
}

.alert-btn:hover {
    background: #c53030 !important;
    border-color: #9c2626 !important;
}

@keyframes alertPulse {
    0%, 100% { 
        box-shadow: 0 0 8px rgba(229, 62, 62, 0.6);
        transform: scale(1);
    }
    50% { 
        box-shadow: 0 0 16px rgba(229, 62, 62, 0.8);
        transform: scale(1.02);
    }
}

.overdue-items-list {
    margin: 20px 0;
    max-height: 400px;
    overflow-y: auto;
}

.overdue-item {
    background: #fef5e7;
    border: 1px solid #f6ad55;
    border-radius: 8px;
    padding: 0;
    margin: 12px 0;
    position: relative;
    display: flex;
    flex-direction: column;
}

.overdue-item.critical {
    background: #fed7d7;
    border-color: #fc8181;
}

.overdue-item-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 8px;
}

.overdue-item-title {
    font-weight: 600;
    color: #d69e2e;
    margin: 0;
    flex: 1;
}

.overdue-item.critical .overdue-item-title {
    color: #c53030;
}

.overdue-time {
    font-size: 12px;
    color: #d69e2e;
    font-weight: 500;
    background: rgba(214, 158, 46, 0.1);
    padding: 4px 8px;
    border-radius: 4px;
    margin-left: 12px;
}

.overdue-item.critical .overdue-time {
    color: #c53030;
    background: rgba(197, 48, 48, 0.1);
}

.overdue-item-description {
    color: #744210;
    font-size: 14px;
    margin: 8px 0 0 0;
    line-height: 1.4;
}

.overdue-item.critical .overdue-item-description {
    color: #742a2a;
}

.overdue-item-due-date {
    font-size: 12px;
    color: #a0aec0;
    margin-top: 8px;
}

/* Overdue item layout styles */
.overdue-item-content {
    padding: 16px;
    flex: 1;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.overdue-item-content:hover {
    background: rgba(0, 0, 0, 0.05);
}

.overdue-item.critical .overdue-item-content:hover {
    background: rgba(0, 0, 0, 0.05);
}

.overdue-item-actions {
    padding: 12px 16px;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
    background: rgba(0, 0, 0, 0.05);
    display: flex;
    gap: 8px;
    align-items: center;
    justify-content: flex-start;
}

.overdue-item.critical .overdue-item-actions {
    border-top-color: rgba(197, 48, 48, 0.2);
    background: rgba(197, 48, 48, 0.05);
}

/* Reschedule dropdown styles */
.reschedule-dropdown {
    position: relative;
}

.reschedule-options {
    position: fixed;
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 6px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    z-index: 10001;
    min-width: 140px;
}

.reschedule-options button {
    display: block;
    width: 100%;
    padding: 8px 12px;
    border: none;
    background: none;
    text-align: left;
    cursor: pointer;
    font-size: 13px;
    color: #4a5568;
    transition: background-color 0.2s ease;
}

.reschedule-options button:hover {
    background: #f7fafc;
    color: #2d3748;
}

.reschedule-options button:first-child {
    border-radius: 6px 6px 0 0;
}

.reschedule-options button:last-child {
    border-radius: 0 0 6px 6px;
}

/* Due date countdown display in entry lists */
.entry-due-countdown {
    font-size: 11px;
    padding: 2px 6px;
    border-radius: 4px;
    margin-left: 8px;
    font-weight: 500;
}

.entry-due-countdown.upcoming {
    background: #e6fffa;
    color: #038770;
    border: 1px solid #81e6d9;
}

.entry-due-countdown.soon {
    background: #fefcbf;
    color: #d69e2e;
    border: 1px solid #f6e05e;
}

.entry-due-countdown.overdue {
    background: #fed7d7;
    color: #c53030;
    border: 1px solid #fc8181;
    animation: overdueGlow 2s ease-in-out infinite;
}

@keyframes overdueGlow {
    0%, 100% { box-shadow: 0 0 4px rgba(197, 48, 48, 0.3); }
    50% { box-shadow: 0 0 8px rgba(197, 48, 48, 0.6); }
}

/* Dark mode styles for overdue system */
.dark-mode .overdue-item {
    background: #2d3748;
    border-color: #ed8936;
}

.dark-mode .overdue-item.critical {
    background: #3c2415;
    border-color: #e53e3e;
}

.dark-mode .overdue-item-title {
    color: #ed8936;
}

.dark-mode .overdue-item.critical .overdue-item-title {
    color: #fc8181;
}

.dark-mode .overdue-item-description {
    color: #cbd5e0;
}

.dark-mode .overdue-time {
    color: #ed8936;
    background: rgba(237, 137, 54, 0.1);
}

.dark-mode .overdue-item.critical .overdue-time {
    color: #fc8181;
    background: rgba(252, 129, 129, 0.1);
}

/* Dark mode styles for overdue item actions */
.dark-mode .overdue-item-content:hover {
    background: rgba(255, 255, 255, 0.1);
}

.dark-mode .overdue-item.critical .overdue-item-content:hover {
    background: rgba(255, 255, 255, 0.1);
}

.dark-mode .overdue-item-actions {
    border-top-color: rgba(255, 255, 255, 0.1);
    background: rgba(255, 255, 255, 0.05);
}

.dark-mode .overdue-item.critical .overdue-item-actions {
    border-top-color: rgba(252, 129, 129, 0.2);
    background: rgba(252, 129, 129, 0.05);
}

.dark-mode .reschedule-options {
    background: #2d3748;
    border-color: #4a5568;
    z-index: 10001;
}

.dark-mode .reschedule-options button {
    color: #cbd5e0;
}

.dark-mode .reschedule-options button:hover {
    background: #4a5568;
    color: #f7fafc;
}

/* Hashtag completion styles */
.hashtag-suggestions {
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 6px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    max-height: 200px;
    overflow-y: auto;
}

.hashtag-suggestion {
    padding: 8px 12px;
    cursor: pointer;
    border-bottom: 1px solid #f7fafc;
    font-size: 14px;
    color: #4a5568;
    transition: background-color 0.2s ease;
}

.hashtag-suggestion:last-child {
    border-bottom: none;
}

.hashtag-suggestion:hover,
.hashtag-suggestion.selected {
    background: #f7fafc;
    color: #2d3748;
}

.hashtag-suggestion.selected {
    background: #ebf4ff;
    color: #2b6cb0;
}

/* Dark mode hashtag suggestions */
.dark-mode .hashtag-suggestions {
    background: #2d3748;
    border-color: #4a5568;
}

.dark-mode .hashtag-suggestion {
    color: #cbd5e0;
    border-bottom-color: #4a5568;
}

.dark-mode .hashtag-suggestion:hover,
.dark-mode .hashtag-suggestion.selected {
    background: #4a5568;
    color: #f7fafc;
}

.dark-mode .hashtag-suggestion.selected {
    background: #3182ce;
    color: #e2e8f0;
}

.dark-mode .entry-due-countdown.upcoming {
    background: #1a202c;
    color: #68d391;
    border-color: #38a169;
}

.dark-mode .entry-due-countdown.soon {
    background: #2d3748;
    color: #ed8936;
    border-color: #dd6b20;
}

.dark-mode .entry-due-countdown.overdue {
    background: #3c2415;
    color: #fc8181;
    border-color: #e53e3e;
}

/* Entry form toggle styles */
.entry-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.entry-toggle-btn {
    background: rgba(255, 255, 255, 0.8);
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    padding: 8px 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 44px;
    height: 44px;
}

.entry-toggle-btn:hover {
    background: rgba(255, 255, 255, 1);
    border-color: #cbd5e0;
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.entry-toggle-btn.hidden-form {
    background: #667eea;
    color: white;
    border-color: #667eea;
}

.entry-toggle-btn.hidden-form:hover {
    background: #5a67d8;
    border-color: #5a67d8;
}

.entry-toggle-btn.glow-hint {
    animation: glowPulse 2s ease-in-out infinite;
    box-shadow: 0 0 12px rgba(102, 126, 234, 0.6);
}

@keyframes glowPulse {
    0%, 100% { box-shadow: 0 0 12px rgba(102, 126, 234, 0.6); }
    50% { box-shadow: 0 0 20px rgba(102, 126, 234, 0.8); }
}

.toggle-icon {
    transition: transform 0.3s ease;
}

.entry-toggle-btn.hidden-form .toggle-icon {
    transform: rotate(180deg);
}

/* Dark mode styles for entry toggle */
.dark-mode .entry-toggle-btn {
    background: rgba(45, 55, 72, 0.8);
    border-color: #4a5568;
    color: #e2e8f0;
}

.dark-mode .entry-toggle-btn:hover {
    background: rgba(45, 55, 72, 1);
    border-color: #718096;
}

.dark-mode .entry-toggle-btn.hidden-form {
    background: #667eea;
    border-color: #667eea;
    color: white;
}

/* Section separator */
.section-separator {
    height: 1px;
    background: linear-gradient(90deg, transparent, #e2e8f0, transparent);
    margin: 30px 0;
}

.dark-mode .section-separator {
    background: linear-gradient(90deg, transparent, #4a5568, transparent);
}

/* Activity entry component animation */
.activity-entry-component {
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    overflow: hidden;
}

.activity-entry-component.collapsed {
    max-height: 64px;
}

.activity-entry-component form,
.activity-entry-component .section-separator {
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    opacity: 1;
    transform: translateY(0);
}

.activity-entry-component.collapsed form,
.activity-entry-component.collapsed .section-separator {
    opacity: 0;
    transform: translateY(-20px);
    pointer-events: none;
}

/* Complex Schedule Styles */
.schedule-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

.schedule-mode-toggle .checkbox-group.inline {
    margin: 0;
}

.schedule-mode {
    margin-bottom: 16px;
}

.complex-schedule-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
    margin-top: 16px;
}

.day-schedule {
    background: #f8fafc;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    padding: 16px;
}

.day-schedule h5 {
    margin: 0 0 12px 0;
    color: #2d3748;
    font-weight: 600;
    font-size: 14px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.time-ranges {
    min-height: 40px;
    margin-bottom: 12px;
}

.time-range {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
    padding: 8px;
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 6px;
}

.time-range input[type="time"] {
    font-size: 12px;
    padding: 4px 8px;
    border: 1px solid #cbd5e0;
    border-radius: 4px;
    background: white;
}

.time-range .range-separator {
    color: #718096;
    font-weight: 500;
    font-size: 12px;
}

.time-range .remove-range {
    background: #fed7d7;
    color: #c53030;
    border: none;
    width: 24px;
    height: 24px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
}

.time-range .remove-range:hover {
    background: #feb2b2;
}

.btn-small {
    font-size: 12px;
    padding: 6px 12px;
    height: auto;
    background: #667eea;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 4px;
}

.btn-small:hover {
    background: #5a67d8;
}

.empty-schedule {
    color: #718096;
    font-style: italic;
    font-size: 13px;
    padding: 16px 0;
    text-align: center;
}

/* Dark mode styles for complex schedule */
.dark-mode .day-schedule {
    background: #2d3748;
    border-color: #4a5568;
}

.dark-mode .day-schedule h5 {
    color: #e2e8f0;
}

.dark-mode .time-range {
    background: #1a202c;
    border-color: #4a5568;
}

.dark-mode .time-range input[type="time"] {
    background: #2d3748;
    border-color: #4a5568;
    color: #e2e8f0;
}

.dark-mode .time-range .range-separator {
    color: #a0aec0;
}

.dark-mode .time-range .remove-range {
    background: #742a2a;
    color: #feb2b2;
}

.dark-mode .time-range .remove-range:hover {
    background: #9c4221;
}

.dark-mode .empty-schedule {
    color: #a0aec0;
}



    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Activity Tracker</h1>
            <p>Task diary, organiser and knowledge base</p>
            
            <!-- Global Search -->
            <div class="global-search">
                <div class="search-container">
                    <input type="text" id="globalSearch" placeholder="Search activities, todos, and hashtags..." autocomplete="off">
                    <button class="hashtag-browser-btn" onclick="showHashtagBrowser()" title="Browse hashtags"></button>
                    <div class="search-results" id="searchResults" style="display: none;"></div>
                </div>
            </div>
            
            <div class="nav">
                <div class="nav-left">
                    <button class="nav-btn active" onclick="showSection('tracker', event)"> Tracker</button>
                    <button class="nav-btn" onclick="showSection('todo', event)"> To Do</button>
                    <button class="nav-btn" onclick="showSection('notes', event)"> Notes</button>
                </div>
                <div class="nav-right">
                    <button id="overdueAlertButton" class="nav-btn alert-btn" onclick="showOverdueAlert()" style="display: none;" title="View overdue items"> Alert</button>
                    <button id="pauseButton" class="nav-btn" onclick="togglePause()">Start Reminders</button>
                    <button id="pomodoroButton" class="nav-btn pomodoro-btn" onclick="togglePomodoro()" style="display: none;"> Start Pomodoro</button>
                    <div id="burgerAnchor" class="burger-anchor"></div>
                </div>
            </div>
        </div>
        
        <!-- Burger Menu positioned outside header to avoid clipping -->
        <div class="burger-menu">
            <button class="burger-btn" onclick="toggleBurgerMenu()" title="Settings menu">
                <span class="burger-line"></span>
                <span class="burger-line"></span>
                <span class="burger-line"></span>
            </button>
            <div class="burger-dropdown" id="burgerDropdown" style="display: none;">
                <button class="burger-item" onclick="showSection('tracker', event); closeBurgerMenu()"><span class="burger-emoji"></span><span class="burger-text">Tracker</span></button>
                <button class="burger-item" onclick="showSection('notes', event); closeBurgerMenu()"><span class="burger-emoji"></span><span class="burger-text">Notes</span></button>
                <button class="burger-item" onclick="showSection('todo', event); closeBurgerMenu()"><span class="burger-emoji"></span><span class="burger-text">To Do</span></button>
                <div class="burger-separator"></div>
                <button class="burger-item" onclick="showSection('reports', event); closeBurgerMenu()"><span class="burger-emoji"></span><span class="burger-text">Reports</span></button>
                <div class="burger-separator"></div>  
                <button class="burger-item" onclick="openWorkspaceManager(); closeBurgerMenu()"><span class="burger-emoji"></span><span class="burger-text">Workspaces</span></button>
                <div class="burger-separator"></div>
                <button class="burger-item" onclick="showSection('settings', event); closeBurgerMenu()"><span class="burger-emoji"></span><span class="burger-text">Settings...</span></button>
                <button class="burger-item" onclick="showSection('diagnostics', event); closeBurgerMenu()"><span class="burger-emoji"></span><span class="burger-text">Diagnostics</span></button>
                <button class="burger-item" onclick="showUserGuide(); closeBurgerMenu()"><span class="burger-emoji"></span><span class="burger-text">User Guide</span></button>
                <button class="burger-item" onclick="showAbout(); closeBurgerMenu()"><span class="burger-emoji"></span><span class="burger-text">About</span></button>
            </div>
        </div>

        <!-- Status Banner -->
        <div id="statusBanner" class="status-banner" style="display: none;">
            <div class="status-banner-content">
                <!-- Pomodoro Status -->
                <div id="pomodoroStatusSection" class="status-section" style="display: none;">
                    <div class="pomodoro-bar">
                        <div id="pomodoroStatus" class="status-label">Pomodoro mode disabled</div>
                        <div id="pomodoroTimer" class="pomodoro-active-bar" style="display: none;">
                            <div class="pomodoro-tomato"></div>
                            <div id="pomodoroPhase" class="session-number">#1</div>
                            <div id="pomodoroTimeRemaining" class="countdown-timer">25:00</div>
                            <div id="pomodoroActivityDisplay" class="work-item" style="display: none;">
                                <div id="pomodoroActivityText" class="work-title"></div>
                                <div id="pomodoroActivityDesc" class="work-desc"></div>
                            </div>
                        </div>
                    </div>
                    <div id="pomodoroBannerControls" class="status-controls" style="display: none;">
                        <button id="pomodoroPauseBtn" class="status-button" onclick="togglePomodoroPause()">Pause</button>
                    </div>
                </div>
                
                <!-- Reminder Status -->
                <div id="reminderStatusSection" class="status-section" style="display: none;">
                    <div class="status-info">
                        <div id="reminderStatus" class="status-label">Next activity logging reminder in:</div>
                        <div id="reminderTimer" class="status-timer">
                            <span id="reminderTimeRemaining">--:--</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tracker Section -->
        <div id="tracker" class="section active">
            <!-- Activity Entry Component -->
            <div class="activity-entry-component" id="trackerEntryComponent">
                <div class="entry-header">
                    <h2 id="entryTitle">Activity Entry</h2>
                    <button class="entry-toggle-btn" id="trackerToggleBtn" onclick="toggleEntryForm('tracker')" title="Hide/Show entry form">
                        <span class="toggle-icon"></span>
                    </button>
                </div>
                <form id="activityForm">
                    <div class="form-group">
                        <label for="activity" id="activityLabel">What are you doing?</label>
                        <input type="text" id="activity" required placeholder="e.g., Writing report, Meeting with team #work" autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="description" id="descriptionLabel">Description (optional)</label>
                        <textarea id="description" rows="3" placeholder="Additional details about this activity"></textarea>
                    </div>
                    <div class="form-group form-group-row">
                        <div class="form-group">
                            <label for="timestamp">Time</label>
                            <input type="datetime-local" id="timestamp" required>
                            <div class="todo-quick-set">
                                <button type="button" class="btn-quick-set" id="todoToggleBtn" onclick="toggleTodoMode()" title="Mark this as a todo item (Ctrl+T to toggle)">Mark as Todo</button>
                                <button type="button" class="btn-quick-set" id="noteToggleBtn" onclick="toggleNoteMode()" title="Mark this as a note (Ctrl+N to toggle)">Mark as Note</button>
                            </div>
                        </div>
                        <div class="form-group" id="dueDateSection">
                            <label for="dueDate">Due Date (optional)</label>
                            <input type="datetime-local" id="dueDate">
                            <div class="due-date-quick-sets">
                                <div class="due-date-group">
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('dueDate', -1, 'day')">-1d</button>
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('dueDate', 1, 'day')">+1d</button>
                                </div>
                                <div class="due-date-group">
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('dueDate', -1, 'week')">-1w</button>
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('dueDate', 1, 'week')">+1w</button>
                                </div>
                                <div class="due-date-group">
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('dueDate', -1, 'month')">-1m</button>
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('dueDate', 1, 'month')">+1m</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="form-actions-split">
                        <button type="submit" class="btn btn-primary" id="addEntryBtn">Add Entry</button>
                        <button type="button" class="btn btn-secondary" onclick="resetActivityForm()">Reset</button>
                    </div>
                </form>
                
                <div class="section-separator"></div>
            </div>

            <div class="entries-list">
                <h3>Recent Entries</h3>
                <div id="entriesList"></div>
                <div class="entries-pagination" id="entriesPagination" style="display: none;">
                    <button class="nav-btn" id="entriesPrevBtn" onclick="tracker.previousEntriesPage()"> Previous</button>
                    <span id="entriesPageInfo"></span>
                    <button class="nav-btn" id="entriesNextBtn" onclick="tracker.nextEntriesPage()">Next </button>
                </div>
            </div>
        </div>

        <!-- To Do Section -->
        <div id="todo" class="section">
            <!-- Activity Entry Component -->
            <div class="activity-entry-component" id="todoEntryComponent">
                <div class="entry-header">
                    <h2 id="todoEntryTitle">New Todo Item</h2>
                    <button class="entry-toggle-btn" id="todoToggleBtn2" onclick="toggleEntryForm('todo')" title="Hide/Show entry form">
                        <span class="toggle-icon"></span>
                    </button>
                </div>
                <form id="todoActivityForm">
                    <div class="form-group">
                        <label for="todoActivity" id="todoActivityLabel">What do you need to do?</label>
                        <input type="text" id="todoActivity" required placeholder="e.g., Call client about project, Review budget #work" autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="todoDescription" id="todoDescriptionLabel">Description (optional)</label>
                        <textarea id="todoDescription" rows="3" placeholder="Additional details about this todo item"></textarea>
                    </div>
                    <div class="form-group form-group-row">
                        <div class="form-group">
                            <label for="todoTimestamp">Time</label>
                            <input type="datetime-local" id="todoTimestamp" required>
                            <div class="todo-quick-set">
                                <button type="button" class="btn-quick-set active" id="todoTodoToggleBtn" onclick="toggleTodoModeForTodo()" title="Mark this as a todo item">Mark as Todo</button>
                                <button type="button" class="btn-quick-set" id="todoNoteToggleBtn" onclick="toggleNoteModeForTodo()" title="Mark this as a note">Mark as Note</button>
                            </div>
                        </div>
                        <div class="form-group" id="todoDueDateSection">
                            <label for="todoDueDate">Due Date (optional)</label>
                            <input type="datetime-local" id="todoDueDate">
                            <div class="due-date-quick-sets">
                                <div class="due-date-group">
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('todoDueDate', -1, 'day')">-1d</button>
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('todoDueDate', 1, 'day')">+1d</button>
                                </div>
                                <div class="due-date-group">
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('todoDueDate', -1, 'week')">-1w</button>
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('todoDueDate', 1, 'week')">+1w</button>
                                </div>
                                <div class="due-date-group">
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('todoDueDate', -1, 'month')">-1m</button>
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('todoDueDate', 1, 'month')">+1m</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="form-actions-split">
                        <button type="submit" class="btn btn-primary" id="todoAddEntryBtn">Add Todo</button>
                        <button type="button" class="btn btn-secondary" onclick="resetTodoForm()">Reset</button>
                    </div>
                </form>
                
                <div class="section-separator"></div>
            </div>

            <h3>To Do List</h3>
            <div class="todo-filters">
                <div class="filter-row">
                    <div class="filter-group">
                        <label for="todoFilter">Filter:</label>
                        <select id="todoFilter" onchange="tracker.filterTodos()">
                            <option value="all">All Todos</option>
                            <option value="due-today">Due Today</option>
                            <option value="overdue">Overdue</option>
                            <option value="no-due-date">No Due Date</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="todoSort">Sort by:</label>
                        <select id="todoSort" onchange="tracker.sortTodos()">
                            <option value="created-desc">Newest First</option>
                            <option value="created-asc">Oldest First</option>
                            <option value="due-asc">Due Date (Earliest)</option>
                            <option value="due-desc">Due Date (Latest)</option>
                            <option value="activity-asc">Activity A-Z</option>
                            <option value="activity-desc">Activity Z-A</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="todo-stats" id="todoStats">
                <span id="todoCount">0 todos</span>
            </div>

            <div class="todo-list" id="todoList">
                <p class="empty-state">No todos found. Add activities as todos to see them here!</p>
            </div>

            <div class="todo-pagination" id="todoPagination" style="display: none;">
                <button class="nav-btn" id="todoPrevBtn" onclick="tracker.previousTodoPage()"> Previous</button>
                <span id="todoPageInfo">Page 1 of 1</span>
                <button class="nav-btn" id="todoNextBtn" onclick="tracker.nextTodoPage()">Next </button>
            </div>
        </div>

        <!-- Notes Section -->
        <div id="notes" class="section">
            <!-- Activity Entry Component -->
            <div class="activity-entry-component" id="notesEntryComponent">
                <div class="entry-header">
                    <h2 id="notesEntryTitle">New Note</h2>
                    <button class="entry-toggle-btn" id="notesToggleBtn2" onclick="toggleEntryForm('notes')" title="Hide/Show entry form">
                        <span class="toggle-icon"></span>
                    </button>
                </div>
                <form id="notesActivityForm">
                    <div class="form-group">
                        <label for="notesActivity" id="notesActivityLabel">Note title or topic</label>
                        <input type="text" id="notesActivity" required placeholder="e.g., Meeting notes, Ideas for project #brainstorm" autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="notesDescription" id="notesDescriptionLabel">Note content</label>
                        <textarea id="notesDescription" rows="3" placeholder="Write your note content here..."></textarea>
                    </div>
                    <div class="form-group form-group-row">
                        <div class="form-group">
                            <label for="notesTimestamp">Time</label>
                            <input type="datetime-local" id="notesTimestamp" required>
                            <div class="todo-quick-set">
                                <button type="button" class="btn-quick-set" id="notesTodToggleBtn" onclick="toggleTodoModeForNotes()" title="Mark this as a todo item">Mark as Todo</button>
                                <button type="button" class="btn-quick-set active" id="notesNoteToggleBtn" onclick="toggleNoteModeForNotes()" title="Mark this as a note">Mark as Note</button>
                            </div>
                        </div>
                        <div class="form-group" id="notesDueDateSection" style="display: none;">
                            <label for="notesDueDate">Due Date (optional)</label>
                            <input type="datetime-local" id="notesDueDate">
                            <div class="due-date-quick-sets">
                                <div class="due-date-group">
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('notesDueDate', -1, 'day')">-1d</button>
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('notesDueDate', 1, 'day')">+1d</button>
                                </div>
                                <div class="due-date-group">
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('notesDueDate', -1, 'week')">-1w</button>
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('notesDueDate', 1, 'week')">+1w</button>
                                </div>
                                <div class="due-date-group">
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('notesDueDate', -1, 'month')">-1m</button>
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('notesDueDate', 1, 'month')">+1m</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="form-actions-split">
                        <button type="submit" class="btn btn-primary" id="notesAddEntryBtn">Add Note</button>
                        <button type="button" class="btn btn-secondary" onclick="resetNotesForm()">Reset</button>
                    </div>
                </form>
                
                <div class="section-separator"></div>
            </div>

            <h3>Notes</h3>
            <div class="notes-filters">
                <div class="filter-row">
                    <div class="filter-group">
                        <label for="noteFilter">Filter:</label>
                        <select id="noteFilter" onchange="tracker.filterNotes()">
                            <option value="all">All Notes</option>
                            <option value="today">Today</option>
                            <option value="week">This Week</option>
                            <option value="month">This Month</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="noteSort">Sort:</label>
                        <select id="noteSort" onchange="tracker.sortNotes()">
                            <option value="newest">Newest First</option>
                            <option value="oldest">Oldest First</option>
                            <option value="activity">Activity Name</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <input type="text" id="noteSearchInput" placeholder="Search through notes..." onkeyup="tracker.searchNotes()" oninput="tracker.toggleNoteClearButton()" autocomplete="off">
                        <button class="btn btn-secondary btn-small" id="noteClearBtn" onclick="tracker.clearNoteSearch()" style="display: none;">Clear</button>
                    </div>
                </div>
            </div>
            
            <div id="noteList" class="entry-list">
                <p class="no-entries">No notes found.</p>
            </div>
            
            <div class="notes-pagination" id="notesPagination" style="display: none;">
                <button class="nav-btn" id="notesPrevBtn" onclick="tracker.previousNotePage()"> Previous</button>
                <span id="notesPageInfo">Page 1 of 1</span>
                <button class="nav-btn" id="notesNextBtn" onclick="tracker.nextNotePage()">Next </button>
            </div>
        </div>

        <!-- Reports Section -->
        <div id="reports" class="section">
            <h2>Activity Reports</h2>

            <!-- Report Generation -->
            <div class="reports-grid">
                <div class="reports-section">
                    <h3>Date Range</h3>
                    <p class="settings-description">Select the time period for your report</p>
                    <div class="form-group">
                        <label for="reportStartDate" title="Choose the start date for your report">Start Date</label>
                        <input type="date" id="reportStartDate">
                    </div>
                    <div class="form-group">
                        <label for="reportEndDate" title="Choose the end date for your report">End Date</label>
                        <input type="date" id="reportEndDate">
                    </div>
                    <div class="report-actions">
                        <button class="btn btn-primary" onclick="generateReport()" title="Generate report for the selected date range">Generate Report</button>
                        <button class="btn btn-secondary" onclick="setWeeklyReport()" title="Set date range to current week">This Week</button>
                    </div>
                </div>

                <div class="reports-section">
                    <h3>Template & Options</h3>
                    <p class="settings-description">Choose format, options and download your report</p>
                    <div class="form-group">
                        <label for="reportTemplate" title="Select the format for your report">Report Template</label>
                        <select id="reportTemplate" onchange="tracker.previewReport()"></select>
                    </div>
                    <div class="form-group">
                        <label for="includeTodos">Todo Items:</label>
                        <select id="includeTodos" onchange="tracker.generateReport()">
                            <option value="exclude">Exclude all todos</option>
                            <option value="incomplete">Include incomplete todos only</option>
                            <option value="all">Include all todos</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="includeNotes">Notes:</label>
                        <select id="includeNotes" onchange="tracker.generateReport()">
                            <option value="exclude">Exclude notes</option>
                            <option value="include">Include notes</option>
                        </select>
                    </div>
                    <div class="download-actions">
                        <button class="btn btn-success" onclick="downloadReport()" title="Download the generated report">Download Report</button>
                        <button class="btn btn-primary" onclick="openReportInNewTab()" title="Open the generated report in a new tab">Open in New Tab</button>
                    </div>
                </div>
            </div>

            <!-- Week Navigation -->
            <div class="report-navigation-section">
                <div class="report-navigation">
                    <button class="nav-btn" onclick="previousWeek()"> Previous Week</button>
                    <div class="week-display" id="weekDisplay">Week of ...</div>
                    <button class="nav-btn" onclick="nextWeek()">Next Week </button>
                </div>
            </div>

            <div id="reportPreviewContainer" class="report-preview-container">
                <div class="report-preview-header">
                    <h3>Report Preview</h3>
                    <div class="preview-controls">
                        <div class="preview-format-tabs">
                            <button class="preview-tab active" id="reportPreviewTabRendered" onclick="switchReportPreviewTab('rendered')" title="View the formatted report output">Rendered</button>
                            <button class="preview-tab" id="reportPreviewTabSource" onclick="switchReportPreviewTab('source')" title="View the raw source code of the report">Source</button>
                        </div>
                        <button class="btn-copy-report" id="copyReportBtn" onclick="copyReportToClipboard()" title="Copy report content to clipboard" style="display: none;">Copy Report</button>
                    </div>
                </div>
                <div id="reportPreview" class="report-preview-content">
                    Select a date range and generate a report to see a preview.
                </div>
            </div>
            
            <!-- Report Templates Management -->
            <div class="report-templates-section">
                <div class="settings-card">
                    <h3>Report Templates</h3>
                    <p class="card-description">Manage templates for report generation</p>
                    <div class="card-actions">
                        <button class="btn btn-primary" onclick="openTemplateManager()" title="Open the template editor to create and modify report templates">Manage Templates</button>
                        <button class="btn btn-secondary" onclick="resetReportTemplates()" title="Restore all templates to their original default versions">Reset to Default</button>
                        <button class="btn btn-info" onclick="showTemplateGuide()" title="View help documentation for template syntax and available data"> Template Guide</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings Section -->
        <div id="settings" class="section">
            <h2>Settings</h2>
            
            <div class="notification-status" id="notificationStatus">
                <span class="status-indicator" id="statusIndicator"></span>
                <span id="statusText">Checking notification status...</span>
            </div>

            <!-- Reminder Control Buttons -->
            <div class="settings-buttons-section">
                <div class="reminder-buttons">
                    <button class="btn btn-primary" onclick="enableNotifications()">Enable Reminders</button>
                </div>
            </div>

            <!-- General Settings (Shared between all modes) -->
            <div class="settings-section general-settings">
                <h3>General Settings</h3>
                <p class="settings-description">Settings that apply to all modes of operation</p>
                <div class="settings-grid settings-grid-four-col">
                    <div class="form-group">
                        <label for="darkModePreference" title="Choose your colour theme preference">Colour Theme</label>
                        <select id="darkModePreference" onchange="saveSettings()">
                            <option value="system">Follow system settings</option>
                            <option value="light">Light mode</option>
                            <option value="dark">Dark mode</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="soundMuteMode" title="Choose which sounds to mute">Sound Settings</label>
                        <select id="soundMuteMode" onchange="saveSettings()">
                            <option value="none">All sounds enabled</option>
                            <option value="all">Mute all sounds</option>
                            <option value="pomodoro">Mute Pomodoro sounds only</option>
                            <option value="notifications">Mute notification sounds only</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="paginationSize" title="Number of items to show per page in lists">Items per page</label>
                        <select id="paginationSize" onchange="saveSettings()">
                            <option value="10">10 items</option>
                            <option value="20" selected>20 items</option>
                            <option value="30">30 items</option>
                            <option value="50">50 items</option>
                            <option value="100">100 items</option>
                        </select>
                    </div>
                    <div class="form-group" id="systemNotificationsGroup" style="display: none;">
                        <label for="sendSystemNotifications" title="Send system notifications to your operating system">System Notifications</label>
                        <select id="sendSystemNotifications" onchange="saveSettings()">
                            <option value="true" selected>Yes</option>
                            <option value="false">No</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Main Settings Grid -->
            <div class="settings-grid settings-grid-two-col">
                <div class="settings-section">
                    <h3>Reminder Settings</h3>
                    <div class="form-group">
                        <label for="notificationInterval" title="How often you'll receive activity reminder notifications">Reminder Interval</label>
                        <select id="notificationInterval" onchange="saveSettings()">
                            <option value="1">1 minute</option>
                            <option value="2">2 minutes</option>
                            <option value="5">5 minutes</option>
                            <option value="15">15 minutes</option>
                            <option value="30">30 minutes</option>
                            <option value="60" selected>1 hour</option>
                            <option value="90">1.5 hours</option>
                            <option value="120">2 hours</option>
                            <option value="180">3 hours</option>
                            <option value="240">4 hours</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="pauseDuration" title="How long alerts remain paused before automatically resuming">When pausing, resume after</label>
                        <select id="pauseDuration" onchange="saveSettings()">
                            <option value="1">1 minute</option>
                            <option value="2">2 minutes</option>
                            <option value="5">5 minutes</option>
                            <option value="15">15 minutes</option>
                            <option value="30">30 minutes</option>
                            <option value="60">1 hour</option>
                            <option value="90">1.5 hours</option>
                            <option value="120">2 hours</option>
                            <option value="180">3 hours</option>
                            <option value="240">4 hours</option>
                            <option value="480">8 hours</option>
                            <option value="1440">24 hours</option>
                            <option value="-1">Never</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="autoStartAlerts" title="Automatically start reminders when the app opens">Auto start reminders upon opening app</label>
                        <select id="autoStartAlerts" onchange="saveSettings()">
                            <option value="false" selected>No</option>
                            <option value="true">Yes</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="notificationSoundType" title="Choose the sound that plays with reminders">Reminder Sound</label>
                        <select id="notificationSoundType" onchange="previewNotificationSound()">
                            <!-- Options will be populated by JavaScript -->
                        </select>
                    </div>
                </div>

                <div class="settings-section">
                    <h3>Activity Schedule</h3>
                    <p class="settings-description">Set your active activity hours and days for notifications</p>
                    
                    <div class="schedule-section">
                        <div class="schedule-header">
                            <h4>Activity Hours</h4>
                            <div class="schedule-mode-toggle">
                                <div class="checkbox-group inline">
                                    <input type="checkbox" id="useComplexSchedule" onchange="toggleScheduleMode()">
                                    <label for="useComplexSchedule" title="Enable complex scheduling with multiple time ranges per day">Complex Schedule</label>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Simple Schedule (default) -->
                        <div id="simpleSchedule" class="schedule-mode">
                            <div class="time-inputs">
                                <div class="form-group">
                                    <label for="startTime" title="When your activity period starts">Start Time</label>
                                    <input type="time" id="startTime" value="08:00" onchange="saveSettings()">
                                </div>
                                <div class="form-group">
                                    <label for="endTime" title="When your activity period ends">End Time</label>
                                    <input type="time" id="endTime" value="18:00" onchange="saveSettings()">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Complex Schedule -->
                        <div id="complexSchedule" class="schedule-mode" style="display: none;">
                            <p class="settings-description">Set multiple time ranges for each day to accommodate complex schedules.</p>
                            <div class="complex-schedule-container">
                                <div class="day-schedule" data-day="monday">
                                    <h5>Monday</h5>
                                    <div class="time-ranges" id="monday-ranges"></div>
                                    <button type="button" class="btn btn-small" onclick="addTimeRange('monday')">+ Add Range</button>
                                </div>
                                <div class="day-schedule" data-day="tuesday">
                                    <h5>Tuesday</h5>
                                    <div class="time-ranges" id="tuesday-ranges"></div>
                                    <button type="button" class="btn btn-small" onclick="addTimeRange('tuesday')">+ Add Range</button>
                                </div>
                                <div class="day-schedule" data-day="wednesday">
                                    <h5>Wednesday</h5>
                                    <div class="time-ranges" id="wednesday-ranges"></div>
                                    <button type="button" class="btn btn-small" onclick="addTimeRange('wednesday')">+ Add Range</button>
                                </div>
                                <div class="day-schedule" data-day="thursday">
                                    <h5>Thursday</h5>
                                    <div class="time-ranges" id="thursday-ranges"></div>
                                    <button type="button" class="btn btn-small" onclick="addTimeRange('thursday')">+ Add Range</button>
                                </div>
                                <div class="day-schedule" data-day="friday">
                                    <h5>Friday</h5>
                                    <div class="time-ranges" id="friday-ranges"></div>
                                    <button type="button" class="btn btn-small" onclick="addTimeRange('friday')">+ Add Range</button>
                                </div>
                                <div class="day-schedule" data-day="saturday">
                                    <h5>Saturday</h5>
                                    <div class="time-ranges" id="saturday-ranges"></div>
                                    <button type="button" class="btn btn-small" onclick="addTimeRange('saturday')">+ Add Range</button>
                                </div>
                                <div class="day-schedule" data-day="sunday">
                                    <h5>Sunday</h5>
                                    <div class="time-ranges" id="sunday-ranges"></div>
                                    <button type="button" class="btn btn-small" onclick="addTimeRange('sunday')">+ Add Range</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="schedule-section">
                        <h4>Activity Days</h4>
                        <div class="activity-days-grid">
                            <div class="checkbox-group">
                                <input type="checkbox" id="monday" checked onchange="saveSettings()">
                                <label for="monday">Monday</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="tuesday" checked onchange="saveSettings()">
                                <label for="tuesday">Tuesday</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="wednesday" checked onchange="saveSettings()">
                                <label for="wednesday">Wednesday</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="thursday" checked onchange="saveSettings()">
                                <label for="thursday">Thursday</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="friday" checked onchange="saveSettings()">
                                <label for="friday">Friday</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="saturday" onchange="saveSettings()">
                                <label for="saturday">Saturday</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="sunday" onchange="saveSettings()">
                                <label for="sunday">Sunday</label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pomodoro Mode Section -->
            <div class="pomodoro-section">
                <div class="settings-card">
                    <h3>Pomodoro Mode</h3>
                    <p class="card-description">Structured work/break intervals with automatic notifications</p>
                    <div class="pomodoro-settings">
                        <div class="checkbox-group">
                            <input type="checkbox" id="pomodoroEnabled" onchange="saveSettings()">
                            <label for="pomodoroEnabled" title="Enable Pomodoro timing mode with work and break alerts">Enable Pomodoro Mode</label>
                        </div>
                        
                        <div class="pomodoro-config" id="pomodoroConfig" style="display: none;">
                            
                            <!-- Timer Configuration -->
                            <div class="pomodoro-timers">
                                <div class="form-group">
                                    <label for="pomodoroWorkDuration" title="Length of work periods in minutes">Work Duration (minutes)</label>
                                    <select id="pomodoroWorkDuration" onchange="saveSettings()">
                                        <option value="15">15 minutes</option>
                                        <option value="20">20 minutes</option>
                                        <option value="25" selected>25 minutes</option>
                                        <option value="30">30 minutes</option>
                                        <option value="45">45 minutes</option>
                                        <option value="60">60 minutes</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="pomodoroBreakDuration" title="Length of short break periods in minutes">Short Break Duration (minutes)</label>
                                    <select id="pomodoroBreakDuration" onchange="saveSettings()">
                                        <option value="3">3 minutes</option>
                                        <option value="5" selected>5 minutes</option>
                                        <option value="10">10 minutes</option>
                                        <option value="15">15 minutes</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="pomodoroLongBreakDuration" title="Length of long break periods in minutes">Long Break Duration (minutes)</label>
                                    <select id="pomodoroLongBreakDuration" onchange="saveSettings()">
                                        <option value="15" selected>15 minutes</option>
                                        <option value="20">20 minutes</option>
                                        <option value="30">30 minutes</option>
                                        <option value="45">45 minutes</option>
                                        <option value="60">60 minutes</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="pomodoroLongBreakInterval" title="Number of work sessions before taking a long break">Sessions before long break</label>
                                    <select id="pomodoroLongBreakInterval" onchange="saveSettings()">
                                        <option value="2">Every 2 sessions</option>
                                        <option value="3">Every 3 sessions</option>
                                        <option value="4" selected>Every 4 sessions</option>
                                        <option value="5">Every 5 sessions</option>
                                        <option value="6">Every 6 sessions</option>
                                    </select>
                                </div>
                            </div>
                            
                            <!-- Tick Sound Configuration -->
                            <div class="pomodoro-sounds">
                                <h4>Tick Sounds</h4>
                                <div class="form-group">
                                    <label for="pomodoroTickSound" title="Optional tick sound to remind you're in a work session">Tick Sound Type</label>
                                    <select id="pomodoroTickSound" onchange="saveSettings()">
                                        <option value="none" selected>No ticking</option>
                                        <option value="soft">Soft tick</option>
                                        <option value="classic">Classic tick</option>
                                        <option value="digital">Digital tick</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="pomodoroTickInterval" title="How often to play the tick sound in seconds">Tick Interval (seconds)</label>
                                    <select id="pomodoroTickInterval" onchange="saveSettings()">
                                        <option value="0" selected>Off (no ticking)</option>
                                        <option value="1">Every 1 second</option>
                                        <option value="2">Every 2 seconds</option>
                                        <option value="3">Every 3 seconds</option>
                                        <option value="4">Every 4 seconds</option>
                                        <option value="5">Every 5 seconds</option>
                                        <option value="10">Every 10 seconds</option>
                                        <option value="15">Every 15 seconds</option>
                                        <option value="30">Every 30 seconds</option>
                                        <option value="60">Every minute</option>
                                    </select>
                                </div>
                            </div>
                            
                            <!-- Announce Sound Configuration -->
                            <div class="pomodoro-announce-sounds">
                                <h4>Announce Sounds</h4>
                                <div class="form-group">
                                    <label for="pomodoroShortBreakSound" title="Sound to play when short break starts">Short Break Announce</label>
                                    <select id="pomodoroShortBreakSound" onchange="saveSettings()">
                                        <!-- Options will be populated by JavaScript -->
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="pomodoroLongBreakSound" title="Sound to play when long break starts">Long Break Announce</label>
                                    <select id="pomodoroLongBreakSound" onchange="saveSettings()">
                                        <!-- Options will be populated by JavaScript -->
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="pomodoroResumeSound" title="Sound to play when resuming work after break">Resume Work Announce</label>
                                    <select id="pomodoroResumeSound" onchange="saveSettings()">
                                        <!-- Options will be populated by JavaScript -->
                                    </select>
                                </div>
                            </div>
                            
                            <!-- Pomodoro Options -->
                            <div class="pomodoro-options">
                                <h4>Options</h4>
                                <div class="checkbox-group">
                                    <input type="checkbox" id="pomodoroAutoStart" onchange="saveSettings()">
                                    <label for="pomodoroAutoStart" title="Automatically start the next session without requiring manual intervention">Automatically start next session</label>
                                </div>
                                <div class="checkbox-group">
                                    <input type="checkbox" id="pomodoroAutoLog" checked onchange="saveSettings()">
                                    <label for="pomodoroAutoLog" title="Prompt for activity description and create log entries for work sessions">Prompt for work session descriptions</label>
                                </div>
                                <div class="checkbox-group">
                                    <input type="checkbox" id="pomodoroLogBreaks" onchange="saveSettings()">
                                    <label for="pomodoroLogBreaks" title="Also log break sessions in the activity tracker">Log break sessions too</label>
                                </div>
                                <div class="checkbox-group">
                                    <input type="checkbox" id="pomodoroLongBreak" checked onchange="saveSettings()">
                                    <label for="pomodoroLongBreak" title="Enable long breaks after completing multiple sessions">Enable long breaks</label>
                                </div>
                                <div class="checkbox-group">
                                    <input type="checkbox" id="pomodoroPauseAllowed" checked onchange="saveSettings()">
                                    <label for="pomodoroPauseAllowed" title="Allow pausing Pomodoro sessions from the banner">Allow session pausing</label>
                                </div>
                                <div class="checkbox-group">
                                    <input type="checkbox" id="pomodoroAutoResetDaily" onchange="saveSettings()">
                                    <label for="pomodoroAutoResetDaily" title="Automatically reset session counter to 1 when the day changes">Auto-reset sessions daily</label>
                                </div>
                            </div>
                            
                            <!-- Session Management -->
                            <div class="pomodoro-session-management">
                                <h5>Session Management</h5>
                                <div class="session-actions">
                                    <button type="button" class="btn btn-outline btn-warning" onclick="resetPomodoroSessions()" title="Reset session counter back to 1">
                                        Reset Session Counter
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Data Management Section -->
            <div class="data-management-section">
                <div class="data-management-grid">
                    <div class="settings-card">
                        <h3>Database Backup</h3>
                        <p class="card-description">Export or import your activity data</p>
                        <div class="card-actions">
                            <button class="btn btn-primary" onclick="exportDatabase()">Export Database</button>
                            <button class="btn btn-secondary" onclick="importDatabase()">Import Database</button>
                            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="handleImportFile(event)">
                        </div>
                    </div>
                    
                    <div class="settings-card">
                        <h3>Warning Settings</h3>
                        <p class="card-description">Configure confirmation dialogs for destructive actions</p>
                        <div class="warning-settings">
                            <div class="form-group">
                                <label for="warnOnActivityDelete" title="Show confirmation dialog when deleting activities">Warn on activity delete</label>
                                <select id="warnOnActivityDelete" onchange="saveSettings()">
                                    <option value="true" selected>Yes</option>
                                    <option value="false">No</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="warnOnSessionReset" title="Show confirmation dialog when resetting Pomodoro session counter">Warn on session reset</label>
                                <select id="warnOnSessionReset" onchange="saveSettings()">
                                    <option value="true" selected>Yes</option>
                                    <option value="false">No</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>


            <button class="btn btn-primary" onclick="saveSettings()">Force Manual Save</button>
        </div>

        <!-- Diagnostics Section -->
        <div id="diagnostics" class="section">
            <h2> Diagnostics</h2>
            
            <div class="diagnostics-container">
                <div class="settings-section">
                    <h3>System Tests</h3>
                    <p class="settings-description">Test various system components and functionality</p>
                    <div class="diagnostic-grid">
                        <div class="diagnostic-card">
                            <h4> Notifications</h4>
                            <div class="diagnostic-buttons">
                                <button class="btn btn-secondary diagnostic-btn" onclick="testNotification()" title="Send a test reminder">
                                    <span class="btn-icon"></span>Test Reminder
                                </button>
                                <button class="btn btn-primary diagnostic-btn" onclick="testNotificationSound()" title="Play a test reminder sound">
                                    <span class="btn-icon"></span>Test Sound
                                </button>
                                <button class="btn btn-secondary diagnostic-btn" onclick="refreshNotificationStatus()" title="Refresh the reminder permission status display">
                                    <span class="btn-icon"></span>Refresh Status
                                </button>
                                <button class="btn btn-warning diagnostic-btn" onclick="forceEnableNotifications()" title="Force show notification permission dialog">
                                    <span class="btn-icon"></span>Force Enable
                                </button>
                            </div>
                        </div>
                        
                        <div class="diagnostic-card">
                            <h4> Service Worker</h4>
                            <div class="diagnostic-buttons">
                                <button class="btn btn-secondary diagnostic-btn" onclick="runServiceWorkerTest()" title="Run comprehensive service worker diagnostics">
                                    <span class="btn-icon"></span>Run Diagnostics
                                </button>
                            </div>
                        </div>
                        
                        <div class="diagnostic-card dangerous">
                            <h4> Data Management</h4>
                            <p class="diagnostic-warning">These actions cannot be undone</p>
                            <div class="diagnostic-buttons">
                                <button class="btn btn-danger diagnostic-btn" onclick="clearAllData()">
                                    <span class="btn-icon"></span>Clear All Data
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Search Results Section -->
        <div id="search" class="section">
            <h2>Search Results</h2>
            
            <div class="search-controls">
                <div class="search-info" id="searchInfo">
                    <span id="searchQuery"></span>
                    <span id="searchCount">0 results</span>
                </div>
                
                <div class="search-options">
                    <div class="filter-group">
                        <label for="searchSort">Sort by:</label>
                        <select id="searchSort" onchange="tracker.sortSearchResults()">
                            <option value="relevance">Relevance</option>
                            <option value="date-desc">Newest First</option>
                            <option value="date-asc">Oldest First</option>
                            <option value="activity-asc">Activity A-Z</option>
                            <option value="activity-desc">Activity Z-A</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="searchFilter">Show:</label>
                        <select id="searchFilter" onchange="tracker.filterSearchResults()">
                            <option value="all">All Items</option>
                            <option value="activities">Activities Only</option>
                            <option value="todos">Todos Only</option>
                            <option value="completed">Completed Only</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="search-results-list" id="searchResultsList">
                <p class="empty-state">Use the search box above to find activities, todos, and hashtags.</p>
            </div>

            <div class="search-pagination" id="searchPagination" style="display: none;">
                <button class="nav-btn" id="searchPrevBtn" onclick="tracker.previousSearchPage()"> Previous</button>
                <span id="searchPageInfo">Page 1 of 1</span>
                <button class="nav-btn" id="searchNextBtn" onclick="tracker.nextSearchPage()">Next </button>
            </div>
        </div>
    </div>

    <!-- Notification Stack Container -->
    <div id="notificationStack" class="notification-stack"></div>

    <!-- Edit Modal -->
    <div id="editModal" class="modal">
        <div class="modal-content edit-modal-content">
            <div class="modal-header">
                <h3>Edit Entry</h3>
                <button class="btn-close" onclick="closeEditModal()">&times;</button>
            </div>
            <div class="modal-body">
                <form id="editForm">
                    <input type="hidden" id="editId">
                    <div class="form-group">
                        <label for="editActivity">Activity</label>
                        <input type="text" id="editActivity" required>
                    </div>
                    <div class="form-group">
                        <label for="editDescription">Description</label>
                        <textarea id="editDescription" rows="3"></textarea>
                    </div>
                    <div class="form-group form-group-row">
                        <div class="form-group">
                            <label for="editTimestamp">Time</label>
                            <input type="datetime-local" id="editTimestamp" required>
                            <div class="todo-quick-set">
                                <button type="button" id="editTodoButton" class="btn-quick-set" onclick="toggleEditTodo()">
                                    <span id="editTodoButtonText">Mark as Todo</span>
                                </button>
                                <button type="button" id="editNoteButton" class="btn-quick-set" onclick="toggleEditNote()">
                                    <span id="editNoteButtonText">Mark as Note</span>
                                </button>
                            </div>
                        </div>
                        <div class="form-group" id="editDueDateSection">
                            <label for="editDueDate">Due Date (optional)</label>
                            <input type="datetime-local" id="editDueDate">
                            <div class="due-date-quick-sets">
                                <div class="due-date-group">
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('editDueDate', -1, 'day')">-1d</button>
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('editDueDate', 1, 'day')">+1d</button>
                                </div>
                                <div class="due-date-group">
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('editDueDate', -1, 'week')">-1w</button>
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('editDueDate', 1, 'week')">+1w</button>
                                </div>
                                <div class="due-date-group">
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('editDueDate', -1, 'month')">-1m</button>
                                    <button type="button" class="btn-quick-set" onclick="adjustDueDate('editDueDate', 1, 'month')">+1m</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-actions">
                        <button type="submit" class="btn btn-primary">Update Entry</button>
                        <button type="button" class="btn btn-secondary" onclick="closeEditModal()">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Template Management Overlay -->
    <div id="templateManagerOverlay" class="template-overlay">
        <div class="template-overlay-content">
            <div class="template-manager-header">
                <h2>Template Manager</h2>
                <div class="template-manager-actions">
                    <button class="btn btn-primary" onclick="saveAllTemplates()">Save All Changes</button>
                    <button class="btn btn-secondary" onclick="closeTemplateManager()">Close</button>
                </div>
            </div>
            
            <div class="template-manager-body">
                <div class="template-list-panel">
                    <h3>Templates</h3>
                    <div class="template-list" id="templateList">
                        <!-- Template list items will be added here -->
                    </div>
                    <div class="template-list-actions">
                        <button class="btn btn-primary" onclick="addNewTemplate()">Add Template</button>
                        <button class="btn btn-secondary" onclick="resetToDefaults()">Reset All</button>
                    </div>
                </div>
                
                <div class="template-editor-panel">
                    <div class="template-editor-header">
                        <h3 id="templateEditorTitle">Select a template to edit</h3>
                        <div class="template-editor-actions" id="templateEditorActions" style="display: none;">
                            <button class="btn btn-success" onclick="saveCurrentTemplate()">Save</button>
                            <button class="btn btn-danger" onclick="deleteCurrentTemplate()">Delete</button>
                            <button class="btn btn-secondary" onclick="duplicateCurrentTemplate()">Duplicate</button>
                        </div>
                    </div>
                    
                    <div class="template-editor-tabs" id="templateEditorTabs" style="display: none;">
                        <button class="template-tab active" id="tabEditor" onclick="switchTemplateTab('editor')">Editor</button>
                        <button class="template-tab" id="tabPreview" onclick="switchTemplateTab('preview')">Preview</button>
                    </div>
                    
                    <div class="template-editor-content">
                        <div class="template-editor-form" id="templateEditorForm" style="display: none;">
                            <div class="form-group">
                                <label for="templateName">Template Name</label>
                                <input type="text" id="templateName" placeholder="e.g., My Custom Template">
                            </div>
                            
                            <div class="form-group">
                                <label for="templateDescription">Description</label>
                                <input type="text" id="templateDescription" placeholder="Brief description of the template">
                            </div>
                            
                            <div class="form-group">
                                <label for="templateType">Output Type</label>
                                <select id="templateType">
                                    <option value="html">HTML</option>
                                    <option value="markdown">Markdown</option>
                                    <option value="csv">CSV</option>
                                    <option value="text">Plain Text</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="templateContent">Template Content</label>
                                <textarea id="templateContent" rows="20" placeholder="Enter your template content here..."></textarea>
                            </div>
                            
                            <div class="checkbox-group">
                                <input type="checkbox" id="templateIsDefault">
                                <label for="templateIsDefault">Set as default template</label>
                            </div>
                        </div>
                        
                        <div class="template-preview-panel" id="templatePreviewPanel" style="display: none;">
                            <div class="template-preview-header">
                                <h4>Preview</h4>
                                <div class="template-preview-controls">
                                    <div class="preview-format-tabs">
                                        <button class="preview-tab active" id="previewTabRendered" onclick="switchPreviewTab('rendered')">Rendered</button>
                                        <button class="preview-tab" id="previewTabSource" onclick="switchPreviewTab('source')">Source</button>
                                    </div>
                                    <button class="btn btn-secondary btn-small" onclick="refreshTemplatePreview()">Refresh</button>
                                </div>
                            </div>
                            <div class="template-preview-content" id="templatePreviewContent">
                                <p class="template-preview-placeholder">Select a template to see preview</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
        </div>
    </div>

    <!-- Template Guide Modal -->
    <div id="templateGuideModal" class="modal">
        <div class="modal-content template-guide-content">
            <div class="modal-header">
                <h3>Template Guide</h3>
                <button class="btn-close" onclick="closeTemplateGuide()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="template-guide-content">
                    <div class="guide-section">
                        <h4>Getting Started</h4>
                        <p>Templates use a simple variable substitution syntax with double curly braces to create dynamic reports.</p>
                    </div>

                    <div class="guide-section">
                        <h4>Basic Syntax</h4>
                        <ul>
                            <li><code>{{variable}}</code> - Simple variable substitution</li>
                            <li><code>{{#each array}}</code> ... <code>{{/each}}</code> - Loop through arrays</li>
                            <li><code>{{#if condition}}</code> ... <code>{{/if}}</code> - Conditional content</li>
                        </ul>
                    </div>

                    <div class="guide-section">
                        <h4>Pipe Syntax & Function Chaining</h4>
                        <p>Transform data using the pipe (<code>|</code>) syntax to chain multiple functions together:</p>
                        
                        <h5>Basic Pipe Syntax</h5>
                        <ul>
                            <li><code>{{ variable | function }}</code> - Apply a single transformation</li>
                            <li><code>{{ variable | function1 | function2 }}</code> - Chain multiple transformations</li>
                            <li><code>{{ variable | function('parameter') }}</code> - Pass parameters to functions</li>
                        </ul>

                        <h5>Available Transformation Functions</h5>
                        <ul>
                            <li><code>date('format')</code> - Format timestamps as dates
                                <ul>
                                    <li><code>{{ timestamp | date('yyyy-mm-dd') }}</code>  "2025-08-02"</li>
                                    <li><code>{{ timestamp | date('mm/dd/yyyy') }}</code>  "08/02/2025"</li>
                                    <li><code>{{ timestamp | date('dd mmm yyyy') }}</code>  "02 Aug 2025"</li>
                                </ul>
                            </li>
                            <li><code>time</code> - Extract time from timestamps
                                <ul>
                                    <li><code>{{ timestamp | time }}</code>  "14:30:25"</li>
                                </ul>
                            </li>
                            <li><code>escapeCsv</code> - Escape CSV special characters
                                <ul>
                                    <li>Wraps text in quotes if it contains commas, quotes, or newlines</li>
                                    <li><code>{{ "Hello, World" | escapeCsv }}</code>  "\"Hello, World\""</li>
                                </ul>
                            </li>
                            <li><code>stripLinebreaks</code> - Remove line breaks from text
                                <ul>
                                    <li><code>{{ "Line 1\nLine 2" | stripLinebreaks }}</code>  "Line 1 Line 2"</li>
                                </ul>
                            </li>
                        </ul>

                        <h5>CSV Template Example with Chaining</h5>
                        <p>Here's how the CSV template uses chaining to create clean, properly escaped output:</p>
                        <pre><code>{{#each entry = entries}}{{ entry.timestamp | date('yyyy-mm-dd') }},{{ entry.timestamp | time }},{{ entry.activity | escapeCsv | stripLinebreaks }},{{ entry.description | escapeCsv | stripLinebreaks }}
{{/each}}</code></pre>
                        
                        <p><strong>How this works:</strong></p>
                        <ul>
                            <li><code>entry.timestamp | date('yyyy-mm-dd')</code> - Converts timestamp to YYYY-MM-DD format</li>
                            <li><code>entry.timestamp | time</code> - Extracts time portion</li>
                            <li><code>entry.activity | escapeCsv | stripLinebreaks</code> - First removes line breaks, then escapes for CSV</li>
                            <li><code>entry.description | escapeCsv | stripLinebreaks</code> - Same process for descriptions</li>
                        </ul>

                        <h5>Order Matters in Chaining!</h5>
                        <p>Functions are applied left to right, so order is important:</p>
                        <ul>
                            <li> <code>{{ text | stripLinebreaks | escapeCsv }}</code> - Remove breaks first, then escape</li>
                            <li> <code>{{ text | escapeCsv | stripLinebreaks }}</code> - Escaping first may interfere with break removal</li>
                        </ul>
                    </div>

                    <div class="guide-section">
                        <h4>Available Data</h4>
                        <p>The following data is available in your templates:</p>
                        <ul>
                            <li><code>{{reportTitle}}</code> - The report title</li>
                            <li><code>{{startDate}}</code> - Report start date (formatted)</li>
                            <li><code>{{endDate}}</code> - Report end date (formatted)</li>
                            <li><code>{{totalEntries}}</code> - Total number of activity entries</li>
                            <li><code>{{entries}}</code> - Array of all activity entries</li>
                        </ul>
                    </div>

                    <div class="guide-section">
                        <h4>Entry Properties</h4>
                        <p>Each entry in the <code>{{#each entries}}</code> loop has:</p>
                        <ul>
                            <li><code>{{activity}}</code> - The activity name</li>
                            <li><code>{{description}}</code> - Activity description</li>
                            <li><code>{{timestamp}}</code> - Raw ISO timestamp</li>
                            <li><code>{{formattedTime}}</code> - Nicely formatted time (e.g., "2:30 PM")</li>
                            <li><code>{{formattedDate}}</code> - Nicely formatted date (e.g., "Jan 15, 2025")</li>
                            <li><code>{{isTodo}}</code> - Boolean: true if this is a todo item</li>
                            <li><code>{{tags}}</code> - Array of hashtags for this entry</li>
                        </ul>
                    </div>

                    <div class="guide-section">
                        <h4>Common Transformations</h4>
                        <p>Transform timestamps and format data:</p>
                        <ul>
                            <li><strong>Date formats</strong>: Use <code>{{formattedDate}}</code> and <code>{{formattedTime}}</code> for human-readable formats</li>
                            <li><strong>Conditional content</strong>: <code>{{#if description}}{{description}}{{/if}}</code> - only show if description exists</li>
                            <li><strong>Loop through tags</strong>: <code>{{#each tags}}#{{this}} {{/each}}</code> - display all hashtags</li>
                            <li><strong>Todo filtering</strong>: <code>{{#if isTodo}}TODO: {{/if}}</code> - mark todo items</li>
                        </ul>
                    </div>

                    <div class="guide-section">
                        <h4>Markdown Formatting</h4>
                        <p>Use Markdown syntax for readable formatting:</p>
                        <ul>
                            <li><code># {{reportTitle}}</code> - Large heading</li>
                            <li><code>## {{activity}}</code> - Medium heading</li>
                            <li><code>**{{activity}}**</code> - Bold text</li>
                            <li><code>*{{description}}*</code> - Italic text</li>
                            <li><code>- {{activity}}</code> - Bullet point</li>
                            <li><code>`{{formattedTime}}`</code> - Code formatting</li>
                        </ul>
                    </div>

                    <div class="guide-section">
                        <h4>Example Template</h4>
                        <pre><code># {{reportTitle}}
From {{startDate}} to {{endDate}}

Total activities: {{totalEntries}}

{{#each entries}}
## {{formattedTime}} - {{activity}}
{{#if description}}
*{{description}}*
{{/if}}
{{#if tags}}
Tags: {{#each tags}}#{{this}} {{/each}}
{{/if}}
{{#if isTodo}}
**TODO ITEM**
{{/if}}

{{/each}}</code></pre>
                    </div>

                    <div class="guide-section">
                        <h4>Pro Tips</h4>
                        <ul>
                            <li><strong>HTML templates</strong>: Use for rich formatting with CSS styles and complex layouts</li>
                            <li><strong>Markdown templates</strong>: Perfect for simple, readable documentation</li>
                            <li><strong>CSV templates</strong>: Ideal for data analysis in spreadsheets</li>
                            <li><strong>Preview feature</strong>: Always test your templates before saving</li>
                            <li><strong>Custom formats</strong>: Combine multiple variables for unique layouts</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Pomodoro Activity Modal -->
    <div id="pomodoroActivityModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Work Session Activity</h3>
                <button class="btn-close" onclick="closePomodoroActivityModal()">&times;</button>
            </div>
            <div class="modal-body">
                <form id="pomodoroActivityForm">
                    <div class="form-group">
                        <label for="pomodoroActivityName">What will you be working on?</label>
                        <input type="text" id="pomodoroActivityName" required placeholder="e.g., Writing report, Meeting preparation">
                        <div class="quick-actions" style="margin-top: 8px;">
                            <button type="button" id="usePreviousActivityBtn" class="btn btn-small btn-outline" onclick="usePreviousActivity()">Use Previous Activity</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="pomodoroActivityDescription">Description (optional)</label>
                        <textarea id="pomodoroActivityDescription" rows="3" placeholder="Additional details about this work session"></textarea>
                    </div>
                    <div class="modal-actions">
                        <button type="submit" class="btn btn-primary">Start Work Session</button>
                        <button type="button" class="btn btn-secondary" onclick="closePomodoroActivityModal()">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Pomodoro Abandonment Dialog -->
    <div id="pomodoroAbandonModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="pomodoroAbandonTitle">Session Abandonment</h3>
                <button class="btn-close" onclick="closePomodoroAbandonDialog()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="abandon-info">
                    <p id="pomodoroAbandonTimeSpent">You worked for X minutes</p>
                    <p>Would you like to save what you accomplished during this partial session?</p>
                </div>
                <form id="pomodoroAbandonForm">
                    <div class="form-group">
                        <label for="pomodoroAbandonActivityName">Activity accomplished</label>
                        <input type="text" id="pomodoroAbandonActivityName" placeholder="What did you work on during this time?">
                    </div>
                    <div class="form-group">
                        <label for="pomodoroAbandonActivityDescription">Description (optional)</label>
                        <textarea id="pomodoroAbandonActivityDescription" rows="2" placeholder="Additional details about what you accomplished"></textarea>
                    </div>
                    <div class="modal-actions">
                        <button type="button" class="btn btn-primary" onclick="handlePomodoroAbandonmentSave(true)">Save Work & Abandon</button>
                        <button type="button" class="btn btn-secondary" onclick="handlePomodoroAbandonmentSave(false)">Just Abandon</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Confirmation Dialog -->
    <div id="confirmationModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="confirmationTitle">Confirm Action</h3>
                <button class="btn-close" onclick="closeConfirmationDialog()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="confirmation-content">
                    <p id="confirmationMessage">Are you sure you want to perform this action?</p>
                </div>
                
                <div class="confirmation-options" id="confirmationSkipSection" style="display: none;">
                    <div class="checkbox-group">
                        <input type="checkbox" id="confirmationSkipFuture">
                        <label for="confirmationSkipFuture">Don't ask again for this type of action</label>
                    </div>
                </div>
                
                <div class="modal-actions">
                    <button type="button" id="confirmationConfirmBtn" class="btn btn-danger">Confirm</button>
                    <button type="button" class="btn btn-secondary" onclick="closeConfirmationDialog()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Activity Hours Info Modal -->
    <div id="activityHoursInfoModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3> Activity Hours Information</h3>
                <button class="btn-close" onclick="closeActivityHoursInfo()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="activity-hours-info">
                    <p><strong>Reminder alerts are switched off outside of activity hours.</strong></p>
                    <p>To receive activity reminders, please update your activity schedule in the settings section. You can customize:</p>
                    <ul>
                        <li>Activity days (Monday through Sunday)</li>
                        <li>Start and end times for each day</li>
                        <li>Different schedules for different days</li>
                    </ul>
                    <p>When you're outside your configured activity hours, reminders are automatically paused to avoid disrupting your personal time.</p>
                </div>
                
                <div class="modal-actions">
                    <button type="button" class="btn btn-primary" onclick="goToActivityHoursSettings()">
                         Configure Activity Hours
                    </button>
                    <button type="button" class="btn btn-secondary" onclick="closeActivityHoursInfo()">Got It</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Overdue Alert Modal -->
    <div id="overdueAlertModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3> Overdue Items</h3>
                <button class="btn-close" onclick="closeOverdueAlert()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="overdue-info">
                    <p>The following items are past their due date:</p>
                </div>
                
                <div class="overdue-items-list" id="overdueItemsList">
                    <!-- Populated by JavaScript -->
                </div>
                
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeOverdueAlert()">Got It</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Hashtag Browser Modal -->
    <div id="hashtagBrowserModal" class="modal">
        <div class="modal-content hashtag-browser-content">
            <div class="modal-header">
                <h3>Hashtag Browser</h3>
                <button class="btn-close" onclick="closeHashtagBrowser()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="hashtag-stats" id="hashtagStats">
                    <span id="hashtagCount">0 hashtags found</span>
                </div>
                <div class="hashtag-cloud" id="hashtagCloud">
                    <p class="empty-state">No hashtags found. Add activities with #hashtags to see them here!</p>
                </div>
            </div>
        </div>
    </div>

    <!-- User Guide Modal -->
    <div id="userGuideModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>User Guide</h3>
                <button class="btn-close" onclick="closeUserGuide()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="user-guide-content">
                    <div class="guide-section">
                        <h4>Getting Started</h4>
                        <p>Activity Tracker is a personal activity tracking application with smart notifications, comprehensive reporting, and Pomodoro timer functionality.</p>
                        
                        <p><strong>Key Features:</strong></p>
                        <ul>
                            <li>Pomodoro Timer with configurable work/break cycles</li>
                            <li>Smart notification system with customizable sounds</li>
                            <li>Comprehensive activity reporting with custom templates</li>
                            <li>Dark mode support</li>
                            <li>Offline functionality with service worker</li>
                            <li>Progressive Web App (PWA) support</li>
                        </ul>
                    </div>
                    
                    <div class="guide-section">
                        <h4>Keyboard Shortcuts</h4>
                        <ul>
                            <li><kbd>Shift</kbd> + <kbd>Space</kbd> - Focus activity input field</li>
                            <li><kbd>Shift</kbd> + <kbd>Enter</kbd> - Submit activity form</li>
                            <li><kbd>Ctrl</kbd> + <kbd>T</kbd> - Toggle todo/not todo status</li>
                            <li><kbd>Ctrl</kbd> + <kbd>N</kbd> - Toggle note status</li>
                            <li><kbd>Esc</kbd> - Close modals</li>
                        </ul>
                    </div>
                    
                    <div class="guide-section">
                        <h4>Adding Activities</h4>
                        <ul>
                            <li>Enter what you're doing in the activity field</li>
                            <li>Add #hashtags for easy categorization</li>
                            <li>Use the "Mark as Todo" button for tasks that need completion</li>
                            <li>Use the "Mark as Note" button for reference items (excluded from reports)</li>
                            <li>Set due dates for todos using quick-set buttons</li>
                        </ul>
                    </div>
                    
                    <div class="guide-section">
                        <h4>Search & Navigation</h4>
                        <ul>
                            <li>Use the global search to find activities, todos, and hashtags</li>
                            <li>Click the  button to browse hashtags in a visual cloud</li>
                            <li>Click any hashtag to search for related items</li>
                            <li>Use pagination controls to navigate through large lists</li>
                        </ul>
                    </div>
                    
                    <div class="guide-section">
                        <h4>Managing Todos</h4>
                        <ul>
                            <li>View all todos in the dedicated "To Do" section</li>
                            <li>Filter by status, due date, or category</li>
                            <li>Click "Mark Complete" to finish todos</li>
                            <li>Overdue items are highlighted in red</li>
                        </ul>
                    </div>
                    
                    <div class="guide-section">
                        <h4>Reports</h4>
                        <ul>
                            <li>Generate weekly, custom date range, or template-based reports</li>
                            <li>Export reports in HTML, Markdown, or CSV formats</li>
                            <li>Create custom report templates with variables</li>
                            <li>Include/exclude completed todos from reports</li>
                        </ul>
                    </div>
                    
                    <div class="guide-section">
                        <h4>Pomodoro Mode (Optional)</h4>
                        <ul>
                            <li>Enable Pomodoro technique with customizable work/break intervals</li>
                            <li>Automatic activity logging during Pomodoro sessions</li>
                            <li>Audio notifications for work/break transitions</li>
                            <li>Focus timer to help maintain productivity</li>
                        </ul>
                    </div>
                    
                    <div class="guide-section">
                        <h4>Settings & Customization</h4>
                        <ul>
                            <li>Customize notification intervals and activity hours</li>
                            <li>Choose from multiple notification sounds</li>
                            <li>Switch between light/dark themes</li>
                            <li>Set pagination size for better navigation</li>
                            <li>All settings auto-save as you change them</li>
                        </ul>
                    </div>
                    
                    <div class="guide-section">
                        <h4>Data Management</h4>
                        <ul>
                            <li>Export your data as JSON backup</li>
                            <li>Import previously exported data</li>
                            <li>Data is stored locally in your browser</li>
                            <li>Works offline after initial load</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- About Modal -->
    <!-- Notification Permission Setup Modal -->
    <div id="notificationPermissionModal" class="modal">
        <div class="modal-content notification-permission-content">
            <div class="modal-header">
                <h3>Enable System Notifications?</h3>
            </div>
            <div class="modal-body">
                <div class="notification-permission-info">
                    <p><strong>Activity Tracker</strong> can send reminder notifications directly to your operating system.</p>
                    <p>This allows you to receive activity reminders even when the app is minimized or you're using other applications.</p>
                    
                    <div class="permission-options">
                        <div class="permission-option permission-clickable" onclick="requestNotificationPermission()">
                            <h4> Enable System Notifications</h4>
                            <p>Get reminder alerts through your operating system's notification center, plus sound alerts in the app.</p>
                        </div>
                        <div class="permission-option permission-clickable" onclick="declineNotificationPermission()">
                            <h4> Sound Only</h4>
                            <p>Use only sound alerts within the app (no system notifications).</p>
                        </div>
                    </div>
                    
                    <p class="permission-note"><em>You can change this setting later in the General Settings section.</em></p>
                </div>
                
                <div class="modal-actions">
                    <button type="button" class="btn btn-primary" onclick="requestNotificationPermission()">Enable System Notifications</button>
                    <button type="button" class="btn btn-secondary" onclick="declineNotificationPermission()">Sound Only</button>
                </div>
            </div>
        </div>
    </div>

    <div id="aboutModal" class="modal">
        <div class="modal-content about-modal-content">
            <div class="modal-header">
                <h3>About Activity Tracker</h3>
                <button class="btn-close" onclick="closeAbout()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="about-section">
                    <h4>Application Info</h4>
                    <div class="debug-info" id="aboutDebugInfo">Loading...</div>
                </div>
                
                <div class="about-section">
                    <h4>Version History</h4>
                    <div id="versionHistoryContainer">
                        Loading version history...
                    </div>
                </div>
                
                <div class="about-section copyright-section">
                    <div class="copyright-card">
                        <div class="copyright-header">
                            <h4>Activity Tracker</h4>
                            <div class="copyright-badge">
                                &copy; <span id="copyrightYear">2025</span>
                            </div>
                        </div>
                        
                        <div class="copyright-author">
                            <p>&copy; <span id="copyrightYearRange">2025</span> <a href="https://github.com/seesee" target="_blank" rel="noopener noreferrer" class="author-link">Chris Carline</a></p>
                        </div>

                        <div class="copyright-description">
                            <p>Personal activity tracking application built as a Progressive Web App. All data is stored locally on your device and remains completely private. No cookies, analytics, or tracking technologies used.</p>
                        </div>

                        <div class="copyright-actions">
                            <a href="https://github.com/seesee/activity-tracker" target="_blank" rel="noopener noreferrer" class="github-button">
                                <span class="github-icon"></span>
                                <span>View on GitHub</span>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Workspace Manager Modal -->
    <div id="workspaceManagerModal" class="modal">
        <div class="modal-content workspace-manager-content">
            <div class="modal-header">
                <h3> Workspace Manager</h3>
                <button class="btn-close" onclick="closeWorkspaceManager()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="workspace-info">
                    <div class="current-workspace">
                        <h4>Current Workspace: <span id="currentWorkspaceName">Default</span></h4>
                        <p class="workspace-description">Each workspace maintains separate activities, settings, and state. Switch between workspaces to organize different projects or contexts.</p>
                    </div>
                </div>
                
                <div class="workspace-list-section">
                    <h4>Available Workspaces</h4>
                    <div class="workspace-list" id="workspaceList">
                        <!-- Workspaces will be populated here -->
                    </div>
                </div>
                
                <div class="workspace-actions">
                    <div class="create-workspace">
                        <input type="text" id="newWorkspaceName" placeholder="Enter workspace name..." maxlength="50">
                        <button class="btn btn-primary" onclick="createNewWorkspace()">Create Workspace</button>
                    </div>
                </div>
                
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeWorkspaceManager()">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Application version
const APP_VERSION = '2025.08.07.31';


// === utils.js ===
/**
 * Utility functions for the Activity Tracker application
 */

/**
 * Format a timestamp to a readable date and time string
 * @param {string} timestamp - ISO timestamp string
 * @returns {string} Formatted date and time
 */
function formatDateTime(timestamp) {
    const date = new Date(timestamp);
    return date.toLocaleString('en-GB', {
        weekday: 'short',
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
    });
}

/**
 * Format a date to a readable date string
 * @param {Date} date - Date object
 * @returns {string} Formatted date
 */
function formatDate(date) {
    return date.toLocaleDateString('en-GB', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    });
}

/**
 * Format a timestamp to just the time portion
 * @param {string} timestamp - ISO timestamp string
 * @returns {string} Formatted time
 */
function formatTime(timestamp) {
    const date = new Date(timestamp);
    return date.toLocaleTimeString('en-GB', {
        hour: '2-digit',
        minute: '2-digit'
    });
}

/**
 * Escape HTML special characters to prevent XSS
 * @param {string} text - Text to escape
 * @returns {string} HTML-safe text
 */
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

/**
 * Toast notification manager for stacking notifications
 */
const ToastManager = {
    notifications: [],
    container: null,

    init() {
        if (!this.container) {
            // Create container for notifications
            this.container = document.createElement('div');
            this.container.id = 'toast-container';
            this.container.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 10000;
                pointer-events: none;
                display: flex;
                flex-direction: column;
                gap: 10px;
                max-width: 400px;
            `;
            document.body.appendChild(this.container);

            // Add global styles for animations
            if (!document.getElementById('toast-styles')) {
                const style = document.createElement('style');
                style.id = 'toast-styles';
                style.textContent = `
                    @keyframes slideDownIn {
                        from {
                            transform: translateY(-100%);
                            opacity: 0;
                        }
                        to {
                            transform: translateY(0);
                            opacity: 1;
                        }
                    }
                    @keyframes slideRightOut {
                        from {
                            transform: translateX(0);
                            opacity: 1;
                        }
                        to {
                            transform: translateX(120%);
                            opacity: 0;
                        }
                    }
                    @keyframes pushDown {
                        from {
                            transform: translateY(0);
                        }
                        to {
                            transform: translateY(10px);
                        }
                    }
                `;
                document.head.appendChild(style);
            }
        }
    },

    show(message, type = 'info', duration = 3000) {
        this.init();

        const notification = document.createElement('div');
        notification.className = 'toast-notification';
        notification.style.cssText = `
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            background: ${type === 'success' ? '#48bb78' : type === 'error' ? '#f56565' : '#667eea'};
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            animation: slideDownIn 0.3s ease-out;
            pointer-events: auto;
            max-width: 100%;
            word-wrap: break-word;
        `;

        notification.innerHTML = message;
        
        // Add to container (will appear at top due to flex-direction: column)
        this.container.appendChild(notification);
        this.notifications.push(notification);

        // Push existing notifications down with animation
        this.notifications.slice(0, -1).forEach(existingNotification => {
            if (existingNotification.parentNode) {
                existingNotification.style.animation = 'pushDown 0.2s ease-out';
            }
        });

        // Auto-remove after duration
        setTimeout(() => {
            this.remove(notification);
        }, duration);

        return notification;
    },

    remove(notification) {
        if (!notification || !notification.parentNode) {
            return;
        }

        // Remove from tracking array immediately to prevent double removal
        const index = this.notifications.indexOf(notification);
        if (index > -1) {
            this.notifications.splice(index, 1);
        }

        // Clear any existing animation and apply slide out
        notification.style.animation = 'none';
        // Force reflow to ensure animation is cleared
        notification.offsetHeight;
        notification.style.animation = 'slideRightOut 0.3s ease-in forwards';
        
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, 300);
    }
};

/**
 * Show a temporary notification message
 * @param {string} message - Message to display
 * @param {string} type - Type of notification (info, success, error)
 * @param {number} duration - Duration in milliseconds
 */
function showNotification(message, type = 'info', duration = 3000) {
    return ToastManager.show(message, type, duration);
}

/**
 * Download a file with the given content
 * @param {string} content - File content
 * @param {string} filename - Desired filename
 * @param {string} mimeType - MIME type of the file
 */
function downloadFile(content, filename, mimeType) {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

/**
 * Get the current time formatted for datetime-local input
 * @returns {string} Current time in datetime-local format
 */
function getCurrentTimeForInput() {
    const now = new Date();
    now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
    return now.toISOString().slice(0, 16);
}

/**
 * Escape CSV field content
 * @param {string} str - String to escape
 * @returns {string} CSV-safe string
 */
function escapeCsv(str) {
    if (!str) return '';
    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
        return `"${str.replace(/"/g, '""')}"`;
    }
    return str;
}

/**
 * Generate a unique ID based on timestamp
 * @returns {string} Unique identifier
 */
function generateId() {
    return Date.now().toString() + Math.random().toString(36).substr(2, 9);
}

/**
 * Validate if a date string is valid
 * @param {string} dateString - Date string to validate
 * @returns {boolean} True if valid date
 */
function isValidDate(dateString) {
    const date = new Date(dateString);
    return date instanceof Date && !isNaN(date);
}

/**
 * Get week start date (Monday) for a given date
 * @param {Date} date - Reference date
 * @returns {Date} Monday of that week
 */
function getWeekStart(date) {
    const monday = new Date(date);
    const dayOfWeek = date.getDay();
    const daysToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
    monday.setDate(date.getDate() + daysToMonday);
    monday.setHours(0, 0, 0, 0);
    return monday;
}

/**
 * Get week end date (Sunday) for a given date
 * @param {Date} date - Reference date
 * @returns {Date} Sunday of that week
 */
function getWeekEnd(date) {
    const sunday = new Date(getWeekStart(date));
    sunday.setDate(sunday.getDate() + 6);
    sunday.setHours(23, 59, 59, 999);
    return sunday;
}

/**
 * Deep clone an object
 * @param {Object} obj - Object to clone
 * @returns {Object} Cloned object
 */
function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (obj instanceof Date) return new Date(obj.getTime());
    if (obj instanceof Array) return obj.map(item => deepClone(item));
    if (typeof obj === 'object') {
        const cloned = {};
        Object.keys(obj).forEach(key => {
            cloned[key] = deepClone(obj[key]);
        });
        return cloned;
    }
}


// === sounds.js ===
/**
 * Sound management for Activity Tracker
 * Handles different notification sound types and synthesis
 */

class SoundManager {
    constructor() {
        this.audioContext = null;
        this.soundTypes = {
            'classic': 'Classic Bloop',
            'gentle': 'Gentle Chime',
            'urgent': 'Urgent Ping',
            'digital': 'Digital Beep',
            'nature': 'Nature Drop',
            'mechanical': 'Mechanical Click',
            'spacey': 'Spacey Wobble',
            'corporate': 'Corporate Ding',
            'retro': 'Retro Arcade',
            'piano': 'Piano Note',
            'bell': 'Temple Bell',
            'whistle': 'Train Whistle',
            'bubble': 'Bubble Pop',
            'glass': 'Glass Tap',
            'wood': 'Wood Block',
            'metal': 'Metal Ting',
            'ethereal': 'Ethereal Hum',
            'cosmic': 'Cosmic Blip',
            'ocean': 'Ocean Wave',
            'forest': 'Forest Chirp',
            'failsafe': 'Failsafe',
            // Pomodoro tick sounds
            'soft-tick': 'Soft Tick',
            'classic-tick': 'Classic Tick',
            'digital-tick': 'Digital Tick'
        };
        this.initAudioContext();
    }

    /**
     * Initialize Web Audio API context
     */
    initAudioContext() {
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // For iOS, we need to unlock the audio context with user interaction
            if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                this.unlockAudioContextForIOS();
            }
        } catch (error) {
            console.warn('Web Audio API not supported:', error);
            this.audioContext = null;
        }
    }

    /**
     * Unlock AudioContext for iOS - must be called from user interaction
     */
    unlockAudioContextForIOS() {
        if (!this.audioContext || this.audioContext.state !== 'suspended') {
            return;
        }

        // Create a short silent buffer to unlock the context
        const unlockAudio = () => {
            if (this.audioContext.state === 'suspended') {
                const buffer = this.audioContext.createBuffer(1, 1, 22050);
                const source = this.audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(this.audioContext.destination);
                source.start(0);
                
                this.audioContext.resume().then(() => {
                    console.log('iOS AudioContext unlocked successfully');
                }).catch(error => {
                    console.warn('Failed to unlock iOS AudioContext:', error);
                });
            }
        };

        // Add event listeners for user interactions to unlock audio
        const events = ['touchstart', 'touchend', 'mousedown', 'keydown'];
        const unlock = () => {
            unlockAudio();
            // Remove listeners after first interaction
            events.forEach(event => document.removeEventListener(event, unlock, true));
        };
        
        events.forEach(event => document.addEventListener(event, unlock, true));
    }

    /**
     * Get available sound types
     * @returns {Object} Sound types object
     */
    getSoundTypes() {
        return this.soundTypes;
    }

    /**
     * Play notification sound of specified type
     * @param {string} soundType - Type of sound to play
     * @param {boolean} muted - Whether sound is muted
     */
    playSound(soundType = 'classic', muted = false) {
        if (!this.audioContext || muted) {
            return;
        }

        try {
            // Resume audio context if it's suspended (critical for iOS)
            if (this.audioContext.state === 'suspended') {
                // For iOS, we need to handle the promise properly
                const resumePromise = this.audioContext.resume();
                if (resumePromise && resumePromise.then) {
                    resumePromise.then(() => {
                        console.log('AudioContext resumed successfully');
                        this.playSoundInternal(soundType);
                    }).catch(error => {
                        console.warn('Failed to resume AudioContext:', error);
                        // Try to reinitialize on iOS if resume fails
                        if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                            this.initAudioContext();
                            if (this.audioContext && this.audioContext.state !== 'suspended') {
                                this.playSoundInternal(soundType);
                            }
                        }
                    });
                    return;
                } else {
                    this.audioContext.resume();
                }
            }
            
            this.playSoundInternal(soundType);
        } catch (error) {
            console.warn('Error playing notification sound:', error);
        }
    }

    /**
     * Internal method to actually play the sound after AudioContext is ready
     */
    playSoundInternal(soundType) {
        try {

            const currentTime = this.audioContext.currentTime;
            
            switch (soundType) {
                case 'classic':
                    this.playClassicBloop(currentTime);
                    break;
                case 'gentle':
                    this.playGentleChime(currentTime);
                    break;
                case 'urgent':
                    this.playUrgentPing(currentTime);
                    break;
                case 'digital':
                    this.playDigitalBeep(currentTime);
                    break;
                case 'nature':
                    this.playNatureDrop(currentTime);
                    break;
                case 'mechanical':
                    this.playMechanicalClick(currentTime);
                    break;
                case 'spacey':
                    this.playSpaceyWobble(currentTime);
                    break;
                case 'corporate':
                    this.playCorporateDing(currentTime);
                    break;
                case 'retro':
                    this.playRetroArcade(currentTime);
                    break;
                case 'piano':
                    this.playPianoNote(currentTime);
                    break;
                case 'bell':
                    this.playTempleBell(currentTime);
                    break;
                case 'whistle':
                    this.playTrainWhistle(currentTime);
                    break;
                case 'bubble':
                    this.playBubblePop(currentTime);
                    break;
                case 'glass':
                    this.playGlassTap(currentTime);
                    break;
                case 'wood':
                    this.playWoodBlock(currentTime);
                    break;
                case 'metal':
                    this.playMetalTing(currentTime);
                    break;
                case 'ethereal':
                    this.playEtherealHum(currentTime);
                    break;
                case 'cosmic':
                    this.playCosmicBlip(currentTime);
                    break;
                case 'ocean':
                    this.playOceanWave(currentTime);
                    break;
                case 'forest':
                    this.playForestChirp(currentTime);
                    break;
                case 'failsafe':
                    this.playFailsafe(currentTime);
                    break;
                case 'soft-tick':
                    this.playSoftTick(currentTime);
                    break;
                case 'classic-tick':
                    this.playClassicTick(currentTime);
                    break;
                case 'digital-tick':
                    this.playDigitalTick(currentTime);
                    break;
                default:
                    this.playClassicBloop(currentTime);
            }
            
            console.log(`Notification sound played: ${soundType}`);
        } catch (error) {
            console.warn('Error in playSoundInternal:', error);
        }
    }

    /**
     * Classic bloop sound (original)
     */
    playClassicBloop(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(400, currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(600, currentTime + 0.1);
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.3, currentTime + 0.05);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.3);
        
        oscillator.start(currentTime);
        oscillator.stop(currentTime + 0.3);
    }

    /**
     * Gentle chime sound
     */
    playGentleChime(currentTime) {
        const oscillator1 = this.audioContext.createOscillator();
        const oscillator2 = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator1.connect(gainNode);
        oscillator2.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator1.type = 'sine';
        oscillator2.type = 'sine';
        oscillator1.frequency.setValueAtTime(523.25, currentTime); // C5
        oscillator2.frequency.setValueAtTime(659.25, currentTime); // E5
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.2, currentTime + 0.05);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 1.0);
        
        oscillator1.start(currentTime);
        oscillator2.start(currentTime);
        oscillator1.stop(currentTime + 1.0);
        oscillator2.stop(currentTime + 1.0);
    }

    /**
     * Urgent ping sound
     */
    playUrgentPing(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.type = 'triangle';
        oscillator.frequency.setValueAtTime(800, currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(1200, currentTime + 0.05);
        oscillator.frequency.exponentialRampToValueAtTime(800, currentTime + 0.1);
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.4, currentTime + 0.02);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.15);
        
        oscillator.start(currentTime);
        oscillator.stop(currentTime + 0.15);
    }

    /**
     * Digital beep sound
     */
    playDigitalBeep(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(1000, currentTime);
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.3, currentTime + 0.01);
        gainNode.gain.linearRampToValueAtTime(0.3, currentTime + 0.05);
        gainNode.gain.linearRampToValueAtTime(0, currentTime + 0.06);
        
        oscillator.start(currentTime);
        oscillator.stop(currentTime + 0.06);
    }

    /**
     * Nature drop sound
     */
    playNatureDrop(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(1200, currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(200, currentTime + 0.8);
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(2000, currentTime);
        filter.frequency.exponentialRampToValueAtTime(300, currentTime + 0.8);
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.25, currentTime + 0.05);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.8);
        
        oscillator.start(currentTime);
        oscillator.stop(currentTime + 0.8);
    }

    /**
     * Mechanical click sound
     */
    playMechanicalClick(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.type = 'sawtooth';
        oscillator.frequency.setValueAtTime(150, currentTime);
        
        filter.type = 'highpass';
        filter.frequency.setValueAtTime(100, currentTime);
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.5, currentTime + 0.005);
        gainNode.gain.linearRampToValueAtTime(0, currentTime + 0.05);
        
        oscillator.start(currentTime);
        oscillator.stop(currentTime + 0.05);
    }

    /**
     * Spacey wobble sound
     */
    playSpaceyWobble(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const lfo = this.audioContext.createOscillator();
        const lfoGain = this.audioContext.createGain();
        const gainNode = this.audioContext.createGain();
        
        lfo.connect(lfoGain);
        lfoGain.connect(oscillator.frequency);
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(300, currentTime);
        
        lfo.type = 'sine';
        lfo.frequency.setValueAtTime(6, currentTime);
        lfoGain.gain.setValueAtTime(50, currentTime);
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.3, currentTime + 0.1);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 1.2);
        
        lfo.start(currentTime);
        oscillator.start(currentTime);
        lfo.stop(currentTime + 1.2);
        oscillator.stop(currentTime + 1.2);
    }

    /**
     * Corporate ding sound
     */
    playCorporateDing(currentTime) {
        const oscillator1 = this.audioContext.createOscillator();
        const oscillator2 = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator1.connect(gainNode);
        oscillator2.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator1.type = 'sine';
        oscillator2.type = 'sine';
        oscillator1.frequency.setValueAtTime(880, currentTime); // A5
        oscillator2.frequency.setValueAtTime(1108.73, currentTime); // C#6
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.25, currentTime + 0.02);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.5);
        
        oscillator1.start(currentTime);
        oscillator2.start(currentTime);
        oscillator1.stop(currentTime + 0.5);
        oscillator2.stop(currentTime + 0.5);
    }

    /**
     * Retro arcade sound
     */
    playRetroArcade(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(220, currentTime);
        oscillator.frequency.setValueAtTime(330, currentTime + 0.1);
        oscillator.frequency.setValueAtTime(440, currentTime + 0.2);
        oscillator.frequency.setValueAtTime(550, currentTime + 0.3);
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.3, currentTime + 0.02);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.4);
        
        oscillator.start(currentTime);
        oscillator.stop(currentTime + 0.4);
    }

    /**
     * Piano note sound
     */
    playPianoNote(currentTime) {
        const oscillator1 = this.audioContext.createOscillator();
        const oscillator2 = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator1.connect(gainNode);
        oscillator2.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator1.type = 'sine';
        oscillator2.type = 'triangle';
        oscillator1.frequency.setValueAtTime(523.25, currentTime); // C5
        oscillator2.frequency.setValueAtTime(523.25, currentTime);
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.4, currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 1.5);
        
        oscillator1.start(currentTime);
        oscillator2.start(currentTime);
        oscillator1.stop(currentTime + 1.5);
        oscillator2.stop(currentTime + 1.5);
    }

    /**
     * Temple bell sound
     */
    playTempleBell(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(800, currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(400, currentTime + 2.0);
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(1200, currentTime);
        filter.Q.setValueAtTime(5, currentTime);
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.3, currentTime + 0.05);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 2.0);
        
        oscillator.start(currentTime);
        oscillator.stop(currentTime + 2.0);
    }

    /**
     * Train whistle sound
     */
    playTrainWhistle(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(880, currentTime);
        oscillator.frequency.setValueAtTime(660, currentTime + 0.5);
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.4, currentTime + 0.1);
        gainNode.gain.linearRampToValueAtTime(0.4, currentTime + 0.4);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.8);
        
        oscillator.start(currentTime);
        oscillator.stop(currentTime + 0.8);
    }

    /**
     * Bubble pop sound
     */
    playBubblePop(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(800, currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(400, currentTime + 0.1);
        
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(600, currentTime);
        filter.Q.setValueAtTime(3, currentTime);
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.3, currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.1);
        
        oscillator.start(currentTime);
        oscillator.stop(currentTime + 0.1);
    }

    /**
     * Glass tap sound
     */
    playGlassTap(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.type = 'triangle';
        oscillator.frequency.setValueAtTime(2000, currentTime);
        
        filter.type = 'highpass';
        filter.frequency.setValueAtTime(1000, currentTime);
        filter.Q.setValueAtTime(2, currentTime);
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.5, currentTime + 0.005);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.3);
        
        oscillator.start(currentTime);
        oscillator.stop(currentTime + 0.3);
    }

    /**
     * Wood block sound
     */
    playWoodBlock(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.type = 'sawtooth';
        oscillator.frequency.setValueAtTime(400, currentTime);
        
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(800, currentTime);
        filter.Q.setValueAtTime(5, currentTime);
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.6, currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.08);
        
        oscillator.start(currentTime);
        oscillator.stop(currentTime + 0.08);
    }

    /**
     * Metal ting sound
     */
    playMetalTing(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.type = 'triangle';
        oscillator.frequency.setValueAtTime(1500, currentTime);
        
        filter.type = 'highpass';
        filter.frequency.setValueAtTime(800, currentTime);
        filter.Q.setValueAtTime(3, currentTime);
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.4, currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.6);
        
        oscillator.start(currentTime);
        oscillator.stop(currentTime + 0.6);
    }

    /**
     * Ethereal hum sound
     */
    playEtherealHum(currentTime) {
        const oscillator1 = this.audioContext.createOscillator();
        const oscillator2 = this.audioContext.createOscillator();
        const lfo = this.audioContext.createOscillator();
        const lfoGain = this.audioContext.createGain();
        const gainNode = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        lfo.connect(lfoGain);
        lfoGain.connect(oscillator1.frequency);
        oscillator1.connect(filter);
        oscillator2.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator1.type = 'sine';
        oscillator2.type = 'sine';
        oscillator1.frequency.setValueAtTime(220, currentTime);
        oscillator2.frequency.setValueAtTime(330, currentTime);
        
        lfo.type = 'sine';
        lfo.frequency.setValueAtTime(0.5, currentTime);
        lfoGain.gain.setValueAtTime(10, currentTime);
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(800, currentTime);
        filter.Q.setValueAtTime(1, currentTime);
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.2, currentTime + 0.3);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 2.0);
        
        lfo.start(currentTime);
        oscillator1.start(currentTime);
        oscillator2.start(currentTime);
        lfo.stop(currentTime + 2.0);
        oscillator1.stop(currentTime + 2.0);
        oscillator2.stop(currentTime + 2.0);
    }

    /**
     * Cosmic blip sound
     */
    playCosmicBlip(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const lfo = this.audioContext.createOscillator();
        const lfoGain = this.audioContext.createGain();
        const gainNode = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        lfo.connect(lfoGain);
        lfoGain.connect(oscillator.frequency);
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(600, currentTime);
        
        lfo.type = 'sine';
        lfo.frequency.setValueAtTime(20, currentTime);
        lfoGain.gain.setValueAtTime(200, currentTime);
        
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(800, currentTime);
        filter.Q.setValueAtTime(2, currentTime);
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.3, currentTime + 0.05);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.4);
        
        lfo.start(currentTime);
        oscillator.start(currentTime);
        lfo.stop(currentTime + 0.4);
        oscillator.stop(currentTime + 0.4);
    }

    /**
     * Ocean wave sound
     */
    playOceanWave(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.type = 'sawtooth';
        oscillator.frequency.setValueAtTime(80, currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(40, currentTime + 1.5);
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(200, currentTime);
        filter.frequency.exponentialRampToValueAtTime(80, currentTime + 1.5);
        filter.Q.setValueAtTime(2, currentTime);
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.3, currentTime + 0.2);
        gainNode.gain.linearRampToValueAtTime(0.2, currentTime + 1.0);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 1.5);
        
        oscillator.start(currentTime);
        oscillator.stop(currentTime + 1.5);
    }

    /**
     * Forest chirp sound
     */
    playForestChirp(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(1200, currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(1800, currentTime + 0.1);
        oscillator.frequency.exponentialRampToValueAtTime(1000, currentTime + 0.3);
        
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(1400, currentTime);
        filter.Q.setValueAtTime(3, currentTime);
        
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.25, currentTime + 0.05);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.3);
        
        oscillator.start(currentTime);
        oscillator.stop(currentTime + 0.3);
    }

    /**
     * Failsafe sound - A magical, multi-layered easter egg sound
     * This creates an ascending cascade of crystalline tones with harmonic layers
     */
    playFailsafe(currentTime) {
        // Create multiple oscillators for a rich, magical sound
        const oscillators = [];
        const gainNodes = [];
        const filters = [];
        
        // Magic frequencies based on the golden ratio and harmonious intervals
        const baseFreq = 130.81; // C3 (one octave lower than C4)
        const magicFreqs = [
            baseFreq,           // C3 - Root
            baseFreq * 1.25,    // E3 - Major third
            baseFreq * 1.5,     // G3 - Perfect fifth
            baseFreq * 2,       // C4 - Octave
            baseFreq * 2.5,     // E4 - Major tenth
            baseFreq * 3,       // G4 - Perfect twelfth
            baseFreq * 4,       // C5 - Double octave
            baseFreq * 5.04,    // E5 - Major seventeenth (golden ratio influenced)
        ];
        
        // Create the main magical chord progression
        magicFreqs.forEach((freq, index) => {
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            const filter = this.audioContext.createBiquadFilter();
            
            oscillators.push(oscillator);
            gainNodes.push(gainNode);
            filters.push(filter);
            
            // Connect the audio chain
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            
            // Use a mix of sine and triangle waves for ethereal quality
            oscillator.type = index % 2 === 0 ? 'sine' : 'triangle';
            oscillator.frequency.setValueAtTime(freq, currentTime);
            
            // Create ascending frequency sweeps for magical effect
            oscillator.frequency.exponentialRampToValueAtTime(freq * 1.618, currentTime + 0.8); // Golden ratio sweep
            oscillator.frequency.exponentialRampToValueAtTime(freq * 2, currentTime + 1.6);
            oscillator.frequency.exponentialRampToValueAtTime(freq * 0.5, currentTime + 2.4);
            
            // Configure filters for crystalline quality
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(freq * 2, currentTime);
            filter.frequency.exponentialRampToValueAtTime(freq * 8, currentTime + 1.2);
            filter.Q.setValueAtTime(3 + index * 0.5, currentTime);
            
            // Staggered gain envelopes for cascading effect
            const delay = index * 0.1; // Each note enters slightly after the previous
            const volume = 0.08 / (index + 1); // Decreasing volume for higher frequencies
            
            gainNode.gain.setValueAtTime(0, currentTime + delay);
            gainNode.gain.linearRampToValueAtTime(volume, currentTime + delay + 0.2);
            gainNode.gain.exponentialRampToValueAtTime(volume * 0.7, currentTime + delay + 1.0);
            gainNode.gain.linearRampToValueAtTime(volume * 0.3, currentTime + delay + 2.0);
            gainNode.gain.exponentialRampToValueAtTime(0.001, currentTime + delay + 3.0);
            
            oscillator.start(currentTime + delay);
            oscillator.stop(currentTime + delay + 3.0);
        });
        
        // Add powerful bass/sub-bass foundation for extra impact
        const bassFreqs = [
            baseFreq / 4,       // C2 - Sub-bass octave (32.7 Hz)
            baseFreq / 2,       // C3 - Bass octave (65.4 Hz)
            baseFreq / 2 * 1.5, // G2 - Bass fifth (98.1 Hz)
        ];
        
        bassFreqs.forEach((freq, index) => {
            const bassOsc = this.audioContext.createOscillator();
            const bassGain = this.audioContext.createGain();
            const bassFilter = this.audioContext.createBiquadFilter();
            
            // Connect bass chain
            bassOsc.connect(bassFilter);
            bassFilter.connect(bassGain);
            bassGain.connect(this.audioContext.destination);
            
            // Use different waveforms for rich bass texture
            const waveforms = ['sawtooth', 'square', 'triangle'];
            bassOsc.type = waveforms[index];
            bassOsc.frequency.setValueAtTime(freq, currentTime);
            
            // Add subtle bass frequency modulation for warmth, then extended dramatic drop
            bassOsc.frequency.exponentialRampToValueAtTime(freq * 1.05, currentTime + 1.0);
            bassOsc.frequency.exponentialRampToValueAtTime(freq * 0.95, currentTime + 1.5);
            // Begin the dramatic frequency drop midway through the sound
            bassOsc.frequency.linearRampToValueAtTime(freq * 0.8, currentTime + 2.0); // Start dropping at midpoint
            bassOsc.frequency.linearRampToValueAtTime(freq * 0.6, currentTime + 2.8); // Continue drop
            bassOsc.frequency.linearRampToValueAtTime(freq * 0.4, currentTime + 3.2); // Final drop to 40% of original
            
            // Configure bass filter for punch and clarity
            bassFilter.type = 'lowpass';
            bassFilter.frequency.setValueAtTime(200 + (index * 100), currentTime);
            bassFilter.frequency.exponentialRampToValueAtTime(300 + (index * 150), currentTime + 0.5);
            bassFilter.frequency.exponentialRampToValueAtTime(150 + (index * 75), currentTime + 2.5);
            bassFilter.Q.setValueAtTime(2, currentTime);
            
            // Bass envelope - punchy attack, sustained body
            const bassDelay = index * 0.05; // Slight stagger for thickness
            const bassVolume = index === 0 ? 0.15 : 0.08; // Sub-bass louder
            
            bassGain.gain.setValueAtTime(0, currentTime + bassDelay);
            bassGain.gain.linearRampToValueAtTime(bassVolume, currentTime + bassDelay + 0.1); // Quick attack
            bassGain.gain.exponentialRampToValueAtTime(bassVolume * 0.8, currentTime + bassDelay + 0.8);
            bassGain.gain.linearRampToValueAtTime(bassVolume * 0.4, currentTime + bassDelay + 2.2);
            bassGain.gain.exponentialRampToValueAtTime(0.001, currentTime + bassDelay + 3.2);
            
            bassOsc.start(currentTime + bassDelay);
            bassOsc.stop(currentTime + bassDelay + 3.2);
        });
        
        // Add sub-bass rumble for extra depth
        const subBassOsc = this.audioContext.createOscillator();
        const subBassGain = this.audioContext.createGain();
        const subBassFilter = this.audioContext.createBiquadFilter();
        
        subBassOsc.connect(subBassFilter);
        subBassFilter.connect(subBassGain);
        subBassGain.connect(this.audioContext.destination);
        
        // Very low frequency for felt impact with dramatic glissando drop
        subBassOsc.type = 'sine';
        subBassOsc.frequency.setValueAtTime(baseFreq / 4, currentTime); // C2 (32.7 Hz) - more audible start
        subBassOsc.frequency.exponentialRampToValueAtTime(baseFreq / 3, currentTime + 1.5); // Up to ~43 Hz
        subBassOsc.frequency.linearRampToValueAtTime(baseFreq / 4, currentTime + 2.0); // Back to 32.7 Hz
        // Dramatic glissando drop - much more audible range
        subBassOsc.frequency.linearRampToValueAtTime(baseFreq / 8, currentTime + 2.5); // Drop to 16 Hz
        subBassOsc.frequency.linearRampToValueAtTime(baseFreq / 12, currentTime + 3.2); // Slide to ~11 Hz
        subBassOsc.frequency.linearRampToValueAtTime(baseFreq / 16, currentTime + 3.5); // Final drop to ~8 Hz
        
        // Sub-bass filter for controlled rumble
        subBassFilter.type = 'lowpass';
        subBassFilter.frequency.setValueAtTime(60, currentTime);
        subBassFilter.frequency.exponentialRampToValueAtTime(80, currentTime + 1.0);
        subBassFilter.frequency.exponentialRampToValueAtTime(40, currentTime + 2.5);
        subBassFilter.Q.setValueAtTime(1.5, currentTime);
        
        // Sub-bass envelope - dramatic presence with swooping finale
        subBassGain.gain.setValueAtTime(0, currentTime);
        subBassGain.gain.linearRampToValueAtTime(0.18, currentTime + 0.3); // Stronger attack
        subBassGain.gain.exponentialRampToValueAtTime(0.12, currentTime + 1.5); // Maintain strong presence
        subBassGain.gain.linearRampToValueAtTime(0.10, currentTime + 2.0); // Keep audible for drop
        subBassGain.gain.linearRampToValueAtTime(0.15, currentTime + 2.5); // Boost during the drop
        subBassGain.gain.exponentialRampToValueAtTime(0.001, currentTime + 3.5); // Final fade
        
        subBassOsc.start(currentTime);
        subBassOsc.stop(currentTime + 3.5);
        
        // Add magical shimmer with high-frequency sparkles
        for (let i = 0; i < 5; i++) {
            const shimmerOsc = this.audioContext.createOscillator();
            const shimmerGain = this.audioContext.createGain();
            const shimmerFilter = this.audioContext.createBiquadFilter();
            
            shimmerOsc.connect(shimmerFilter);
            shimmerFilter.connect(shimmerGain);
            shimmerGain.connect(this.audioContext.destination);
            
            // Lower frequencies for sparkle effect
            const shimmerFreq = 800 + Math.random() * 1200;
            shimmerOsc.type = 'sine';
            shimmerOsc.frequency.setValueAtTime(shimmerFreq, currentTime);
            shimmerOsc.frequency.exponentialRampToValueAtTime(shimmerFreq * 2, currentTime + 0.3);
            
            shimmerFilter.type = 'highpass';
            shimmerFilter.frequency.setValueAtTime(1500, currentTime);
            shimmerFilter.Q.setValueAtTime(10, currentTime);
            
            const shimmerDelay = i * 0.4;
            shimmerGain.gain.setValueAtTime(0, currentTime + shimmerDelay);
            shimmerGain.gain.linearRampToValueAtTime(0.03, currentTime + shimmerDelay + 0.05);
            shimmerGain.gain.exponentialRampToValueAtTime(0.001, currentTime + shimmerDelay + 0.3);
            
            shimmerOsc.start(currentTime + shimmerDelay);
            shimmerOsc.stop(currentTime + shimmerDelay + 0.3);
        }
        
        // Add subtle reverb effect with delay
        const delayNode = this.audioContext.createDelay(0.3);
        const delayGain = this.audioContext.createGain();
        const delayFilter = this.audioContext.createBiquadFilter();
        
        // Create a simple reverb feedback loop
        delayNode.delayTime.setValueAtTime(0.15, currentTime);
        delayGain.gain.setValueAtTime(0.2, currentTime);
        delayFilter.type = 'lowpass';
        delayFilter.frequency.setValueAtTime(8000, currentTime);
        
        // Connect delay chain
        delayNode.connect(delayFilter);
        delayFilter.connect(delayGain);
        delayGain.connect(delayNode); // Feedback
        delayGain.connect(this.audioContext.destination);
        
        // Connect some oscillators to the delay for reverb effect
        if (gainNodes.length > 0) {
            gainNodes[0].connect(delayNode);
            if (gainNodes.length > 2) {
                gainNodes[2].connect(delayNode);
            }
        }
        
        // Also connect the sub-bass to reverb for extra depth
        subBassGain.connect(delayNode);
        
        console.log(' Failsafe sound: Magic activated with epic bass! ');
    }

    // === POMODORO TICK SOUNDS ===

    /**
     * Soft tick sound - gentle but crisp digital-style click
     */
    playSoftTick(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        // Triangle wave like digital but lower pitch for softness
        oscillator.type = 'triangle';
        oscillator.frequency.setValueAtTime(1800, currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(900, currentTime + 0.005);
        
        // Band-pass filter like digital but lower Q for gentleness
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(1200, currentTime);
        filter.Q.setValueAtTime(4, currentTime);
        
        // Sharp but softer envelope like digital
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.035, currentTime + 0.0005);
        gainNode.gain.exponentialRampToValueAtTime(0.001, currentTime + 0.02);
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.start(currentTime);
        oscillator.stop(currentTime + 0.02);
    }

    /**
     * Classic tick sound - crisp digital-style click with classic feel
     */
    playClassicTick(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        // Triangle wave like digital but slightly higher pitch for classic feel
        oscillator.type = 'triangle';
        oscillator.frequency.setValueAtTime(2000, currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(1000, currentTime + 0.005);
        
        // Band-pass filter like digital but mid-range for classic sound
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(1350, currentTime);
        filter.Q.setValueAtTime(5, currentTime);
        
        // Sharp digital-style envelope with slightly more volume
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.045, currentTime + 0.0005);
        gainNode.gain.exponentialRampToValueAtTime(0.001, currentTime + 0.02);
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.start(currentTime);
        oscillator.stop(currentTime + 0.02);
    }

    /**
     * Digital tick sound - crisp electronic click
     */
    playDigitalTick(currentTime) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        // Triangle wave for cleaner digital sound
        oscillator.type = 'triangle';
        oscillator.frequency.setValueAtTime(2200, currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(1100, currentTime + 0.005);
        
        // Band-pass filter for focused click
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(1500, currentTime);
        filter.Q.setValueAtTime(6, currentTime);
        
        // Ultra-sharp digital click envelope
        gainNode.gain.setValueAtTime(0, currentTime);
        gainNode.gain.linearRampToValueAtTime(0.05, currentTime + 0.0005);
        gainNode.gain.exponentialRampToValueAtTime(0.001, currentTime + 0.02);
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.start(currentTime);
        oscillator.stop(currentTime + 0.02);
    }

    /**
     * Test a specific sound type
     * @param {string} soundType - Sound type to test
     * @param {boolean} muted - Whether sound is muted
     */
    testSound(soundType, muted = false) {
        this.playSound(soundType, muted);
    }
}

// Export for use in other modules
if (typeof window !== 'undefined') {
    window.SoundManager = SoundManager;
}

console.log('Sound Manager module loaded');


// === pauseManager.js ===
/**
 * Pause Manager for Activity Tracker
 * Handles pause countdown, visual draining effect, and pause state management
 */

class PauseManager {
    constructor(activityTracker) {
        this.tracker = activityTracker;
        this.countdownInterval = null;
        this.pauseButton = null;
        this.originalButtonText = 'Pause Reminders';
        this.init();
    }

    /**
     * Initialize the pause manager
     */
    init() {
        this.pauseButton = document.getElementById('pauseButton');
        if (this.pauseButton) {
            this.updatePauseButtonDisplay();
            this.setupPauseButtonHandlers();
        }
    }
    
    /**
     * Setup pause button event handlers for right-click pause menu
     */
    setupPauseButtonHandlers() {
        // Add right-click context menu for pause durations
        this.pauseButton.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            this.showPauseMenu(e);
        });
        
        // Add long-press support for mobile
        let pressTimer;
        this.pauseButton.addEventListener('touchstart', (e) => {
            pressTimer = setTimeout(() => {
                e.preventDefault();
                this.showPauseMenu(e);
            }, 500);
        });
        
        this.pauseButton.addEventListener('touchend', () => {
            clearTimeout(pressTimer);
        });
    }
    
    /**
     * Show pause duration menu
     */
    showPauseMenu(event) {
        // If already paused, just resume
        if (this.isPaused()) {
            this.resume();
            return;
        }
        
        // Create context menu
        const menu = document.createElement('div');
        menu.className = 'pause-context-menu';
        menu.style.cssText = `
            position: fixed;
            z-index: 10000;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 8px 0;
            min-width: 150px;
            font-size: 14px;
        `;
        
        const options = [
            { label: '5 minutes', duration: 5 },
            { label: '15 minutes', duration: 15 },
            { label: '30 minutes', duration: 30 },
            { label: '1 hour', duration: 60 },
            { label: '2 hours', duration: 120 },
            { label: 'Until manually resumed', duration: -1 }
        ];
        
        options.forEach(option => {
            const menuItem = document.createElement('div');
            menuItem.className = 'pause-context-menu-item';
            menuItem.textContent = option.label;
            
            menuItem.addEventListener('click', () => {
                this.startPause(option.duration);
                menu.remove();
            });
            
            menu.appendChild(menuItem);
        });
        
        // Position menu
        const rect = this.pauseButton.getBoundingClientRect();
        menu.style.left = `${rect.left}px`;
        menu.style.top = `${rect.bottom + 5}px`;
        
        // Add to page
        document.body.appendChild(menu);
        
        // Remove menu when clicking elsewhere
        const removeMenu = (e) => {
            if (!menu.contains(e.target)) {
                menu.remove();
                document.removeEventListener('click', removeMenu);
            }
        };
        
        setTimeout(() => {
            document.addEventListener('click', removeMenu);
        }, 0);
    }

    /**
     * Start pause with countdown
     * @param {number} durationMinutes - Duration in minutes (-1 for forever)
     */
    startPause(durationMinutes) {
        // Clear any existing countdown
        this.stopCountdown();

        if (durationMinutes === -1) {
            // Forever pause
            this.tracker.settings.notificationsPausedUntil = Infinity;
            this.updatePauseButtonForever();
            showNotification('Reminders paused indefinitely', 'info');
        } else {
            // Timed pause
            this.tracker.settings.notificationsPausedUntil = new Date().getTime() + durationMinutes * 60 * 1000;
            this.startCountdown();
            const unit = durationMinutes === 1 ? 'minute' : 'minutes';
            showNotification(`Reminders paused for ${durationMinutes} ${unit}`, 'info');
        }

        this.tracker.saveSettings();
    }

    /**
     * Resume notifications
     */
    resume() {
        this.stopCountdown();
        this.tracker.settings.notificationsPausedUntil = null;
        this.updatePauseButtonNormal();
        this.tracker.saveSettings();
        showNotification('Reminders resumed', 'success');
    }

    /**
     * Start the countdown timer
     */
    startCountdown() {
        if (this.countdownInterval) {
            clearInterval(this.countdownInterval);
        }

        // Update immediately
        this.updateCountdownDisplay();

        // Update every second
        this.countdownInterval = setInterval(() => {
            this.updateCountdownDisplay();
        }, 1000);
    }

    /**
     * Stop the countdown timer
     */
    stopCountdown() {
        if (this.countdownInterval) {
            clearInterval(this.countdownInterval);
            this.countdownInterval = null;
        }
    }

    /**
     * Update the countdown display and draining effect
     */
    updateCountdownDisplay() {
        if (!this.pauseButton || !this.tracker.settings.notificationsPausedUntil) {
            this.updatePauseButtonNormal();
            return;
        }

        const now = new Date().getTime();
        const pausedUntil = this.tracker.settings.notificationsPausedUntil;

        if (pausedUntil === Infinity) {
            this.updatePauseButtonForever();
            return;
        }

        const timeRemaining = pausedUntil - now;

        if (timeRemaining <= 0) {
            // Time's up, auto-resume
            this.resume();
            showNotification('Notifications automatically resumed', 'success');
            return;
        }

        // Calculate time components
        const totalSeconds = Math.floor(timeRemaining / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        // Format countdown text
        let countdownText;
        if (hours > 0) {
            countdownText = `${hours}h ${minutes}m ${seconds}s`;
        } else if (minutes > 0) {
            countdownText = `${minutes}m ${seconds}s`;
        } else {
            countdownText = `${seconds}s`;
        }

        // Update button text
        this.pauseButton.textContent = `Resume (${countdownText})`;
        this.pauseButton.title = 'Click to resume reminders now. Right-click for pause duration options.';

        // Calculate drain percentage (how much time has passed)
        const totalDuration = this.tracker.settings.pauseDuration * 60 * 1000;
        const timeElapsed = totalDuration - timeRemaining;
        const drainPercentage = Math.max(0, Math.min(100, (timeElapsed / totalDuration) * 100));

        // Apply draining visual effect
        this.applyDrainingEffect(drainPercentage);
    }

    /**
     * Apply visual draining effect to button
     * @param {number} percentage - Percentage drained (0-100)
     */
    applyDrainingEffect(percentage) {
        // Create a gradient that "drains" from right to left (starts full on right, drains to left)
        const drained = `rgba(229, 62, 62, 0.3)`; // Light red for drained area
        const full = `#e53e3e`; // Full red for remaining area

        // Calculate where the drain line should be (percentage is how much has been consumed)
        // We want to start full from the right and drain to the left
        this.pauseButton.style.background = `linear-gradient(to left, ${drained} 0%, ${drained} ${percentage}%, ${full} ${percentage}%, ${full} 100%)`;
        this.pauseButton.style.transition = 'background 1s ease-out';
        
        // Add a subtle pulse effect when nearly drained
        if (percentage > 90) {
            this.pauseButton.style.animation = 'pulse 1s infinite';
        } else {
            this.pauseButton.style.animation = 'none';
        }
    }

    /**
     * Update button for forever pause
     */
    updatePauseButtonForever() {
        this.pauseButton.textContent = 'Resume (Paused Forever)';
        this.pauseButton.title = 'Click to resume reminders. Right-click for pause duration options.';
        this.pauseButton.style.background = '#e53e3e';
        this.pauseButton.style.animation = 'none';
        this.pauseButton.style.transition = '';
    }

    /**
     * Check if current time is within activity schedule
     */
    isWithinWorkingSchedule() {
        const now = new Date();
        const currentTime = now.getHours() * 60 + now.getMinutes();
        const dayName = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'][now.getDay()];

        // Check if it's a working day
        if (!this.tracker.settings.workingDays[dayName]) {
            return false;
        }

        // Use the tracker's method for checking activity hours (supports complex schedules)
        return this.tracker.isWithinWorkingHours(now);
    }

    /**
     * Update button for normal (not paused) state
     */
    updatePauseButtonNormal() {
        const isWithinSchedule = this.isWithinWorkingSchedule();
        
        if (this.tracker.settings.notificationsEnabled) {
            if (isWithinSchedule) {
                // Notifications are on and within schedule - show pause button
                this.pauseButton.textContent = 'Pause Reminders';
                this.pauseButton.title = 'Click to pause reminders. Right-click for pause duration options.';
                this.pauseButton.disabled = false;
                this.pauseButton.style.background = '';
                this.pauseButton.style.opacity = '';
                this.pauseButton.style.cursor = '';
            } else {
                // Notifications are on but outside activity hours
                this.pauseButton.textContent = 'Outside activity hours';
                this.pauseButton.title = 'Click to learn about activity hours settings. Reminders are only available during your configured activity schedule.';
                this.pauseButton.disabled = false; // Keep enabled so events fire
                this.pauseButton.style.background = '#9ca3af';
                this.pauseButton.style.opacity = '0.6';
                this.pauseButton.style.cursor = 'not-allowed';
            }
        } else {
            // Notifications are completely disabled
            this.pauseButton.textContent = 'All reminders disabled';
            this.pauseButton.title = 'Activity reminders are turned off. Click "Turn on activity reminders" in the notification status to enable.';
            this.pauseButton.disabled = false; // Keep enabled so events fire
            this.pauseButton.style.background = '#9ca3af';
            this.pauseButton.style.opacity = '0.6';
            this.pauseButton.style.cursor = 'not-allowed';
        }
        
        this.pauseButton.style.animation = 'none';
        this.pauseButton.style.transition = '';
    }

    /**
     * Update the pause button display based on current state
     */
    updatePauseButtonDisplay() {
        if (!this.pauseButton) return;

        // Hide button when pomodoro mode is active (modes are mutually exclusive)
        if (this.tracker.pomodoroManager && this.tracker.pomodoroManager.isActive) {
            this.pauseButton.style.display = 'none';
            return;
        } else {
            this.pauseButton.style.display = '';
        }

        if (this.tracker.settings.notificationsPausedUntil) {
            if (this.tracker.settings.notificationsPausedUntil === Infinity) {
                this.updatePauseButtonForever();
            } else {
                this.startCountdown();
            }
        } else {
            this.updatePauseButtonNormal();
        }
    }

    /**
     * Check if notifications are currently paused
     * @returns {boolean} True if paused
     */
    isPaused() {
        if (!this.tracker.settings.notificationsPausedUntil) {
            return false;
        }

        if (this.tracker.settings.notificationsPausedUntil === Infinity) {
            return true;
        }

        const now = new Date().getTime();
        return now < this.tracker.settings.notificationsPausedUntil;
    }

    /**
     * Get remaining pause time in milliseconds
     * @returns {number} Remaining time in ms, or -1 for forever, or 0 if not paused
     */
    getRemainingTime() {
        if (!this.tracker.settings.notificationsPausedUntil) {
            return 0;
        }

        if (this.tracker.settings.notificationsPausedUntil === Infinity) {
            return -1;
        }

        const now = new Date().getTime();
        const remaining = this.tracker.settings.notificationsPausedUntil - now;
        return Math.max(0, remaining);
    }

    /**
     * Cleanup when destroying the pause manager
     */
    destroy() {
        this.stopCountdown();
    }
}

// Export for use in other modules
if (typeof window !== 'undefined') {
    window.PauseManager = PauseManager;
}

console.log('Pause Manager module loaded');


// === pomodoroManager.js ===
/**
 * Pomodoro Timer Manager
 * Handles structured work/break cycles with notifications and activity logging
 */

class PomodoroManager {
    constructor(activityTracker) {
        this.activityTracker = activityTracker;
        this.isActive = false;
        this.isRunning = false;
        this.isPaused = false;
        this.pausedAt = null;
        this.currentPhase = 'work'; // 'work' or 'break'
        this.cycleCount = 0; // Number of completed work sessions
        this.totalSessions = 0; // Total completed work sessions across all Pomodoro mode activations
        this.timer = null;
        this.tickTimer = null;
        this.remainingTime = 0;
        this.startTime = null;
        this.originalDuration = 0;
        
        // Settings (will be loaded from activity tracker settings)
        this.settings = {
            enabled: false,
            workDuration: 25, // minutes
            breakDuration: 5, // minutes
            longBreakDuration: 15, // minutes
            longBreakInterval: 4, // sessions before long break
            tickSound: 'none', // 'none', 'soft', 'classic', 'digital'
            tickInterval: 0, // seconds between ticks (0 = off)
            shortBreakSound: 'gentle',
            longBreakSound: 'bell',
            resumeSound: 'digital',
            autoStart: false,
            autoLog: true,
            logBreaks: false,
            longBreak: true,
            pauseAllowed: true,
            autoResetDaily: false
        };
        
        this.statusUpdateInterval = null;
        this.lastResetDate = null; // Track last reset date for daily auto-reset
        
        this.init();
    }
    
    init() {
        // Set up Pomodoro mode toggle
        const pomodoroEnabled = document.getElementById('pomodoroEnabled');
        if (pomodoroEnabled) {
            pomodoroEnabled.addEventListener('change', () => {
                this.togglePomodoroMode(pomodoroEnabled.checked);
            });
        }
        
        // Set up auto-save for all Pomodoro settings
        this.setupAutoSaveListeners();
        
        // Pomodoro control is now handled by the main navigation button
        
        // Load settings from activity tracker
        this.loadSettings();
        
        console.log('Pomodoro Manager initialized with comprehensive features');
    }
    
    /**
     * Setup auto-save listeners for all Pomodoro settings
     */
    setupAutoSaveListeners() {
        const settingsIds = [
            'pomodoroWorkDuration',
            'pomodoroBreakDuration', 
            'pomodoroLongBreakDuration',
            'pomodoroLongBreakInterval',
            'pomodoroTickSound',
            'pomodoroTickInterval',
            'pomodoroShortBreakSound',
            'pomodoroLongBreakSound',
            'pomodoroResumeSound',
            'pomodoroAutoStart',
            'pomodoroAutoLog',
            'pomodoroLogBreaks',
            'pomodoroLongBreak',
            'pomodoroAutoResetDaily',
            'pomodoroLastResetDate'
        ];
        
        settingsIds.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                const eventType = element.type === 'checkbox' ? 'change' : 'change';
                element.addEventListener(eventType, () => {
                    console.log(`Auto-saving Pomodoro setting: ${id}`);
                    this.saveSettings();
                    this.loadSettings(); // Refresh settings immediately
                });
            }
        });
        
        console.log('Auto-save listeners setup for Pomodoro settings');
    }
    
    loadSettings() {
        if (this.activityTracker && this.activityTracker.settings) {
            const settings = this.activityTracker.settings;
            this.settings = {
                enabled: settings.pomodoroEnabled || false,
                workDuration: parseInt(settings.pomodoroWorkDuration) || 25,
                breakDuration: parseInt(settings.pomodoroBreakDuration) || 5,
                longBreakDuration: parseInt(settings.pomodoroLongBreakDuration) || 15,
                longBreakInterval: parseInt(settings.pomodoroLongBreakInterval) || 4,
                tickSound: settings.pomodoroTickSound || 'none',
                tickInterval: parseInt(settings.pomodoroTickInterval) || 0,
                shortBreakSound: settings.pomodoroShortBreakSound || 'gentle',
                longBreakSound: settings.pomodoroLongBreakSound || 'bell',
                resumeSound: settings.pomodoroResumeSound || 'digital',
                autoStart: settings.pomodoroAutoStart || false,
                autoLog: settings.pomodoroAutoLog !== false,
                logBreaks: settings.pomodoroLogBreaks || false,
                longBreak: settings.pomodoroLongBreak !== false,
                pauseAllowed: settings.pomodoroPauseAllowed !== false,
                autoResetDaily: settings.pomodoroAutoResetDaily !== false
            };
            
            // Note: Session state restoration is now handled by the new state system
            
            // Update UI
            this.updateUI();
        }
    }
    
    updateUI() {
        const pomodoroEnabled = document.getElementById('pomodoroEnabled');
        const pomodoroConfig = document.getElementById('pomodoroConfig');
        const workDuration = document.getElementById('pomodoroWorkDuration');
        const breakDuration = document.getElementById('pomodoroBreakDuration');
        const longBreakDuration = document.getElementById('pomodoroLongBreakDuration');
        const longBreakInterval = document.getElementById('pomodoroLongBreakInterval');
        const tickSound = document.getElementById('pomodoroTickSound');
        const tickInterval = document.getElementById('pomodoroTickInterval');
        const shortBreakSound = document.getElementById('pomodoroShortBreakSound');
        const longBreakSound = document.getElementById('pomodoroLongBreakSound');
        const resumeSound = document.getElementById('pomodoroResumeSound');
        const autoStart = document.getElementById('pomodoroAutoStart');
        const autoLog = document.getElementById('pomodoroAutoLog');
        const logBreaks = document.getElementById('pomodoroLogBreaks');
        const longBreak = document.getElementById('pomodoroLongBreak');
        const autoResetDaily = document.getElementById('pomodoroAutoResetDaily');
        const statusDisplay = document.getElementById('pomodoroStatus');
        
        if (pomodoroEnabled) {
            pomodoroEnabled.checked = this.settings.enabled;
        }
        
        if (pomodoroConfig) {
            pomodoroConfig.style.display = this.settings.enabled ? 'block' : 'none';
        }
        
        if (workDuration) {
            workDuration.value = this.settings.workDuration.toString();
        }
        
        if (breakDuration) {
            breakDuration.value = this.settings.breakDuration.toString();
        }
        
        if (longBreakDuration) {
            longBreakDuration.value = this.settings.longBreakDuration.toString();
        }
        
        if (longBreakInterval) {
            longBreakInterval.value = this.settings.longBreakInterval.toString();
        }
        
        if (tickSound) {
            tickSound.value = this.settings.tickSound;
        }
        
        if (tickInterval) {
            tickInterval.value = this.settings.tickInterval.toString();
        }
        
        if (shortBreakSound) {
            shortBreakSound.value = this.settings.shortBreakSound;
        }
        
        if (longBreakSound) {
            longBreakSound.value = this.settings.longBreakSound;
        }
        
        if (resumeSound) {
            resumeSound.value = this.settings.resumeSound;
        }
        
        if (autoStart) {
            autoStart.checked = this.settings.autoStart;
        }
        
        if (autoLog) {
            autoLog.checked = this.settings.autoLog;
        }
        
        if (logBreaks) {
            logBreaks.checked = this.settings.logBreaks;
        }
        
        if (longBreak) {
            longBreak.checked = this.settings.longBreak;
        }
        
        if (autoResetDaily) {
            autoResetDaily.checked = this.settings.autoResetDaily;
        }
        
        // Update main Pomodoro button in nav
        this.updatePomodoroButton();
        
        if (statusDisplay) {
            this.updateStatusDisplay();
        }
    }
    
    togglePomodoroMode(enabled) {
        this.settings.enabled = enabled;
        this.isActive = enabled;
        
        const pomodoroConfig = document.getElementById('pomodoroConfig');
        if (pomodoroConfig) {
            pomodoroConfig.style.display = enabled ? 'block' : 'none';
        }
        
        // Update button visibility immediately
        this.updatePomodoroButton();
        
        // Update pause button visibility (hide when pomodoro active)
        if (this.activityTracker && this.activityTracker.pauseManager) {
            this.activityTracker.pauseManager.updatePauseButtonDisplay();
        }
        
        if (enabled) {
            this.startPomodoroMode();
        } else {
            this.stopPomodoroMode();
        }
        
        // Save settings
        if (this.activityTracker) {
            this.activityTracker.settings.pomodoroEnabled = enabled;
            this.activityTracker.saveSettings();
        }
        
        console.log(`Pomodoro mode ${enabled ? 'enabled' : 'disabled'}`);
    }
    
    startPomodoroMode() {
        if (!this.isActive) return;
        
        // Reset state but don't start immediately
        this.currentPhase = 'work';
        this.cycleCount = 0;
        this.totalSessions = 0;
        this.isRunning = false;
        this.isPaused = false;
        this.pausedAt = null;
        this.currentWorkActivity = null;
        
        // Save the reset state
        this.updateState();
        
        // Update display to show ready state
        this.updateStatusDisplay();
        
        showNotification('Pomodoro mode enabled! Click the button to start your first session.', 'success');
    }
    
    stopPomodoroMode() {
        this.isActive = false;
        this.isRunning = false;
        
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        
        this.stopTickSounds();
        this.stopStatusUpdates();
        
        if (this.settings.autoLog && this.currentPhase === 'work') {
            this.logActivity('Pomodoro session ended', 'Work session interrupted');
        }
        
        // Clear session state from storage
        if (this.activityTracker && this.activityTracker.settings) {
            this.activityTracker.settings.pomodoroIsActive = false;
            this.activityTracker.settings.pomodoroIsRunning = false;
            this.activityTracker.settings.pomodoroCurrentPhase = null;
            this.activityTracker.settings.pomodoroStartTime = null;
            this.activityTracker.settings.pomodoroRemainingTime = null;
            this.activityTracker.settings.pomodoroOriginalDuration = null;
            this.activityTracker.settings.pomodoroIsPaused = false;
            this.activityTracker.settings.pomodoroPausedAt = null;
            this.activityTracker.settings.pomodoroCurrentWorkActivity = null;
            this.activityTracker.saveSettings();
        }
        
        this.updateUI();
        showNotification('Pomodoro mode stopped.', 'info');
    }
    
    startWorkPeriod() {
        if (!this.isActive) return;
        
        // Always show modal for work session activity if auto-log is enabled
        if (this.settings.autoLog) {
            this.pendingWorkSession = true;
            this.showWorkActivityModal();
            return;
        }
        
        this.actuallyStartWorkPeriod();
    }
    
    actuallyStartWorkPeriod() {
        if (!this.isActive) return;
        
        // Prevent multiple instances - stop any existing timers first
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        this.stopTickSounds();
        this.stopStatusUpdates();
        
        this.currentPhase = 'work';
        this.isRunning = true;
        this.isPaused = false;
        this.pausedAt = null;
        this.remainingTime = this.settings.workDuration * 60 * 1000;
        this.originalDuration = this.remainingTime; // Convert to milliseconds
        this.startTime = Date.now();
        
        this.timer = setTimeout(() => {
            this.endWorkPeriod();
        }, this.remainingTime);
        
        // Start tick sounds if enabled
        this.startTickSounds();
        
        // Start status updates
        this.startStatusUpdates();
        
        // Save session state
        this.updateState();
        
        // Update UI
        this.updateUI();
        
        console.log(`Starting ${this.settings.workDuration} minute work period (Session ${this.getCurrentSessionNumber()})`);
    }
    
    endWorkPeriod() {
        if (!this.isActive) return;
        
        this.cycleCount++;
        this.totalSessions++;
        this.isRunning = false;
        
        // Stop tick sounds
        this.stopTickSounds();
        
        // Save session progress
        this.updateState();
        
        // Log work activity with custom description if available
        if (this.settings.autoLog) {
            if (this.currentWorkActivity) {
                this.logActivity(
                    this.currentWorkActivity.name,
                    this.currentWorkActivity.description || `Completed ${this.settings.workDuration} minute Pomodoro work session`
                );
            } else {
                this.logActivity(
                    `Pomodoro work period #${this.cycleCount} completed`,
                    `Completed ${this.settings.workDuration} minute focused work session`
                );
            }
        }
        
        // Play notification sound
        if (this.activityTracker) {
            this.activityTracker.playNotificationSound();
        }
        
        // Show notification with action
        this.showWorkCompleteNotification();
        
        // Update UI
        this.updateUI();
        
        // Start break period
        setTimeout(() => {
            this.startBreakPeriod();
        }, 1000);
    }
    
    startBreakPeriod() {
        if (!this.isActive) return;
        
        // Prevent multiple instances - stop any existing timers first
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        this.stopTickSounds(); // Should already be stopped for breaks, but be safe
        this.stopStatusUpdates();
        
        this.currentPhase = 'break';
        this.isRunning = true;
        this.isPaused = false;
        this.pausedAt = null;
        
        // Determine break duration (long break based on configurable interval)
        // Only give long break after completing the specified number of sessions (not at start)
        const isLongBreak = this.settings.longBreak && this.cycleCount > 0 && (this.cycleCount % this.settings.longBreakInterval === 0);
        const breakDuration = isLongBreak ? this.settings.longBreakDuration : this.settings.breakDuration;
        
        this.remainingTime = breakDuration * 60 * 1000;
        this.originalDuration = this.remainingTime;
        this.startTime = Date.now();
        
        this.timer = setTimeout(() => {
            this.endBreakPeriod();
        }, this.remainingTime);
        
        // Start status updates
        this.startStatusUpdates();
        
        // Save session state
        this.updateState();
        
        // Update UI
        this.updateUI();
        
        const breakType = isLongBreak ? 'long break' : 'break';
        console.log(`Starting ${breakDuration} minute ${breakType} (after ${this.cycleCount} sessions)`);
        
        // Play appropriate announce sound
        const announceSound = isLongBreak ? this.settings.longBreakSound : this.settings.shortBreakSound;
        if (this.activityTracker && this.activityTracker.soundManager) {
            const isMuted = this.activityTracker.isPomodoroSoundMuted();
            this.activityTracker.soundManager.playSound(announceSound, isMuted);
        }
        
        // Show break notification
        this.showBreakStartNotification(breakType, breakDuration);
    }
    
    endBreakPeriod() {
        if (!this.isActive) return;
        
        this.isRunning = false;
        
        // Save session progress
        this.updateState();
        
        // Log break activity (only if logBreaks is enabled)
        if (this.settings.logBreaks) {
            const isLongBreak = this.settings.longBreak && this.cycleCount > 0 && (this.cycleCount % this.settings.longBreakInterval === 0);
            this.logActivity(
                `Pomodoro ${isLongBreak ? 'Long Break' : 'Short Break'}`,
                `Completed`,
                [this.generateBreakTag(isLongBreak)]
            );
        }
        
        // Play notification sound
        if (this.activityTracker) {
            this.activityTracker.playNotificationSound();
        }
        
        // Play resume work announce sound
        if (this.activityTracker && this.activityTracker.soundManager) {
            const isMuted = this.activityTracker.isPomodoroSoundMuted();
            this.activityTracker.soundManager.playSound(this.settings.resumeSound, isMuted);
        }
        
        // Show back-to-work notification
        this.showBackToWorkNotification();
        
        // Update UI
        this.updateUI();
        
        // Start next work period (or wait for manual start if auto-start is disabled)
        if (this.settings.autoStart) {
            setTimeout(() => {
                this.startWorkPeriod();
            }, 1000);
        } else {
            // User must manually start next session
            showNotification('Break finished! Click the Pomodoro button to continue.', 'info', 10000);
        }
    }
    
    showWorkCompleteNotification() {
        const options = {
            body: `Work period #${this.cycleCount} complete! Time for a break.`,
            icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23f56565"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>',
            tag: 'pomodoro-work-complete',
            requireInteraction: true,
            actions: [
                { action: 'start-break', title: 'Start Break', icon: '' },
                { action: 'continue-work', title: 'Continue Working', icon: '' }
            ]
        };
        
        if (this.activityTracker) {
            this.activityTracker.showNotificationWithServiceWorker('Pomodoro - Work Complete!', options);
        }
    }
    
    showBreakStartNotification(breakType, duration) {
        const options = {
            body: `Take a ${breakType} for ${duration} minutes. You've earned it!`,
            icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%2348bb78"><path d="M7 14c-1.66 0-3 1.34-3 3 0 1.31-1.16 2-2 2 .92 1.22 2.49 2 4 2 2.21 0 4-1.79 4-4 0-1.66-1.34-3-3-3zM20.71 4.63l-1.34-1.34c-.39-.39-1.02-.39-1.41 0L9 12.25 11.75 15l8.96-8.96c.39-.39.39-1.02 0-1.41z"/></svg>',
            tag: 'pomodoro-break-start',
            requireInteraction: false
        };
        
        if (this.activityTracker) {
            this.activityTracker.showNotificationWithServiceWorker(`${breakType.charAt(0).toUpperCase() + breakType.slice(1)} Time!`, options);
        }
    }
    
    showBackToWorkNotification() {
        const options = {
            body: 'Break time is over. Ready to get back to focused work?',
            icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23667eea"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>',
            tag: 'pomodoro-back-to-work',
            requireInteraction: true,
            actions: [
                { action: 'reply', type: 'text', title: 'Log Work Activity', placeholder: 'What will you work on next?' }
            ]
        };
        
        if (this.activityTracker) {
            this.activityTracker.showNotificationWithServiceWorker('Back to Work!', options);
        }
    }
    
    /**
     * Generate a simple hash for duplicate detection
     */
    generateActivityHash(activity, description, timestamp) {
        // Round timestamp to minute accuracy for duplicate detection
        const date = new Date(timestamp);
        const minuteAccurateTime = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 
                                          date.getHours(), date.getMinutes()).toISOString();
        
        const hashString = `${activity}|${description || ''}|${minuteAccurateTime}`;
        
        // Simple hash function
        let hash = 0;
        for (let i = 0; i < hashString.length; i++) {
            const char = hashString.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return hash.toString();
    }

    /**
     * Check if an activity entry already exists (duplicate detection)
     */
    isDuplicateActivity(activity, description, timestamp) {
        if (!this.activityTracker || !this.activityTracker.entries) return false;
        
        const hash = this.generateActivityHash(activity, description, timestamp);
        
        // Check recent entries (last 10) for performance
        const recentEntries = this.activityTracker.entries.slice(0, 10);
        
        return recentEntries.some(entry => {
            if (entry.source !== 'pomodoro') return false;
            
            const entryHash = this.generateActivityHash(
                entry.activity, 
                entry.description || '', 
                entry.timestamp
            );
            
            return entryHash === hash;
        });
    }

    logActivity(activity, description, extraTags = []) {
        if (!this.activityTracker || !this.settings.autoLog) return;
        
        const timestamp = new Date().toISOString();
        
        // Check for duplicates before adding
        if (this.isDuplicateActivity(activity, description, timestamp)) {
            console.log('Skipping duplicate Pomodoro activity:', activity);
            return;
        }
        
        const entry = {
            id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
            activity: activity,
            description: description || '',
            timestamp: timestamp,
            created: new Date().toISOString(),
            source: 'pomodoro',
            tags: extraTags
        };
        
        this.activityTracker.addEntry(entry);
        console.log('Auto-logged Pomodoro activity:', activity);
    }
    
    saveSettings() {
        if (!this.activityTracker) return;
        
        // Get current values from UI
        const workDuration = document.getElementById('pomodoroWorkDuration');
        const breakDuration = document.getElementById('pomodoroBreakDuration');
        const longBreakDuration = document.getElementById('pomodoroLongBreakDuration');
        const longBreakInterval = document.getElementById('pomodoroLongBreakInterval');
        const tickSound = document.getElementById('pomodoroTickSound');
        const tickInterval = document.getElementById('pomodoroTickInterval');
        const shortBreakSound = document.getElementById('pomodoroShortBreakSound');
        const longBreakSound = document.getElementById('pomodoroLongBreakSound');
        const resumeSound = document.getElementById('pomodoroResumeSound');
        const autoStart = document.getElementById('pomodoroAutoStart');
        const autoLog = document.getElementById('pomodoroAutoLog');
        const logBreaks = document.getElementById('pomodoroLogBreaks');
        const longBreak = document.getElementById('pomodoroLongBreak');
        const autoResetDaily = document.getElementById('pomodoroAutoResetDaily');
        
        if (workDuration) this.settings.workDuration = parseInt(workDuration.value);
        if (breakDuration) this.settings.breakDuration = parseInt(breakDuration.value);
        if (longBreakDuration) this.settings.longBreakDuration = parseInt(longBreakDuration.value);
        if (longBreakInterval) this.settings.longBreakInterval = parseInt(longBreakInterval.value);
        if (tickSound) this.settings.tickSound = tickSound.value;
        if (tickInterval) this.settings.tickInterval = parseInt(tickInterval.value);
        if (shortBreakSound) this.settings.shortBreakSound = shortBreakSound.value;
        if (longBreakSound) this.settings.longBreakSound = longBreakSound.value;
        if (resumeSound) this.settings.resumeSound = resumeSound.value;
        if (autoStart) this.settings.autoStart = autoStart.checked;
        if (autoLog) this.settings.autoLog = autoLog.checked;
        if (logBreaks) this.settings.logBreaks = logBreaks.checked;
        if (longBreak) this.settings.longBreak = longBreak.checked;
        if (autoResetDaily) this.settings.autoResetDaily = autoResetDaily.checked;
        
        // Save to activity tracker settings
        this.activityTracker.settings.pomodoroWorkDuration = this.settings.workDuration;
        this.activityTracker.settings.pomodoroBreakDuration = this.settings.breakDuration;
        this.activityTracker.settings.pomodoroLongBreakDuration = this.settings.longBreakDuration;
        this.activityTracker.settings.pomodoroLongBreakInterval = this.settings.longBreakInterval;
        this.activityTracker.settings.pomodoroTickSound = this.settings.tickSound;
        this.activityTracker.settings.pomodoroTickInterval = this.settings.tickInterval;
        this.activityTracker.settings.pomodoroShortBreakSound = this.settings.shortBreakSound;
        this.activityTracker.settings.pomodoroLongBreakSound = this.settings.longBreakSound;
        this.activityTracker.settings.pomodoroResumeSound = this.settings.resumeSound;
        this.activityTracker.settings.pomodoroAutoStart = this.settings.autoStart;
        this.activityTracker.settings.pomodoroAutoLog = this.settings.autoLog;
        this.activityTracker.settings.pomodoroLogBreaks = this.settings.logBreaks;
        this.activityTracker.settings.pomodoroLongBreak = this.settings.longBreak;
        this.activityTracker.settings.pomodoroAutoResetDaily = this.settings.autoResetDaily;
        
        console.log('Pomodoro settings saved');
    }
    
    /**
     * Get the current session number
     * @returns {number} Current session number (1-based)
     */
    getCurrentSessionNumber() {
        // Current session is always cycleCount + 1 since cycleCount tracks completed sessions
        return this.cycleCount + 1;
    }
    
    /**
     * Get the next session number
     * @returns {number} Next session number (1-based)
     */
    getNextSessionNumber() {
        // Next session depends on current phase
        return this.currentPhase === 'work' ? this.getCurrentSessionNumber() : this.getCurrentSessionNumber() + 1;
    }
    
    getCurrentStatus() {
        if (!this.isActive) return 'Disabled';
        if (!this.isRunning) return 'Paused';
        
        const timeLeft = Math.ceil((this.remainingTime - (Date.now() - this.startTime)) / 60000);
        const phase = this.currentPhase === 'work' ? 'Working' : 'Break';
        const sessionInfo = this.currentPhase === 'work' ? ` (Session ${this.getCurrentSessionNumber()})` : '';
        return `${phase}${sessionInfo} - ${Math.max(0, timeLeft)}m left`;
    }
    
    // === NEW COMPREHENSIVE FEATURES ===
    
    /**
     * Start tick sounds during work periods
     */
    startTickSounds() {
        console.log(`StartTickSounds called - Active: ${this.isActive}, Phase: ${this.currentPhase}, TickSound: ${this.settings.tickSound}, Interval: ${this.settings.tickInterval}`);
        
        // Stop any existing tick timer first
        this.stopTickSounds();
        
        if (!this.isActive || this.currentPhase !== 'work' || this.settings.tickSound === 'none' || this.settings.tickInterval <= 0) {
            console.log('Tick sounds not started - conditions not met');
            return;
        }
        
        console.log(`Starting tick sounds with ${this.settings.tickInterval}s interval`);
        
        const playTick = () => {
            if (!this.isActive || !this.isRunning || this.currentPhase !== 'work') {
                console.log('Tick cancelled - session ended or not in work phase');
                return;
            }
            
            this.playTickSound();
            
            // Schedule next tick
            this.tickTimer = setTimeout(playTick, this.settings.tickInterval * 1000);
        };
        
        // Start first tick after initial delay
        this.tickTimer = setTimeout(playTick, this.settings.tickInterval * 1000);
    }
    
    /**
     * Stop tick sounds
     */
    stopTickSounds() {
        if (this.tickTimer) {
            clearTimeout(this.tickTimer);
            this.tickTimer = null;
        }
    }
    
    /**
     * Play appropriate tick sound
     */
    playTickSound() {
        if (!this.activityTracker || !this.activityTracker.soundManager) {
            console.warn('Tick sound: No sound manager available');
            return;
        }
        
        if (this.settings.tickSound === 'none') {
            return; // No sound
        }
        
        // Check if sounds are muted
        const isMuted = this.activityTracker.isPomodoroSoundMuted();
        if (isMuted) {
            return; // Pomodoro sounds are muted
        }
        
        let soundType = 'soft-tick'; // Default fallback
        switch (this.settings.tickSound) {
            case 'soft':
                soundType = 'soft-tick';
                break;
            case 'classic':
                soundType = 'classic-tick';
                break;
            case 'digital':
                soundType = 'digital-tick';
                break;
        }
        
        console.log(`Playing tick sound: ${soundType} (interval: ${this.settings.tickInterval}s)`);
        this.activityTracker.soundManager.playSound(soundType, false);
    }
    
    /**
     * Abandon current session and restart at same session number
     */
    abandonCurrentSession() {
        if (!this.isActive || !this.isRunning) {
            return;
        }
        
        // Calculate how much time was spent
        const timeSpent = this.originalDuration - this.remainingTime + (Date.now() - this.startTime);
        const minutesSpent = Math.round(timeSpent / 60000);
        
        // Get current session number consistently
        const currentSession = this.getCurrentSessionNumber();
        
        // Stop current timers
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        this.stopTickSounds();
        this.stopStatusUpdates();
        
        // Show abandonment options if we've spent meaningful time (>2 minutes)
        if (minutesSpent > 2 && this.currentPhase === 'work' && this.settings.autoLog) {
            this.showAbandonmentSaveDialog(currentSession, minutesSpent);
        } else {
            // Just abandon without save option for short sessions
            this.finalizeAbandonment(currentSession, false);
        }
    }
    
    /**
     * Show dialog to save partial work when abandoning session
     */
    showAbandonmentSaveDialog(sessionNumber, minutesSpent) {
        if (typeof showPomodoroAbandonDialog === 'function') {
            // Set up the dialog with current session info
            const dialogTitle = document.getElementById('pomodoroAbandonTitle');
            const timeSpentElement = document.getElementById('pomodoroAbandonTimeSpent');
            const activityName = document.getElementById('pomodoroAbandonActivityName');
            const activityDescription = document.getElementById('pomodoroAbandonActivityDescription');
            
            if (dialogTitle) {
                dialogTitle.textContent = `Session ${sessionNumber} Abandonment`;
            }
            if (timeSpentElement) {
                timeSpentElement.textContent = `You worked for ${minutesSpent} minutes`;
            }
            if (activityName && this.currentWorkActivity) {
                activityName.value = this.currentWorkActivity.name || '';
            }
            if (activityDescription && this.currentWorkActivity) {
                activityDescription.value = this.currentWorkActivity.description || `Partial work on session ${sessionNumber} (${minutesSpent} minutes)`;
            }
            
            showPomodoroAbandonDialog();
        } else {
            // Fallback if dialog function not available
            this.finalizeAbandonment(sessionNumber, false);
        }
    }
    
    /**
     * Handle saving partial work when abandoning
     */
    handleAbandonmentSave(saveWork) {
        const currentSession = this.getCurrentSessionNumber();
        
        if (saveWork && this.settings.autoLog) {
            const activityName = document.getElementById('pomodoroAbandonActivityName');
            const activityDescription = document.getElementById('pomodoroAbandonActivityDescription');
            
            const activity = activityName ? activityName.value.trim() : '';
            const description = activityDescription ? activityDescription.value.trim() : '';
            
            if (activity) {
                this.logActivity(activity, description || `Partial Pomodoro session ${currentSession} work`, [this.generateAbandonedTag(currentSession)]);
                showNotification(`Partial work saved: "${activity}"`, 'success');
            }
        }
        
        // Close the dialog
        if (typeof closePomodoroAbandonDialog === 'function') {
            closePomodoroAbandonDialog();
        }
        
        // Finalize abandonment
        this.finalizeAbandonment(currentSession, saveWork);
    }
    
    /**
     * Generate shortened pomodoro tag for abandoned sessions
     */
    generateAbandonedTag(sessionNumber) {
        const today = new Date().toISOString().split('T')[0].replace(/-/g, ''); // YYYYMMDD format
        const sessionStr = sessionNumber.toString().padStart(2, '0');
        return `pd${today}_${sessionStr}_dnc`;
    }

    /**
     * Generate shortened pomodoro tag for break sessions
     */
    generateBreakTag(isLongBreak) {
        const today = new Date().toISOString().split('T')[0].replace(/-/g, ''); // YYYYMMDD format
        const breakType = isLongBreak ? 'lb' : 'sb'; // lb = long break, sb = short break
        return `pd${today}_${breakType}`;
    }

    /**
     * Complete the abandonment process
     */
    finalizeAbandonment(sessionNumber, workSaved) {
        // Log abandonment (separate from any saved work)
        if (this.settings.autoLog && !workSaved) {
            if (this.currentWorkActivity && this.currentWorkActivity.name) {
                this.logActivity(
                    this.currentWorkActivity.name,
                    this.currentWorkActivity.description || `Pomodoro session ${sessionNumber} abandoned`,
                    [this.generateAbandonedTag(sessionNumber)]
                );
            } else {
                this.logActivity(
                    `Pomodoro session ${sessionNumber} abandoned`,
                    `Session interrupted, restarting at session ${sessionNumber}`,
                    [this.generateAbandonedTag(sessionNumber)]
                );
            }
        }
        
        // Reset to beginning of current work session
        // No need to adjust cycleCount as we're restarting the same session
        this.isRunning = false;
        this.isPaused = false;
        this.pausedAt = null;
        this.currentPhase = 'work';
        
        // Clear current work activity to force re-selection
        this.currentWorkActivity = null;
        
        // Save progress
        this.updateState();
        
        // Show notification
        const message = workSaved ? 
            `Session ${sessionNumber} abandoned with work saved. Click Start to begin next session.` :
            `Session ${sessionNumber} abandoned. Click Start to begin next session.`;
        showNotification(message, 'warning');
        
        // Update UI
        this.updateUI();
        
        console.log(`Session ${sessionNumber} abandoned, user must restart manually`);
    }
    
    /**
     * Restore pomodoro state from application state
     */
    restoreFromState(pomodoroState) {
        if (!pomodoroState) return;
        
        console.log('Restoring pomodoro from state:', pomodoroState);
        
        // Restore basic state
        this.cycleCount = pomodoroState.cycleCount || 0;
        this.totalSessions = pomodoroState.totalSessions || 0;
        
        // If there's a running session, restore it
        if (pomodoroState.isRunning && pomodoroState.startTime && pomodoroState.remainingTime) {
            this.restoreActiveSession(pomodoroState);
        }
        
        // Update UI
        this.updateUI();
    }

    /**
     * Restore an active session from state
     */
    restoreActiveSession(state) {
        const now = Date.now();
        
        // Calculate how much time has passed
        let timeLeft;
        if (state.isPaused && state.pausedAt) {
            // Session was paused - use the paused state
            const timeElapsedBeforePause = state.pausedAt - state.startTime;
            timeLeft = state.originalDuration - timeElapsedBeforePause;
        } else {
            // Session was running - calculate elapsed time
            const elapsedTime = now - state.startTime;
            timeLeft = state.remainingTime - elapsedTime;
        }
        
        console.log(`Time remaining calculation: ${Math.ceil(timeLeft/1000)}s`);
        
        // Check if session expired while page was closed
        if (timeLeft <= 0) {
            this.handleExpiredSession(state);
            return;
        }
        
        // Restore the active session
        this.isActive = true;
        this.isRunning = true;
        this.currentPhase = state.currentPhase;
        this.originalDuration = state.originalDuration;
        
        if (state.isPaused) {
            // Restore paused session
            this.isPaused = true;
            this.pausedAt = state.pausedAt;
            this.startTime = state.startTime;
            this.remainingTime = state.remainingTime;
            this.startStatusUpdates();
            
            showNotification(`Paused session restored! ${Math.ceil(timeLeft/60000)} minutes remaining.`, 'info');
        } else {
            // Restore running session
            this.isPaused = false;
            this.pausedAt = null;
            this.startTime = now; // Reset start time to now
            this.remainingTime = timeLeft;
            
            // Restart the timer
            this.timer = setTimeout(() => {
                if (this.currentPhase === 'work') {
                    this.endWorkPeriod();
                } else {
                    this.endBreakPeriod();
                }
            }, timeLeft);
            
            this.startTickSounds();
            this.startStatusUpdates();
            
            showNotification(`Session restored! ${Math.ceil(timeLeft/60000)} minutes remaining.`, 'success');
        }
        
        // Restore work activity
        if (state.workActivity) {
            this.currentWorkActivity = state.workActivity;
        }
    }

    /**
     * Handle a session that expired while the page was closed
     */
    handleExpiredSession(state) {
        if (state.currentPhase === 'work') {
            console.log('Work period expired during reload');
            showNotification('Work session completed while page was closed. Ready for break!', 'info');
        } else {
            console.log('Break period expired during reload');
            showNotification('Break completed while page was closed. Ready for next session!', 'info');
        }
        
        this.isActive = true;
        this.isRunning = false;
        this.isPaused = false;
    }

    /**
     * Update pomodoro state in application state
     */
    updateState() {
        if (!this.activityTracker) return;
        
        const pomodoroState = {
            isRunning: this.isRunning,
            isPaused: this.isPaused,
            currentPhase: this.currentPhase,
            sessionNumber: this.getCurrentSessionNumber(),
            startTime: this.startTime,
            originalDuration: this.originalDuration,
            remainingTime: this.remainingTime,
            pausedAt: this.pausedAt,
            workActivity: this.currentWorkActivity,
            cycleCount: this.cycleCount,
            totalSessions: this.totalSessions
        };
        
        this.activityTracker.updatePomodoroState(pomodoroState);
    }
    
    /**
     * Update status display in UI
     */
    updateStatusDisplay() {
        const statusDisplay = document.getElementById('pomodoroStatus');
        const banner = document.getElementById('statusBanner');
        const pomodoroSection = document.getElementById('pomodoroStatusSection');
        const timer = document.getElementById('pomodoroTimer');
        const timeRemaining = document.getElementById('pomodoroTimeRemaining');
        const phase = document.getElementById('pomodoroPhase');
        const activityDisplay = document.getElementById('pomodoroActivityDisplay');
        const activityText = document.getElementById('pomodoroActivityText');
        const activityDesc = document.getElementById('pomodoroActivityDesc');
        
        if (!this.isActive) {
            if (statusDisplay) {
                statusDisplay.textContent = 'Pomodoro mode disabled';
                statusDisplay.style.display = 'block';
            }
            if (timer) timer.style.display = 'none';
            if (pomodoroSection) pomodoroSection.style.display = 'none';
            
            // Hide the entire banner if no sections are visible
            const reminderSection = document.getElementById('reminderStatusSection');
            if (banner && reminderSection && 
                pomodoroSection && pomodoroSection.style.display === 'none' && 
                reminderSection.style.display === 'none') {
                banner.style.display = 'none';
            }
            
            // Re-enable standard reminders when Pomodoro is disabled
            if (this.activityTracker && this.activityTracker.settings.notificationsEnabled) {
                this.activityTracker.startNotificationTimer();
            }
            return;
        }
        
        // Disable standard reminders when Pomodoro is active
        if (this.activityTracker) {
            this.activityTracker.stopNotificationTimer();
        }
        
        // Show banner and Pomodoro section when active
        if (banner && pomodoroSection) {
            banner.style.display = 'block';
            pomodoroSection.style.display = 'flex';
        }
        
        if (!this.isRunning) {
            // Show status text and hide timer when no session is running
            if (statusDisplay) {
                const nextSession = this.getCurrentSessionNumber();
                statusDisplay.textContent = `Ready to start session ${nextSession}`;
                statusDisplay.style.display = 'block';
            }
            if (timer) timer.style.display = 'none';
            this.hidePauseButton();
            return;
        }
        
        // Hide status text and show horizontal bar when running
        if (statusDisplay) statusDisplay.style.display = 'none';
        if (timer) timer.style.display = 'flex';
        
        const timeLeft = Math.ceil((this.remainingTime - (Date.now() - this.startTime)) / 60000);
        const timeLeftSafe = Math.max(0, timeLeft);
        
        // Calculate more precise time remaining for display
        let totalMs;
        if (this.isPaused) {
            // Show time remaining when paused
            const timeElapsedBeforePause = this.pausedAt - this.startTime;
            totalMs = this.originalDuration - timeElapsedBeforePause;
        } else {
            // Normal running calculation
            totalMs = this.remainingTime - (Date.now() - this.startTime);
        }
        const minutes = Math.floor(totalMs / 60000);
        const seconds = Math.floor((totalMs % 60000) / 1000);
        const formattedTime = `${Math.max(0, minutes)}:${Math.max(0, seconds).toString().padStart(2, '0')}`;
        
        if (this.currentPhase === 'work') {
            const currentSession = this.getCurrentSessionNumber();
            if (timeRemaining) timeRemaining.textContent = formattedTime;
            if (phase) phase.textContent = this.isPaused ? `#${currentSession} (Paused)` : `#${currentSession}`;
            
            // Show activity if available
            if (activityDisplay && activityText && this.currentWorkActivity && this.currentWorkActivity.name) {
                activityDisplay.style.display = 'block';
                activityText.textContent = this.currentWorkActivity.name;
                
                // Show description if available and there's space
                if (activityDesc && this.currentWorkActivity.description) {
                    activityDesc.textContent = this.currentWorkActivity.description;
                    activityDesc.style.display = 'block';
                } else if (activityDesc) {
                    activityDesc.style.display = 'none';
                }
            } else if (activityDisplay) {
                activityDisplay.style.display = 'none';
            }
        } else {
            const isLongBreak = this.settings.longBreak && this.cycleCount > 0 && (this.cycleCount % this.settings.longBreakInterval === 0);
            const breakType = isLongBreak ? 'Long Break' : 'Short Break';
            
            if (timeRemaining) timeRemaining.textContent = formattedTime;
            if (phase) phase.textContent = this.isPaused ? `${breakType} (Paused)` : breakType;
            
            // Hide activity during breaks
            if (activityDisplay) {
                activityDisplay.style.display = 'none';
            }
        }
        
        // Update pause button visibility and text based on state and settings
        if (this.settings.pauseAllowed) {
            this.showPauseButton();
            this.updatePauseButtonText();
        } else {
            this.hidePauseButton();
        }
    }
    
    /**
     * Update the main Pomodoro button in navigation
     */
    updatePomodoroButton() {
        const pomodoroBtn = document.getElementById('pomodoroButton');
        if (!pomodoroBtn) return;
        
        if (!this.settings.enabled) {
            pomodoroBtn.style.display = 'none';
            return;
        }
        
        pomodoroBtn.style.display = 'inline-block';
        
        if (!this.isActive) {
            pomodoroBtn.textContent = 'Start Pomodoro';
            pomodoroBtn.className = 'nav-btn pomodoro-btn';
            pomodoroBtn.title = 'Start a new Pomodoro session';
        } else if (this.isRunning) {
            if (this.currentPhase === 'work') {
                const currentSession = this.getCurrentSessionNumber();
                pomodoroBtn.textContent = `Abandon Session ${currentSession}`;
                pomodoroBtn.className = 'nav-btn pomodoro-btn active';
                pomodoroBtn.title = 'Abandon current work session and restart';
            } else {
                pomodoroBtn.textContent = 'On Break';
                pomodoroBtn.className = 'nav-btn pomodoro-btn breaking';
                pomodoroBtn.title = 'Currently on break - click to abandon and restart';
            }
        } else {
            const nextSession = this.getCurrentSessionNumber();
            pomodoroBtn.textContent = ` Start Session ${nextSession}`;
            pomodoroBtn.className = 'nav-btn pomodoro-btn';
            pomodoroBtn.title = `Start work session ${nextSession}`;
        }
    }
    
    /**
     * Toggle Pomodoro (called from nav button)
     */
    togglePomodoroFromButton() {
        if (!this.isActive) {
            // Start Pomodoro mode and immediately begin first work session
            this.togglePomodoroMode(true);
            this.startWorkPeriod();
        } else if (this.isRunning) {
            // Abandon current session
            this.abandonCurrentSession();
        } else {
            // Start next session
            this.startWorkPeriod();
        }
    }
    
    /**
     * Start periodic status updates
     */
    startStatusUpdates() {
        this.stopStatusUpdates(); // Clear any existing interval
        
        this.statusUpdateInterval = setInterval(() => {
            if (this.isActive && (this.isRunning || this.isPaused)) {
                this.updateStatusDisplay();
                this.updatePomodoroButton();
            }
        }, 1000); // Update every second
    }
    
    /**
     * Stop periodic status updates
     */
    stopStatusUpdates() {
        if (this.statusUpdateInterval) {
            clearInterval(this.statusUpdateInterval);
            this.statusUpdateInterval = null;
        }
    }
    
    /**
     * Check for daily auto-reset functionality
     */
    checkDailyAutoReset() {
        if (!this.settings.autoResetDaily) return;
        
        const today = new Date().toDateString();
        
        // If we have a last reset date and it's different from today, reset
        if (this.lastResetDate && this.lastResetDate !== today) {
            console.log('Daily auto-reset triggered');
            this.cycleCount = 0;
            this.totalSessions = 0;
            this.lastResetDate = today;
            
            if (this.settings.autoLog) {
                this.logActivity('Daily Pomodoro reset', 'Session counter automatically reset for new day');
            }
            
            this.updateState();
            this.updateUI();
            
            showNotification('Daily session reset applied', 'info');
        } else if (!this.lastResetDate) {
            // First time, just set the date
            this.lastResetDate = today;
            this.updateState();
        }
    }
    
    /**
     * Reset Pomodoro session counter (for complete restart)
     */
    resetSessionCounter() {
        this.cycleCount = 0;
        this.totalSessions = 0;
        this.lastResetDate = new Date().toDateString(); // Update reset date
        this.updateState();
        this.updateUI();
        
        if (this.settings.autoLog) {
            this.logActivity('Pomodoro session counter reset', 'Starting fresh Pomodoro cycle');
        }
        
        showNotification('Pomodoro session counter reset', 'info');
    }
    
    /**
     * Show work activity modal to prompt for session description
     */
    showWorkActivityModal() {
        if (typeof showPomodoroActivityModal === 'function') {
            showPomodoroActivityModal();
            
            // Set up form handler if not already done
            const form = document.getElementById('pomodoroActivityForm');
            if (form && !form.pomodoroHandlerAdded) {
                form.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleWorkActivitySubmit();
                });
                form.pomodoroHandlerAdded = true;
            }
        }
    }
    
    /**
     * Handle work activity form submission
     */
    handleWorkActivitySubmit() {
        const activityName = document.getElementById('pomodoroActivityName');
        const activityDescription = document.getElementById('pomodoroActivityDescription');
        
        if (activityName && activityName.value.trim()) {
            // Store the activity for logging when session completes
            this.currentWorkActivity = {
                name: activityName.value.trim(),
                description: activityDescription ? activityDescription.value.trim() : ''
            };
            
            // Close modal
            if (typeof closePomodoroActivityModal === 'function') {
                closePomodoroActivityModal();
            }
            
            // Start the work period
            this.pendingWorkSession = false;
            this.actuallyStartWorkPeriod();
            
            // Save the work activity to session state
            this.updateState();
            
            console.log('Work session started with activity:', this.currentWorkActivity.name);
        }
    }
    
    /**
     * Toggle pause/resume of current Pomodoro session
     */
    togglePause() {
        if (!this.isActive || !this.isRunning) {
            return; // Can't pause if not running
        }
        
        if (!this.settings.pauseAllowed) {
            showNotification('Session pausing is disabled in settings', 'warning');
            return;
        }
        
        if (this.isPaused) {
            // Resume
            this.resumeSession();
        } else {
            // Pause
            this.pauseSession();
        }
    }
    
    /**
     * Pause the current session
     */
    pauseSession() {
        if (!this.isActive || !this.isRunning || this.isPaused) return;
        
        this.isPaused = true;
        this.pausedAt = Date.now();
        
        // Clear the timer
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        
        // Stop tick sounds but keep status updates for UI display
        this.stopTickSounds();
        // Note: Keep status updates running to show paused timer display
        
        // Save pause state
        this.updateState();
        
        // Update UI
        this.updateStatusDisplay();
        this.updatePomodoroButton();
        
        showNotification('Pomodoro session paused', 'info');
        console.log('Session paused');
    }
    
    /**
     * Resume the paused session
     */
    resumeSession() {
        if (!this.isActive || !this.isPaused) return;
        
        // Calculate how much time was remaining when paused
        const timeElapsedBeforePause = this.pausedAt - this.startTime;
        const remainingTimeWhenPaused = this.originalDuration - timeElapsedBeforePause;
        
        // Reset start time to now, keeping the same remaining time
        this.startTime = Date.now();
        this.remainingTime = remainingTimeWhenPaused;
        
        this.isPaused = false;
        this.pausedAt = null;
        
        // Restart the timer with the remaining time
        this.timer = setTimeout(() => {
            if (this.currentPhase === 'work') {
                this.endWorkPeriod();
            } else {
                this.endBreakPeriod();
            }
        }, remainingTimeWhenPaused);
        
        // Restart tick sounds and status updates
        if (this.currentPhase === 'work') {
            this.startTickSounds();
        }
        this.startStatusUpdates();
        
        // Save resumed state
        this.updateState();
        
        // Update UI
        this.updateStatusDisplay();
        this.updatePomodoroButton();
        
        showNotification('Pomodoro session resumed', 'success');
        console.log('Session resumed');
    }
    
    /**
     * Show the pause button in the banner
     */
    showPauseButton() {
        const controls = document.getElementById('pomodoroBannerControls');
        if (controls) {
            controls.style.display = 'flex';
        }
    }
    
    /**
     * Hide the pause button in the banner
     */
    hidePauseButton() {
        const controls = document.getElementById('pomodoroBannerControls');
        if (controls) {
            controls.style.display = 'none';
        }
    }
    
    /**
     * Update the pause button text based on current state
     */
    updatePauseButtonText() {
        const pauseBtn = document.getElementById('pomodoroPauseBtn');
        if (pauseBtn) {
            pauseBtn.textContent = this.isPaused ? 'Resume' : 'Pause';
        }
    }
    
    destroy() {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        this.stopTickSounds();
        this.stopStatusUpdates();
        this.isActive = false;
        this.isRunning = false;
        console.log('Pomodoro Manager destroyed');
    }
}

// Export for use in other modules
if (typeof window !== 'undefined') {
    window.PomodoroManager = PomodoroManager;
}

console.log('Pomodoro Manager module loaded');

// === markdownRenderer.js ===
/**
 * Lightweight Markdown Renderer for Activity Tracker
 * Handles basic markdown rendering for reports preview
 */

class MarkdownRenderer {
    constructor() {
        this.rules = [
            // Headers
            { pattern: /^### (.*$)/gim, replacement: '<h3>$1</h3>' },
            { pattern: /^## (.*$)/gim, replacement: '<h2>$1</h2>' },
            { pattern: /^# (.*$)/gim, replacement: '<h1>$1</h1>' },
            
            // Bold
            { pattern: /\*\*(.*)\*\*/gim, replacement: '<strong>$1</strong>' },
            
            // Italic
            { pattern: /\*(.*)\*/gim, replacement: '<em>$1</em>' },
            
            // Code (inline)
            { pattern: /`(.*)`/gim, replacement: '<code>$1</code>' },
            
            // Links
            { pattern: /\[([^\]]*)\]\(([^\)]*)\)/gim, replacement: '<a href="$2">$1</a>' },
            
            // Horizontal rules
            { pattern: /^---\s*$/gim, replacement: '<hr>' },
            
            // Blockquotes
            { pattern: /^> (.*)$/gim, replacement: '<blockquote>$1</blockquote>' },
            
            // Unordered lists
            { pattern: /^\- (.*)$/gim, replacement: '<li>$1</li>' }
        ];
    }

    /**
     * Render markdown to HTML
     * @param {string} markdown - Markdown text
     * @param {boolean} inline - Whether this is inline rendering (for descriptions)  
     * @returns {string} HTML string
     */
    render(markdown, inline = false) {
        if (!markdown || typeof markdown !== 'string') {
            return '';
        }

        let html = markdown.trim();

        // Apply markdown rules
        this.rules.forEach(rule => {
            html = html.replace(rule.pattern, rule.replacement);
        });

        // Handle line breaks and paragraphs
        if (inline) {
            // For inline content (descriptions), be more conservative
            // Double newlines become paragraph breaks
            html = html.replace(/\n\s*\n/gim, '</p><p>');
            // Single newlines become line breaks only if not in lists
            html = html.replace(/\n(?![<\/])/gim, '<br>');
        } else {
            // For full content, handle paragraphs more aggressively
            html = html.replace(/\n\s*\n/gim, '</p><p>');
            html = html.replace(/\n(?![<\/])/gim, '<br>');
        }

        // Wrap in paragraphs if not inline or if it doesn't start with a block element
        if (!inline || !html.match(/^<(h[1-6]|ul|ol|blockquote|hr)/)) {
            html = '<p>' + html + '</p>';
        }

        // Clean up empty paragraphs
        html = html.replace(/<p>\s*<\/p>/gim, '');
        html = html.replace(/<p><h/gim, '<h');
        html = html.replace(/<\/h([1-6])><\/p>/gim, '</h$1>');
        html = html.replace(/<p><hr><\/p>/gim, '<hr>');
        html = html.replace(/<p><blockquote>/gim, '<blockquote>');
        html = html.replace(/<\/blockquote><\/p>/gim, '</blockquote>');
        html = html.replace(/<p><ul>/gim, '<ul>');
        html = html.replace(/<\/ul><\/p>/gim, '</ul>');

        // Handle lists
        html = this.renderLists(html);
        
        // Clean up extra line breaks around lists
        html = html.replace(/<br>\s*<\/li>/gim, '</li>');
        html = html.replace(/<li><br>/gim, '<li>');
        html = html.replace(/<\/ul><br>/gim, '</ul>');
        html = html.replace(/<br><ul>/gim, '<ul>');

        return html;
    }

    /**
     * Process list items into proper ul/ol tags
     * @param {string} html - HTML with list items
     * @returns {string} HTML with proper list structure
     */
    renderLists(html) {
        // Find sequences of <li> tags (including those separated by <br> tags) and wrap them in <ul>
        html = html.replace(/(<li>.*?<\/li>)(\s*(<br>)?\s*<li>.*?<\/li>)*/gim, (match) => {
            // Remove <br> tags between list items
            const cleanMatch = match.replace(/<br>\s*(?=<li>)/gim, '');            return '<ul>' + match + '</ul>';
        });

        // Clean up paragraph tags around lists
        html = html.replace(/<p><ul>/gim, '<ul>');
        html = html.replace(/<\/ul><\/p>/gim, '</ul>');
        html = html.replace(/<p><li>/gim, '<li>');
        html = html.replace(/<\/li><\/p>/gim, '</li>');
        
        // Remove <br> tags immediately before/after lists
        html = html.replace(/<br>\s*<ul>/gim, '<ul>');
        html = html.replace(/<\/ul>\s*<br>/gim, '</ul>');

        return html;
    }

    /**
     * Render inline markdown (for descriptions)
     * @param {string} markdown - Markdown text
     * @returns {string} HTML string
     */
    renderInline(markdown) {
        return this.render(markdown, true);
    }

    /**
     * Render markdown with custom CSS classes
     * @param {string} markdown - Markdown text
     * @param {boolean} inline - Whether this is inline rendering
     * @returns {string} HTML with CSS classes
     */
    renderWithClasses(markdown, inline = false) {
        let html = this.render(markdown, inline);
        
        // Add CSS classes for styling
        html = html.replace(/<h1>/gim, '<h1 class="md-h1">');
        html = html.replace(/<h2>/gim, '<h2 class="md-h2">');
        html = html.replace(/<h3>/gim, '<h3 class="md-h3">');
        html = html.replace(/<blockquote>/gim, '<blockquote class="md-blockquote">');
        html = html.replace(/<code>/gim, '<code class="md-code">');
        html = html.replace(/<ul>/gim, '<ul class="md-list">');
        html = html.replace(/<p>/gim, '<p class="md-paragraph">');
        html = html.replace(/<hr>/gim, '<hr class="md-hr">');

        return html;
    }

    /**
     * Render inline markdown with CSS classes (for descriptions)
     * @param {string} markdown - Markdown text
     * @returns {string} HTML string with classes
     */
    renderInlineWithClasses(markdown) {
        return this.renderWithClasses(markdown, true);
    }

    /**
     * Create a preview of markdown content (first few lines)
     * @param {string} markdown - Markdown text
     * @param {number} maxLines - Maximum lines to preview
     * @returns {string} HTML preview
     */
    preview(markdown, maxLines = 10) {
        if (!markdown) return '';
        
        const lines = markdown.split('\n').slice(0, maxLines);
        const previewMarkdown = lines.join('\n');
        
        if (lines.length >= maxLines && markdown.split('\n').length > maxLines) {
            return this.renderWithClasses(previewMarkdown) + '<p class="md-preview-more">...</p>';
        }
        
        return this.renderWithClasses(previewMarkdown);
    }
}

// Export for use in other modules
if (typeof window !== 'undefined') {
    window.MarkdownRenderer = MarkdownRenderer;
}

console.log('Markdown Renderer module loaded');


// === templating.js ===
/**
 * A robust templating engine using tokenizer and AST approach
 * This properly handles nested loops and maintains correct context
 */
class TemplatingEngine {
    constructor() {
        this.formatters = {
            // Date/Time Formatters
            date: (value, format = 'dd/mm/yyyy') => this.formatDate(value, format),
            time: (value) => {
                if (!value) return '--:--';
                let date = value instanceof Date ? value : new Date(value);
                if (isNaN(date.getTime())) return '--:--';
                return date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
            },
            datetime: (value) => new Date(value).toLocaleString('en-GB'),
            uppercase: (value) => String(value).toUpperCase(),
            lowercase: (value) => String(value).toLowerCase(),
            capitalize: (value) => String(value).charAt(0).toUpperCase() + String(value).slice(1),
            escapeHtml: (value) => this.escapeHtml(value),
            escapeCsv: (value) => this.escapeCsv(value),
            nl2br: (value) => String(value).replace(/\n/g, '<br>'),
            stripLinebreaks: (value) => String(value).replace(/(\r\n|\n|\r)/gm, " "),
            duration: (value) => this.formatDuration(value),
            markdown: (value) => {
                if (window.MarkdownRenderer) {
                    const renderer = new window.MarkdownRenderer();
                    return renderer.renderInlineWithClasses(String(value));
                }
                return this.escapeHtml(value);
            },
            cleanHashtags: (value) => this.cleanHashtags(value)
        };
        console.log('Templating Engine Initialized (Tokenizer Version)');
    }

    /**
     * Main render method using tokenizer approach
     */
    render(template, data) {
        console.log('Starting template render with tokenizer');
        
        try {
            // Step 1: Tokenize the template
            const tokens = this.tokenize(template);
            console.log('Tokens:', tokens);
            
            // Step 2: Parse tokens into AST
            const ast = this.parse(tokens);
            console.log(' AST:', ast);
            
            // Step 3: Evaluate AST with data
            const result = this.evaluate(ast, data);
            
            console.log('Template render complete');
            return result;
        } catch (error) {
            console.error('Template render error:', error);
            return `Template Error: ${error.message}`;
        }
    }

    /**
     * Tokenize template into discrete tokens
     */
    tokenize(template) {
        const tokens = [];
        let current = 0;
        
        while (current < template.length) {
            // Look for template expressions {{ ... }}
            const start = template.indexOf('{{', current);
            
            if (start === -1) {
                // No more template expressions, add rest as text
                if (current < template.length) {
                    tokens.push({
                        type: 'TEXT',
                        value: template.substring(current)
                    });
                }
                break;
            }
            
            // Add any text before the expression
            if (start > current) {
                tokens.push({
                    type: 'TEXT',
                    value: template.substring(current, start)
                });
            }
            
            // Find the end of the expression
            const end = template.indexOf('}}', start);
            if (end === -1) {
                throw new Error('Unclosed template expression at position ' + start);
            }
            
            // Extract and parse the expression
            const expression = template.substring(start + 2, end).trim();
            const token = this.parseExpression(expression);
            tokens.push(token);
            
            current = end + 2;
        }
        
        return tokens;
    }

    /**
     * Parse a single template expression into a token
     */
    parseExpression(expression) {
        console.log('Parsing expression:', JSON.stringify(expression));
        
        // Handle different types of expressions
        if (expression.startsWith('#each ')) {
            const match = expression.match(/^#each\s+(\w+)\s*=\s*([\w.]+)$/);
            console.log('Each match result:', match);
            if (!match) throw new Error('Invalid each expression: ' + expression);
            return {
                type: 'EACH_START',
                itemVar: match[1],
                arrayPath: match[2]
            };
        }
        
        if (expression === '/each') {
            console.log('Found /each');
            return { type: 'EACH_END' };
        }    


        if (expression.startsWith('#if ')) {
            const condition = expression.substring(4).trim();
            return {
                type: 'IF_START',
                condition: condition
            };
        }
        
        if (expression === 'else') {
            return { type: 'ELSE' };
        }
        
        if (expression === '/if') {
            return { type: 'IF_END' };
        }
        
        // Regular variable with optional formatters
        const parts = expression.split('|').map(s => s.trim());
        return {
            type: 'VARIABLE',
            path: parts[0],
            formatters: parts.slice(1)
        };
    }

    /**
     * Parse tokens into Abstract Syntax Tree
     */
    parse(tokens) {
        const ast = [];
        let current = 0;
        
        while (current < tokens.length) {
            const result = this.parseNode(tokens, current);
            if (result) {
                ast.push(result.node);
                current = result.nextIndex;
            } else {
                current++;
            }
        }
        
        return ast;
    }

    /**
     * Parse a single node and return it with the next index
     */
    parseNode(tokens, startIndex) {
        if (startIndex >= tokens.length) {
            console.log(` parseNode: reached end of tokens at index ${startIndex}`);
            return null;
        }
        
        const token = tokens[startIndex];
        console.log(`parseNode at ${startIndex}:`, token.type);
        
        switch (token.type) {
            case 'TEXT':
                return {
                    node: { type: 'text', value: token.value },
                    nextIndex: startIndex + 1
                };
                
            case 'VARIABLE':
                return {
                    node: { 
                        type: 'variable', 
                        path: token.path, 
                        formatters: token.formatters 
                    },
                    nextIndex: startIndex + 1
                };
                
            case 'EACH_START':
                return this.parseEachLoop(tokens, startIndex);
                
            case 'IF_START':
                return this.parseIfStatement(tokens, startIndex);
                
            case 'EACH_END':
            case 'IF_END':
            case 'ELSE':
                // These should be handled by their respective parent parsers
                console.warn('Orphaned token:', token.type, 'at index', startIndex);
                return null;
                
            default:
                throw new Error('Unknown token type: ' + token.type);
        }
    }

    /**
     * Parse an each loop and its contents
     */
    parseEachLoop(tokens, startIndex) {
        const startToken = tokens[startIndex];
        const children = [];
        let current = startIndex + 1;
        let depth = 1;
        
        console.log(`Starting parseEachLoop for ${startToken.itemVar} = ${startToken.arrayPath}, startIndex: ${startIndex}`);
        
        while (current < tokens.length && depth > 0) {
            const token = tokens[current];
            console.log(`Processing token at ${current}:`, token.type, token);
            
            if (token.type === 'EACH_START') {
                console.log(`Nested each found, depth was: ${depth}`);
                // Parse the nested each loop
                const result = this.parseEachLoop(tokens, current);
                children.push(result.node);
                current = result.nextIndex;
                console.log(` After nested each, current index: ${current}`);
                // Don't increment depth here - the nested call handles its own depth
            } else if (token.type === 'EACH_END') {
                depth--;
                console.log(`Each end found, depth now: ${depth}`);
                if (depth === 0) {
                    // Found our matching end
                    console.log(`Found matching end for ${startToken.itemVar}`);
                    break;
                } else {
                    // This should not happen if parsing is correct
                    console.error(`Unexpected EACH_END at depth ${depth} for ${startToken.itemVar}`);
                    current++;
                }
            } else {
                // Parse regular content
                const result = this.parseNode(tokens, current);
                if (result) {
                    children.push(result.node);
                    current = result.nextIndex;
                } else {
                    current++;
                }
            }
        }
        
        if (depth > 0) {
            console.error(`Unclosed each loop for ${startToken.itemVar}, depth: ${depth}, current: ${current}, tokens.length: ${tokens.length}`);
            console.error('Remaining tokens:', tokens.slice(current).map(t => `${t.type}: ${JSON.stringify(t.value || t.path)}`));
            throw new Error(`Unclosed each loop for ${startToken.itemVar}`);
        }
        
        console.log(`Completed parseEachLoop for ${startToken.itemVar}, nextIndex: ${current + 1}`);
        
        return {
            node: {
                type: 'each',
                itemVar: startToken.itemVar,
                arrayPath: startToken.arrayPath,
                children: children
            },
            nextIndex: current + 1
        };
    }

    /**
     * Parse an if statement and its contents
     */
    parseIfStatement(tokens, startIndex) {
        const startToken = tokens[startIndex];
        const ifChildren = [];
        const elseChildren = [];
        let current = startIndex + 1;
        let depth = 1;
        let inElse = false;
        
        while (current < tokens.length && depth > 0) {
            const token = tokens[current];
            
            if (token.type === 'IF_START') {
                depth++;
                const result = this.parseIfStatement(tokens, current);
                if (inElse) {
                    elseChildren.push(result.node);
                } else {
                    ifChildren.push(result.node);
                }
                current = result.nextIndex;
            } else if (token.type === 'IF_END') {
                depth--;
                if (depth === 0) break;
                current++;
            } else if (token.type === 'ELSE' && depth === 1) {
                inElse = true;
                current++;
            } else {
                const result = this.parseNode(tokens, current);
                if (result) {
                    if (inElse) {
                        elseChildren.push(result.node);
                    } else {
                        ifChildren.push(result.node);
                    }
                    current = result.nextIndex;
                } else {
                    current++;
                }
            }
        }
        
        return {
            node: {
                type: 'if',
                condition: startToken.condition,
                ifChildren: ifChildren,
                elseChildren: elseChildren
            },
            nextIndex: current + 1
        };
    }

    /**
     * Evaluate AST with given data context
     */
    evaluate(ast, data, depth = 0) {
        const indent = '  '.repeat(depth);
        console.log(`${indent}Evaluating AST with context:`, Object.keys(data));
        
        return ast.map(node => this.evaluateNode(node, data, depth)).join('');
    }

    /**
     * Evaluate a single AST node
     */
    evaluateNode(node, data, depth = 0) {
        const indent = '  '.repeat(depth);
        
        switch (node.type) {
            case 'text':
                return node.value;
                
            case 'variable':
                console.log(`${indent} Evaluating variable: ${node.path}`);
                let value = this.getValue(data, node.path);
                console.log(`${indent} Value: ${value}`);
                
                // Apply formatters
                for (const formatter of node.formatters || []) {
                    value = this.applyFormatter(value, formatter);
                    console.log(`${indent} After ${formatter}: ${value}`);
                }
                
                return (value !== null && value !== undefined) ? String(value) : '';
                
            case 'each':
                console.log(`${indent}Evaluating each: ${node.itemVar} = ${node.arrayPath}`);
                const arrayData = this.getValue(data, node.arrayPath);
                console.log(`${indent}Array data:`, arrayData);
                
                if (!Array.isArray(arrayData)) {
                    console.warn(`${indent}Not an array:`, arrayData);
                    return '';
                }
                
                return arrayData.map((item, index) => {
                    const itemContext = {
                        ...data,
                        [node.itemVar]: item,
                        index: index,
                        first: index === 0,
                        last: index === arrayData.length - 1
                    };
                    
                    console.log(`${indent}Processing item ${index}:`, item);
                    console.log(`${indent}Context keys:`, Object.keys(itemContext));
                    return this.evaluate(node.children, itemContext, depth + 1);
                }).join('');
                
            case 'if':
                console.log(`${indent} Evaluating if: ${node.condition}`);
                const conditionValue = this.getValue(data, node.condition);
                const isTrue = this.isTruthy(conditionValue);
                console.log(`${indent} Condition result: ${isTrue}`);
                
                const childrenToEvaluate = isTrue ? node.ifChildren : node.elseChildren;
                return this.evaluate(childrenToEvaluate, data, depth + 1);
                
            default:
                throw new Error('Unknown node type: ' + node.type);
        }
    }

    /**
     * Get a value from data using dot notation
     */
    getValue(data, path) {
        if (!path || !data) return undefined;
        
        const parts = path.split('.');
        let current = data;
        
        for (const part of parts) {
            if (current === null || current === undefined) return undefined;
            current = current[part];
        }
        
        return current;
    }

    /**
     * Check if a value is truthy
     */
    isTruthy(value) {
        if (value === null || value === undefined) return false;
        if (typeof value === 'boolean') return value;
        if (typeof value === 'number') return value !== 0;
        if (typeof value === 'string') return value.length > 0;
        if (Array.isArray(value)) return value.length > 0;
        if (typeof value === 'object') return Object.keys(value).length > 0;
        return !!value;
    }

    /**
     * Apply a formatter to a value
     */
    applyFormatter(value, formatterExpression) {
        const match = formatterExpression.match(/^(\w+)(?:\s*\(\s*['"]?(.*?)['"]?\s*\))?$/);
        if (!match) return value;
        
        const [, formatterName, arg] = match;
        
        if (!this.formatters[formatterName]) {
            console.warn('Unknown formatter:', formatterName);
            return value;
        }
        
        try {
            return arg !== undefined 
                ? this.formatters[formatterName](value, arg)
                : this.formatters[formatterName](value);
        } catch (error) {
            console.warn('Formatter error:', formatterName, error);
            return value;
        }
    }

    // Keep all existing formatter methods...
    formatDate(dateValue, format) {
        const date = new Date(dateValue);
        if (isNaN(date.getTime())) return 'Invalid Date';

        const year = date.getFullYear();
        const month = date.getMonth();
        const day = date.getDate();
        const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

        let formatted = format.replace(/mmm/g, monthNames[month]);
        formatted = formatted
            .replace(/yyyy/g, year)
            .replace(/mm/g, String(month + 1).padStart(2, '0'))
            .replace(/dd/g, String(day).padStart(2, '0'));
        
        return formatted;
    }

    formatDuration(minutes) {
        if (isNaN(minutes) || minutes < 0) return '';
        const h = Math.floor(minutes / 60);
        const m = minutes % 60;
        let result = '';
        if (h > 0) result += `${h}h `;
        if (m > 0) result += `${m}m`;
        return result.trim();
    }

    escapeHtml(text) {
        if (text === null || text === undefined) return '';
        return String(text).replace(/[&<>"']/g, (match) => {
            return { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[match];
        });
    }

    escapeCsv(text) {
        if (text === null || text === undefined) return '';
        let str = String(text);
        if (str.includes(',') || str.includes('"') || str.includes('\n')) {
            return `"${str.replace(/"/g, '""')}"`;
        }
        return str;
    }

    cleanHashtags(text) {
        if (text === null || text === undefined) return '';
        return String(text).replace(/#([\w][\w-_]*)/g, (match, hashtag) => {
            return hashtag.replace(/[-_]/g, ' ');
        });
    }
}

window.TemplatingEngine = TemplatingEngine;
console.log('Templating Engine loaded (Tokenizer Version)');


// === report-templates.js ===
/**
 * Default report templates for the Activity Tracker.
 */
window.ReportTemplates = {
    'detailed-html': {
        name: 'Detailed Report (HTML)',
        description: 'A comprehensive HTML report with timings and full descriptions.',
        type: 'html',
        template: `<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <title>Activity Report: {{ report.startDate | date('dd/mm/yyyy') }} - {{ report.endDate | date('dd/mm/yyyy') }}</title>
    <style>
        body { font-family: sans-serif; line-height: 1.5; color: #333; }
        .report-container { max-width: 800px; margin: 20px auto; padding: 20px; border: 1px solid #ccc; border-radius: 8px; }
        .report-header { text-align: center; border-bottom: 2px solid #667eea; padding-bottom: 10px; margin-bottom: 20px; }
        .report-summary { background: #f0f2ff; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .day-group { margin-bottom: 20px; }
        .day-header { font-size: 1.2em; font-weight: bold; color: #667eea; border-bottom: 1px solid #ddd; padding-bottom: 5px; margin-bottom: 10px; }
        .entry { margin-bottom: 10px; padding-left: 15px; border-left: 3px solid #ccc; }
        .entry-time { font-weight: bold; }
        .entry-activity { font-size: 1.1em; }
        .entry-description { color: #555; font-style: italic; }
        .duration { font-size: 0.9em; color: #888; }
    </style>
</head>
<body>
    <div class="report-container">
        <div class="report-header">
            <h1>Activity Report</h1>
            <p>{{ report.startDate | date('dd mmm yyyy') }} to {{ report.endDate | date('dd mmm yyyy') }}</p>
        </div>
        <div class="report-summary">
            <h3>Report Summary</h3>
            <p><strong>Total Entries:</strong> {{ report.totalEntries }}</p>
            <p><strong>Total Duration:</strong> {{ report.totalDuration | duration }}</p>
            <p><strong>Active Days:</strong> {{ report.activeDays }}</p>
        </div>
        
        {{#each day = days}}
        <div class="day-group">
            <h2 class="day-header">{{ day.date }} ({{ day.entries.length }} entries, {{ day.totalDuration | duration }})</h2>
            {{#each entry = day.entries}}
            <div class="entry">
                <p><span class="entry-time">{{ entry.timestamp | time }}</span>: <span class="entry-activity">{{ entry.activity | cleanHashtags | escapeHtml }}</span></p>
                {{#if entry.description}}
                <div class="entry-description">{{ entry.description | cleanHashtags | markdown }}</div>
                {{/if}}
                <p class="duration">Duration: {{ entry.duration | duration }}</p>
            </div>
            {{/each}}
        </div>
        {{/each}}
    </div>
</body>
</html>`
    },
    'summary-markdown': {
        name: 'Summary (Markdown)',
        description: 'A summary report in Markdown, suitable for pasting into documents.',
        type: 'markdown',
        template: `# Activity Report

**Period:** {{ report.startDate | date('dd mmm yyyy') }} to {{ report.endDate | date('dd mmm yyyy') }}

## Summary
- **Total Entries:** {{ report.totalEntries }}
- **Total Duration:** {{ report.totalDuration | duration }}
- **Active Days:** {{ report.activeDays }}

---

{{#each day = days}}
## {{ day.date }} (Total: {{ day.totalDuration | duration }})
{{#each entry = day.entries}}
- **{{ entry.timestamp | time }} ({{ entry.duration | duration }})**: {{ entry.activity | cleanHashtags }}
{{/each}}
{{/each}}`
    },
    'basic-csv': {
        name: 'Basic Export (CSV)',
        description: 'A simple CSV file with core activity data.',
        type: 'csv',
        template: `Date,Time,Activity,Description
{{#each entry = entries}}{{ entry.timestamp | date('yyyy-mm-dd') }},{{ entry.timestamp | time }},{{ entry.activity | cleanHashtags | escapeCsv | stripLinebreaks }},{{ entry.description | cleanHashtags | escapeCsv | stripLinebreaks }}
{{/each}}`
    },
    'timed-csv': {
        name: 'Timed Export (CSV)',
        description: 'A detailed CSV file including calculated durations.',
        type: 'csv',
        template: `Date,StartTime,EndTime,DurationMinutes,Activity,Description
{{#each entry = entries}}{{ entry.timestamp | date('yyyy-mm-dd') }},{{ entry.timestamp | time }},{{ entry.endTime | time }},{{ entry.duration }},"{{ entry.activity | cleanHashtags | escapeCsv | stripLinebreaks }}","{{ entry.description | cleanHashtags | escapeCsv | stripLinebreaks }}"
{{/each}}`
    }
};


// === versionHistory.js ===
/**
 * Version History for Activity Tracker
 * Contains the last 5 major revisions with build versions and summaries
 */

const VERSION_HISTORY = [
    {
        commit: "24dacd7",
        date: "2025-08-05",
        summary: "Added complex schedule capabilities and renamed 'working schedule' to 'activity schedule' for generic terminology"
    },
    {
        commit: "5398868",
        date: "2025-08-05",
        summary: "Added comprehensive workspace system for organizing separate projects with isolated data, settings, and state"
    },
    {
        commit: "eccb96b",
        date: "2025-08-05",
        summary: "UI refactor with split Add/Reset buttons, flexible due date controls, system theme default, and reorganized settings"
    },
    {
        commit: "eb3cd3b",
        date: "2025-08-05",
        summary: "Enhanced mobile UI with hashtag autocompletion, improved form layouts, and better notification integration"
    },
    {
        commit: "b0709e0",
        date: "2025-08-04",
        summary: "Complete due date management system with overdue alerts, rescheduling, and smart prioritization"
    }
];

/**
 * Get the version history array
 * @returns {Array} Array of version history objects
 */
function getVersionHistory() {
    return VERSION_HISTORY;
}

/**
 * Get the current application version
 * @returns {string} Current version string
 */
function getCurrentVersion() {
    // This will be replaced by the build system with actual version
    return typeof APP_VERSION !== 'undefined' ? APP_VERSION : 'Development';
}

/**
 * Format version history for display
 * @returns {string} HTML formatted version history
 */
function formatVersionHistory() {
    const currentVersion = getCurrentVersion();
    let html = `<div class="version-current">
        <strong>Current Build:</strong> ${currentVersion}
    </div>
    <div class="version-history-list">
        <h5 style="margin: 16px 0 12px 0; color: #4a5568;">Recent Major Changes</h5>`;
    
    VERSION_HISTORY.forEach((entry, index) => {
        const isLatest = index === 0;
        const className = isLatest ? 'version-entry current' : 'version-entry';
        
        html += `<div class="${className}">
            <div class="version-header">
                <span class="version-number">${entry.commit}</span>
                <span class="version-date">${entry.date}</span>
            </div>
            <div class="version-summary">${entry.summary}</div>
        </div>`;
    });
    
    html += '</div>';
    return html;
}

// Export for use in other modules
if (typeof window !== 'undefined') {
    window.VersionHistory = {
        getVersionHistory,
        getCurrentVersion,
        formatVersionHistory
    };
}

console.log('Version History module loaded');

// === ActivityTracker.js ===
/**
 * Main ActivityTracker class
 * Handles all functionality for tracking activities, notifications, and reports
 */
class ActivityTracker {
    constructor() {
        // Initialize entries array from localStorage
        let entries = [];
        try {
            const storedEntries = JSON.parse(localStorage.getItem('activityEntries'));
            if (Array.isArray(storedEntries)) {
                entries = storedEntries.filter(entry => 
                    entry && typeof entry === 'object' && entry.timestamp
                ).map(entry => {
                    // Migrate existing entries to new schema
                    if (typeof entry.isTodo === 'undefined') {
                        entry.isTodo = false;
                    }
                    if (typeof entry.isNote === 'undefined') {
                        entry.isNote = false;
                    }
                    if (!entry.tags) {
                        entry.tags = [];
                    }
                    if (!entry.dueDate) {
                        entry.dueDate = null;
                    }
                    if (!entry.startedAt) {
                        entry.startedAt = null;
                    }
                    return entry;
                });
            }
        } catch (e) {
            console.error("Error parsing activity entries from localStorage", e);
            localStorage.removeItem('activityEntries');
        }
        this.entries = entries;

        // Define default settings
        this.defaultSettings = {
            notificationInterval: 60,
            startTime: '08:00',
            endTime: '18:00',
            workingDays: {
                monday: true,
                tuesday: true,
                wednesday: true,
                thursday: true,
                friday: true,
                saturday: false,
                sunday: false
            },
            // New complex schedule structure - each day can have multiple time ranges
            complexSchedule: {
                monday: [{ start: '09:00', end: '17:00' }],
                tuesday: [{ start: '09:00', end: '17:00' }],
                wednesday: [{ start: '09:00', end: '17:00' }],
                thursday: [{ start: '09:00', end: '17:00' }],
                friday: [{ start: '09:00', end: '17:00' }],
                saturday: [],
                sunday: []
            },
            useComplexSchedule: false, // Flag to use complex schedule instead of simple startTime/endTime
            pauseDuration: 60,
            notificationsPausedUntil: null,
            notificationsEnabled: true,
            autoStartAlerts: false,
            hasRequestedNotificationPermission: false, // Whether user has been asked about browser notifications
            sendSystemNotifications: true, // Whether to send system notifications (only applies if hasRequestedNotificationPermission is true)
            soundMuteMode: 'none', // 'none', 'all', 'pomodoro', 'notifications'
            notificationSoundType: "classic",
            darkModePreference: 'system', // 'light', 'dark', 'system'
            paginationSize: 20,
            warnOnActivityDelete: true,
            warnOnSessionReset: true
        };

        // Initialize settings with defaults
        this.settings = {
            ...this.defaultSettings,
            ...JSON.parse(localStorage.getItem('activitySettings') || '{}')
        };

        // Initialize state variables
        this.notificationTimer = null;
        this.currentReportEntries = [];
        this.currentWeekStart = null;
        this.soundManager = null;
        this.pauseManager = null;
        
        // Initialize application state
        this.state = this.loadState();
        
        // Initialize workspace system
        this.currentWorkspace = localStorage.getItem('currentWorkspace') || 'Default';
        this.initializeWorkspaces();

        this.init();
    }

    /**
     * Initialize the application
     */
    init() {
        this.loadSettings();
        this.migrateExistingEntries();
        this.initMarkdownRenderer();
        this.initReportTemplates();
        this.loadReportTemplatesIntoEditor();
        this.initTemplatePreviewGrid();
        this.displayEntries();
        this.displayTodos();
        this.displayNotes();
        this.updateNotificationStatus();
        this.updateDebugInfo();
        this.updatePauseButtonState();
        this.updateHeaderWorkspaceName();
        
        // Only start notifications if auto-start is enabled
        if (this.settings.autoStartAlerts) {
            this.startNotificationTimer();
        }
        this.setWeeklyReport();
        this.initSoundManager();
        this.initPauseManager();
        this.initPomodoroManager();
        
        // Event listeners
        this.attachEventListeners();
        this.initSearch();
        this.initHashtagCompletion();
        
        // Set current time by default
        this.setCurrentTime();
        
        // Check notification permissions on first run
        this.checkNotificationSetup();
        document.getElementById('activity').focus();

        // Check for local file protocol
        if (window.location.protocol === 'file:') {
            console.warn('Running from local file - notifications may have limitations');
        }
        
        // Initialize due date monitoring system
        if (typeof initializeDueDateSystem === 'function') {
            initializeDueDateSystem();
        }
    }

    /**
     * Migrate existing entries to add hashtags and update schema
     */
    migrateExistingEntries() {
        let needsSave = false;
        
        this.entries.forEach(entry => {
            if (!entry.tags || entry.tags.length === 0) {
                entry.tags = this.extractHashtags(entry.activity + ' ' + (entry.description || ''));
                needsSave = true;
            }
        });
        
        if (needsSave) {
            this.saveEntries();
            console.log('Migrated existing entries with hashtags');
        }
    }

    /**
     * Get current report templates, combining defaults with custom templates from localStorage.
     */
    getReportTemplates() {
        // Start with default templates
        const allTemplates = { ...(window.ReportTemplates || {}) };
        
        // Load and merge custom templates
        const customTemplatesData = localStorage.getItem('customReportTemplates');
        if (customTemplatesData) {
            try {
                const customTemplates = JSON.parse(customTemplatesData);
                Object.assign(allTemplates, customTemplates);
                console.log('Loaded custom templates:', Object.keys(customTemplates));
            } catch (e) {
                console.error("Error parsing custom report templates from localStorage", e);
            }
        }
        
        return allTemplates;
    }

    /**
     * Load the report templates into the editor in the settings page.
     */
    loadReportTemplatesIntoEditor() {
        const editorContainer = document.getElementById('report-templates-editor');
        if (!editorContainer) return;

        const templates = this.getReportTemplates();
        editorContainer.innerHTML = Object.keys(templates).map(key => `
            <div class="template-group">
                <label for="template-${key}">${templates[key].name}</label>
                <textarea id="template-${key}" data-key="${key}">${escapeHtml(templates[key].template)}</textarea>
            </div>
        `).join('');
    }

    /**
     * Save the report templates from the editor to localStorage.
     */
    saveReportTemplates() {
        const editorContainer = document.getElementById('report-templates-editor');
        if (!editorContainer) return;

        const customTemplates = this.getReportTemplates();
        const textareas = editorContainer.querySelectorAll('textarea');

        textareas.forEach(textarea => {
            const key = textarea.dataset.key;
            if (customTemplates[key]) {
                customTemplates[key].template = textarea.value;
            }
        });

        localStorage.setItem('reportTemplates', JSON.stringify(customTemplates));
        showNotification('Report templates saved successfully!', 'success');
        
        // Refresh report section to reflect changes
        this.initReportTemplates();
        if (this.currentReportData) {
            this.previewReport();
        }
    }

    /**
     * Reset report templates to their default values.
     */
    resetReportTemplates() {
        if (confirm('Are you sure you want to reset all report templates to their default values?')) {
            localStorage.removeItem('reportTemplates');
            this.loadReportTemplatesIntoEditor();
            this.initReportTemplates();
            if (this.currentReportData) {
                this.previewReport();
            }
            showNotification('Report templates have been reset to default.', 'success');
        }
    }

    /**
     * Initialize markdown renderer
     */
    initMarkdownRenderer() {
        try {
            this.markdownRenderer = new MarkdownRenderer();
        } catch (error) {
            console.warn('Markdown Renderer initialization failed:', error);
        }
    }

    /**
     * Initialize pause manager
     */
    initPauseManager() {
        try {
            this.pauseManager = new PauseManager(this);
        } catch (error) {
            console.warn('Pause Manager initialization failed:', error);
        }
    }

    /**
     * Attach event listeners to forms
     */
    attachEventListeners() {
        document.getElementById('activityForm').addEventListener('submit', (e) => {
            e.preventDefault();
            this.addEntry();
        });

        document.getElementById('editForm').addEventListener('submit', (e) => {
            e.preventDefault();
            this.updateEntry();
        });

        // Auto-save settings when changed
        this.attachSettingsListeners();
    }

    /**
     * Attach event listeners to settings inputs for auto-save
     */
    attachSettingsListeners() {
        const settingsInputs = [
            'notificationInterval',
            'startTime', 
            'endTime',
            'pauseDuration',
            'soundMuteMode',
            'notificationSoundType',
            'darkModePreference',
            'autoStartAlerts',
            'paginationSize',
            'pomodoroEnabled',
            'pomodoroWorkDuration',
            'pomodoroBreakDuration',
            'pomodoroLongBreakDuration', 
            'pomodoroLongBreakInterval',
            'pomodoroTickSound',
            'pomodoroTickInterval',
            'pomodoroShortBreakSound',
            'pomodoroLongBreakSound',
            'pomodoroResumeSound',
            'pomodoroAutoStart',
            'pomodoroAutoLog',
            'pomodoroLogBreaks',
            'pomodoroLongBreak',
            'warnOnActivityDelete',
            'warnOnSessionReset',
            'pomodoroPauseAllowed',
            'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'
        ];

        settingsInputs.forEach(inputId => {
            const element = document.getElementById(inputId);
            if (element) {
                let eventType;
                if (element.type === 'checkbox' || element.tagName.toLowerCase() === 'select') {
                    eventType = 'change';
                } else {
                    eventType = 'input';
                }
                element.addEventListener(eventType, () => {
                    this.autoSaveSettings();
                });
            }
        });
    }

    /**
     * Auto-save settings when inputs change
     */
    autoSaveSettings() {
        // Update settings from UI
        this.settings.notificationInterval = parseInt(document.getElementById('notificationInterval').value);
        this.settings.startTime = document.getElementById('startTime').value;
        this.settings.endTime = document.getElementById('endTime').value;
        this.settings.pauseDuration = parseInt(document.getElementById('pauseDuration').value);
        this.settings.soundMuteMode = document.getElementById('soundMuteMode').value;
        this.settings.notificationSoundType = document.getElementById('notificationSoundType').value;
        this.settings.darkModePreference = document.getElementById('darkModePreference').value;
        this.settings.autoStartAlerts = document.getElementById('autoStartAlerts')?.value === 'true';
        this.settings.paginationSize = parseInt(document.getElementById('paginationSize').value);
        this.settings.pomodoroAutoStart = document.getElementById('pomodoroAutoStart')?.checked || false;
        this.settings.pomodoroAutoLog = document.getElementById('pomodoroAutoLog')?.checked !== false;
        this.settings.pomodoroLogBreaks = document.getElementById('pomodoroLogBreaks')?.checked || false;

        // Update working days
        ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'].forEach(day => {
            this.settings.workingDays[day] = document.getElementById(day).checked;
        });

        // Apply theme immediately
        this.applyTheme();

        // Update pagination settings if pagination size changed
        if (document.getElementById('paginationSize')) {
            this.updatePaginationSettings();
        }

        // Save to localStorage (this will show "Settings saved successfully!")
        this.saveSettings();

        // Restart notification timer if interval changed
        if (this.settings.notificationsEnabled) {
            this.startNotificationTimer();
        }

        // Update about section to reflect changes
        this.updateDebugInfo();

        // Save Pomodoro settings if manager exists
        if (this.pomodoroManager) {
            this.pomodoroManager.saveSettings();
            this.pomodoroManager.loadSettings();
        }
    }

    /**
     * Initialize Web Audio API for notification sounds
     */
    initSoundManager() {
        try {
            this.soundManager = new SoundManager();
        } catch (error) {
            console.warn('Sound Manager failed to initialise:', error);
        }
    }

    /**
     * Check if notification sounds are muted
     */
    isNotificationSoundMuted() {
        return this.settings.soundMuteMode === 'all' || this.settings.soundMuteMode === 'notifications';
    }

    /**
     * Check if Pomodoro sounds are muted
     */
    isPomodoroSoundMuted() {
        return this.settings.soundMuteMode === 'all' || this.settings.soundMuteMode === 'pomodoro';
    }

    /**
     * Play notification sound
     */
    playNotificationSound() {
        if (this.soundManager) {
            this.soundManager.playSound(this.settings.notificationSoundType, this.isNotificationSoundMuted());
        }
    }

    /**
     * Test notification sound
     */
    testNotificationSound() {
        if (this.soundManager) {
            const isMuted = this.isNotificationSoundMuted();
            
            if (isMuted) {
                let muteReason = 'Sound is muted because: ';
                const reasons = [];
                
                if (this.settings.muteSound) {
                    reasons.push('Global sound is disabled in Settings');
                }
                if (this.isOutsideWorkingHours()) {
                    reasons.push('Currently outside activity hours');
                }
                if (this.pomodoroManager && this.pomodoroManager.isActive()) {
                    reasons.push('Pomodoro mode is active');
                }
                
                muteReason += reasons.join(', ');
                alert(muteReason + '\n\nTo hear test sounds, please adjust your settings or check the time.');
                return;
            }
            
            this.soundManager.playSound(this.settings.notificationSoundType, false);
            showNotification('Test sound played!', 'success');
        } else {
            alert('Sound manager is not available');
        }
    }

    /**
     * Add a new activity entry
     * @param {Object} entry - Optional pre-formed entry object
     */
    addEntry(entry) {
        let newEntry = entry;
        if (!newEntry) {
            const activity = document.getElementById('activity').value;
            const description = document.getElementById('description').value;
            const timestamp = document.getElementById('timestamp').value;
            const isTodo = isTodoModeActive();
            const isNote = isNoteModeActive();
            const dueDate = document.getElementById('dueDate')?.value || null;

            // Extract hashtags from text and add pomodoro hashtags if active
            const extractedTags = this.extractHashtags(activity + ' ' + (description || ''));
            const pomodoroTags = this.generatePomodoroHashtags();
            const allTags = [...new Set([...extractedTags, ...pomodoroTags])];
            
            newEntry = {
                id: generateId(),
                activity,
                description,
                timestamp: new Date(timestamp).toISOString(),
                created: new Date().toISOString(),
                isTodo: isTodo,
                isNote: isNote,
                tags: allTags,
                dueDate: dueDate ? new Date(dueDate).toISOString() : null,
                startedAt: isTodo ? new Date(timestamp).toISOString() : null
            };
        } else if (entry.source === 'pomodoro') {
            const pomodoroTags = this.generatePomodoroHashtags();
            const allTags = [...new Set([...(entry.tags || []), ...pomodoroTags])];
            newEntry.tags = allTags;
        }

        // Development mode: Check for debug palette override flags
        this.validateDebugModeFlags(newEntry.tags);

        this.entries.unshift(newEntry);
        this.saveEntries();
        this.displayEntries();
        this.displayTodos();
        this.displayNotes();

        if (!entry) {
            document.getElementById('activityForm').reset();
            // Reset todo mode button
            const todoBtn = document.getElementById('todoToggleBtn');
            if (todoBtn) {
                todoBtn.classList.remove('active');
                todoBtn.textContent = 'Mark as Todo';
            }
            
            // Reset note mode button
            const noteBtn = document.getElementById('noteToggleBtn');
            if (noteBtn) {
                noteBtn.classList.remove('active');
                noteBtn.textContent = 'Mark as Note';
            }
            this.setCurrentTime();
            document.getElementById('activity').focus();
        }
        
        showNotification('Entry added successfully!', 'success');
    }

    /**
     * Update an existing entry
     */
    updateEntry() {
        const id = document.getElementById('editId').value;
        const activity = document.getElementById('editActivity').value;
        const description = document.getElementById('editDescription').value;
        const timestamp = document.getElementById('editTimestamp').value;
        const todoButton = document.getElementById('editTodoButton');
        const isTodo = todoButton ? todoButton.dataset.isTodo === 'true' : false;
        const noteButton = document.getElementById('editNoteButton');
        const isNote = noteButton ? noteButton.dataset.isNote === 'true' : false;
        const dueDate = document.getElementById('editDueDate').value;

        const entryIndex = this.entries.findIndex(entry => entry.id === id);
        if (entryIndex !== -1) {
            const existingEntry = this.entries[entryIndex];
            
            // Extract hashtags from text and add pomodoro hashtags if active
            const extractedTags = this.extractHashtags(activity + ' ' + (description || ''));
            const pomodoroTags = this.generatePomodoroHashtags();
            const allTags = [...extractedTags, ...pomodoroTags];
            
            this.entries[entryIndex] = {
                ...existingEntry,
                activity,
                description,
                timestamp: new Date(timestamp).toISOString(),
                isTodo,
                isNote,
                tags: allTags,
                dueDate: dueDate ? new Date(dueDate).toISOString() : null,
                // Preserve startedAt if it exists, or set it if becoming a todo
                startedAt: isTodo ? (existingEntry.startedAt || new Date(timestamp).toISOString()) : existingEntry.startedAt
            };
            
            this.saveEntries();
            this.displayEntries();
            this.displayTodos();
            this.displayNotes();
            this.closeEditModal();
            showNotification('Entry updated successfully!', 'success');
        }
    }

    /**
     * Delete an entry
     * @param {string} id - Entry ID to delete
     */
    deleteEntry(id) {
        const entry = this.entries.find(e => e.id === id);
        if (!entry) return;
        
        // Check warning settings
        if (this.settings.warnOnActivityDelete) {
            showConfirmationDialog(
                'Delete Activity',
                `Are you sure you want to delete "${entry.activity}"? This action can be undone.`,
                (skipFuture) => {
                    if (skipFuture) {
                        this.settings.warnOnActivityDelete = false;
                        // Update the form element to reflect the change
                        const warnDeleteElement = document.getElementById('warnOnActivityDelete');
                        if (warnDeleteElement) {
                            warnDeleteElement.value = 'false';
                        }
                        this.saveSettings();
                    }
                    this.performDeletion(id);
                },
                {
                    confirmText: 'Delete',
                    buttonClass: 'btn-danger',
                    allowSkip: true
                }
            );
        } else {
            this.performDeletion(id);
        }
    }
    
    /**
     * Perform the actual deletion after confirmation
     */
    performDeletion(id) {
        const entry = this.entries.find(e => e.id === id);
        if (!entry) return;
        
        // Add to undo buffer
        this.addToUndoBuffer(entry);
        
        // Remove from entries
        this.entries = this.entries.filter(e => e.id !== id);
        this.saveEntries();
        this.displayEntries();
        this.displayTodos();
        this.displayNotes();
        
        showNotification('Entry deleted successfully! <button onclick="tracker.undoLastDeletion()" class="undo-btn">Undo</button>', 'success', 5000);
    }
    
    /**
     * Add deleted entry to undo buffer
     */
    addToUndoBuffer(entry) {
        // Ensure state and deletedEntriesBuffer are initialized
        if (!this.state) {
            this.state = this.loadState();
        }
        if (!this.state.deletedEntriesBuffer) {
            this.state.deletedEntriesBuffer = [];
        }
        
        // Add deleted entry with timestamp
        const deletedEntry = {
            ...entry,
            deletedAt: new Date().toISOString()
        };
        
        this.state.deletedEntriesBuffer.unshift(deletedEntry);
        
        // Keep only last 5 deleted entries
        if (this.state.deletedEntriesBuffer.length > 5) {
            this.state.deletedEntriesBuffer = this.state.deletedEntriesBuffer.slice(0, 5);
        }
        
        // Save state
        this.saveState();
    }
    
    /**
     * Undo the last deletion
     */
    undoLastDeletion() {
        // Ensure state and deletedEntriesBuffer are initialized
        if (!this.state) {
            this.state = this.loadState();
        }
        if (!this.state.deletedEntriesBuffer) {
            this.state.deletedEntriesBuffer = [];
        }
        
        if (this.state.deletedEntriesBuffer.length === 0) {
            showNotification('No deletions to undo', 'info');
            return;
        }
        
        const lastDeleted = this.state.deletedEntriesBuffer.shift();
        delete lastDeleted.deletedAt; // Remove the deletion timestamp
        
        // Check if entry with same ID already exists
        if (this.entries.find(e => e.id === lastDeleted.id)) {
            // Generate new ID to avoid conflicts
            lastDeleted.id = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        }
        
        // Add back to entries
        this.entries.unshift(lastDeleted);
        this.saveEntries();
        this.displayEntries();
        this.displayTodos();
        this.displayNotes();
        
        // Update state
        this.saveState();
        
        showNotification(`Restored "${lastDeleted.activity}"`, 'success');
    }
    
    /**
     * Get undo buffer for display purposes
     */
    getUndoBuffer() {
        return this.deletedEntriesBuffer.map(entry => ({
            id: entry.id,
            activity: entry.activity,
            description: entry.description,
            timestamp: entry.timestamp,
            deletedAt: entry.deletedAt
        }));
    }

    /**
     * Edit an entry (open modal)
     * @param {string} id - Entry ID to edit
     */
    editEntry(id) {
        const entry = this.entries.find(entry => entry.id === id);
        if (entry) {
            document.getElementById('editId').value = entry.id;
            document.getElementById('editActivity').value = entry.activity;
            
            // Check if entry has tags that aren't already in activity/description text
            let description = entry.description || '';
            if (entry.tags && entry.tags.length > 0) {
                const existingText = entry.activity + ' ' + description;
                const existingTags = this.extractHashtags(existingText);
                const missingTags = entry.tags.filter(tag => !existingTags.includes(tag));
                
                // Add missing tags to description to preserve them during editing
                if (missingTags.length > 0) {
                    const tagString = missingTags.map(tag => `#${tag}`).join(' ');
                    description = description ? `${description} ${tagString}` : tagString;
                }
            }
            
            document.getElementById('editDescription').value = description;
            document.getElementById('editTimestamp').value = 
                new Date(entry.timestamp).toISOString().slice(0, 16);
            
            // Update todo button state
            this.setEditTodoButtonState(entry.isTodo || false);
            
            // Update note button state
            this.setEditNoteButtonState(entry.isNote || false);
            
            document.getElementById('editDueDate').value = 
                entry.dueDate ? new Date(entry.dueDate).toISOString().slice(0, 16) : '';
            
            document.getElementById('editModal').style.display = 'block';
        }
    }
    
    /**
     * Set the edit todo button state
     */
    setEditTodoButtonState(isTodo) {
        const button = document.getElementById('editTodoButton');
        const buttonText = document.getElementById('editTodoButtonText');
        const editDueDateSection = document.getElementById('editDueDateSection');
        
        if (button && buttonText) {
            button.dataset.isTodo = isTodo.toString();
            if (isTodo) {
                button.classList.add('active');
                buttonText.textContent = 'Remove from Todos';
                // Show due date section when in todo mode
                if (editDueDateSection) {
                    editDueDateSection.style.display = 'block';
                }
            } else {
                button.classList.remove('active');
                buttonText.textContent = 'Mark as Todo';
                // Hide due date section when not in todo mode
                if (editDueDateSection) {
                    editDueDateSection.style.display = 'none';
                }
            }
        }
    }

    /**
     * Set the edit note button state
     */
    setEditNoteButtonState(isNote) {
        const button = document.getElementById('editNoteButton');
        const buttonText = document.getElementById('editNoteButtonText');
        
        if (button && buttonText) {
            button.dataset.isNote = isNote.toString();
            if (isNote) {
                button.classList.add('active');
                buttonText.textContent = 'Remove from Notes';
            } else {
                button.classList.remove('active');
                buttonText.textContent = 'Mark as Note';
            }
        }
    }

    /**
     * Close the edit modal
     */
    closeEditModal() {
        document.getElementById('editModal').style.display = 'none';
    }

    /**
     * Display entries in the UI
     */
    displayEntries() {
        const container = document.getElementById('entriesList');
        
        // Initialize entries pagination if it doesn't exist
        if (!this.entriesPagination) {
            this.entriesPagination = {
                currentPage: 1,
                itemsPerPage: this.settings.paginationSize || 20
            };
        }
        
        // Update pagination size if settings changed
        this.entriesPagination.itemsPerPage = this.settings.paginationSize || 20;
        
        // Sort entries with overdue items first
        const sortedEntries = this.getSortedEntriesWithOverduePriority();
        
        // Calculate pagination
        const startIndex = (this.entriesPagination.currentPage - 1) * this.entriesPagination.itemsPerPage;
        const endIndex = startIndex + this.entriesPagination.itemsPerPage;
        const paginatedEntries = sortedEntries.slice(startIndex, endIndex);

        if (paginatedEntries.length === 0) {
            container.innerHTML = '<p>No entries yet. Add your first activity above!</p>';
            return;
        }

        container.innerHTML = paginatedEntries.map(entry => this.renderEntry(entry, { showTodoIndicator: true, showNoteIndicator: true })).join('');
        
        // Update pagination controls
        this.updateEntriesPagination(sortedEntries.length);
    }

    /**
     * Get entries sorted with overdue items prioritized first
     */
    getSortedEntriesWithOverduePriority() {
        const now = new Date();
        const overdueEntries = this.entries.filter(entry => entry.dueDate && entry.isTodo && new Date(entry.dueDate) < now);
        const regularEntries = this.entries.filter(entry => !entry.dueDate || !entry.isTodo || new Date(entry.dueDate) >= now);

        // Sort overdue entries by how overdue they are (most overdue first)
        const sortedOverdue = overdueEntries.sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate));
        // Keep regular entries in their original order (newest first, which is the default)
        const sortedRegular = regularEntries;

        // Return overdue items first, then regular items
        return [...sortedOverdue, ...sortedRegular];
    }

    /**
     * Unified entry rendering method used by both main entries and todo sections
     * @param {Object} entry - The entry to render
     * @param {Object} options - Rendering options
     * @returns {string} HTML string for the entry
     */
    renderEntry(entry, options = {}) {
        const {
            showTodoIndicator = false,
            showNoteIndicator = false,
            showCreatedTime = false
        } = options;

        const now = new Date();
        const isOverdue = entry.isTodo && entry.dueDate && new Date(entry.dueDate) < now;
        const isTodo = entry.isTodo;
        
        let itemClass = 'entry-item';
        if (isTodo) {
            itemClass += isOverdue ? ' entry-todo entry-overdue' : ' entry-todo';
        }
        
        // Generate human-friendly due date display (only show if item is currently a todo)
        let dueDateHtml = '';
        if (entry.dueDate && isTodo && typeof formatTimeUntilDue === 'function') {
            const countdownText = formatTimeUntilDue(entry.dueDate);
            if (countdownText) {
                const isOverdueItem = typeof isOverdue === 'function' && isOverdue(entry.dueDate);
                const badgeClass = isOverdueItem ? 'due-badge-overdue' : 'due-badge-normal';
                dueDateHtml = `<div class="entry-due-date"><span class="due-countdown-badge ${badgeClass}">${countdownText}</span></div>`;
            }
        } else if (entry.dueDate && isTodo) {
            // Fallback to formatted date if countdown functions aren't available (only for todos)
            dueDateHtml = `<div class="entry-due-date">Due: ${formatDateTime(entry.dueDate)}</div>`;
        }

        // For todo section, show created time instead of timestamp, and optionally show todo indicator
        const timeToShow = showCreatedTime && entry.created ? entry.created : entry.timestamp;
        const todoIndicator = (showTodoIndicator && entry.isTodo) ? '<span class="entry-todo-indicator"> Todo</span>' : '';
        const noteIndicator = (showNoteIndicator && entry.isNote) ? '<span class="entry-note-indicator"> Note</span>' : '';

        // Process description with inline hashtags
        const processedDescription = entry.description ? this.renderDescriptionWithInlineHashtags(entry.description, entry.tags) : '';

        return `
            <div class="${itemClass}">
                <div class="entry-content">
                    <div class="entry-time">${formatDateTime(timeToShow)} ${todoIndicator}${noteIndicator}</div>
                    <div class="entry-activity">${escapeHtml(entry.activity)}</div>
                    ${processedDescription ? `<div class="entry-description">${processedDescription}</div>` : ''}
                    ${dueDateHtml}
                </div>
                <div class="entry-actions">
                    ${entry.isTodo ? `<button class="btn btn-success btn-small" onclick="tracker.completeEntry('${entry.id}')" title="Mark as completed">Mark Complete</button>` : ''}
                    <button class="btn btn-secondary btn-small" onclick="tracker.editEntry('${entry.id}')">Edit</button>
                    <button class="btn btn-danger btn-small" onclick="tracker.deleteEntry('${entry.id}')">Delete</button>
                </div>
            </div>
        `;
    }

    /**
     * Render description text as markdown
     * @param {string} description - Description text
     * @returns {string} HTML string
     */
    renderDescriptionMarkdown(description) {
        // Initialize markdown renderer if not already done
        if (!this.markdownRenderer && typeof MarkdownRenderer !== 'undefined') {
            this.initMarkdownRenderer();
        }

        if (this.markdownRenderer && description) {
            return this.markdownRenderer.renderInlineWithClasses(description);
        }
        return escapeHtml(description);
    }

    /**
     * Render description with inline hashtag links and add missing tags
     * @param {string} description - The entry description
     * @param {Array} entryTags - The tags associated with this entry
     * @returns {string} Processed description with clickable hashtags
     */
    renderDescriptionWithInlineHashtags(description, entryTags = []) {
        // Start with the description, adding missing tags if needed
        let fullText = description;
        
        // Check if entry has tags that aren't already in the description
        if (entryTags && entryTags.length > 0) {
            const existingTags = this.extractHashtags(description);
            const missingTags = entryTags.filter(tag => !existingTags.includes(tag));
            
            // Add missing tags to the end of the description
            if (missingTags.length > 0) {
                const tagString = missingTags.map(tag => `#${tag}`).join(' ');
                fullText = fullText ? `${fullText} ${tagString}` : tagString;
            }
        }
        
        // First apply markdown rendering
        let processedText = this.renderDescriptionMarkdown(fullText);
        
        // Convert URLs to clickable links first (before hashtags to avoid conflicts)
        processedText = processedText.replace(/(https?:\/\/[^\s<>"\[\]]+)/gi, (match, url) => {
            return `<a href="${url}" target="_blank" rel="noopener noreferrer" class="external-link">${url}</a>`;
        });
        
        // Then replace hashtags with clickable links (but not inside HTML tags)
        // Use negative lookbehind to avoid matching hashtags inside href attributes
        processedText = processedText.replace(/(?<!href="[^"]*|href='[^']*)#([\w][\w-]*)/g, (match, tag) => {
            return `<a href="#" class="hashtag-link" onclick="tracker.searchByHashtag('${tag}'); return false;">#${tag}</a>`;
        });
        
        return processedText;
    }

    /**
     * Save entries to localStorage
     */
    saveEntries() {
        localStorage.setItem('activityEntries', JSON.stringify(this.entries));
    }

    /**
     * Save settings
     */
    saveSettings() {
        try {
            this.settings = {
            ...this.settings,
            notificationInterval: parseInt(document.getElementById('notificationInterval').value),
            startTime: document.getElementById('startTime').value,
            endTime: document.getElementById('endTime').value,
            pauseDuration: parseInt(document.getElementById('pauseDuration').value),
            soundMuteMode: document.getElementById('soundMuteMode').value,
            notificationSoundType: document.getElementById('notificationSoundType').value,
            darkModePreference: document.getElementById('darkModePreference').value,
            autoStartAlerts: document.getElementById('autoStartAlerts')?.value === 'true',
            hasRequestedNotificationPermission: this.settings.hasRequestedNotificationPermission, // Don't override this from form
            sendSystemNotifications: document.getElementById('sendSystemNotifications')?.value === 'true',
            paginationSize: parseInt(document.getElementById('paginationSize').value),
            warnOnActivityDelete: document.getElementById('warnOnActivityDelete')?.value === 'true',
            warnOnSessionReset: document.getElementById('warnOnSessionReset')?.value === 'true',
            workingDays: {
                monday: document.getElementById('monday').checked,
                tuesday: document.getElementById('tuesday').checked,
                wednesday: document.getElementById('wednesday').checked,
                thursday: document.getElementById('thursday').checked,
                friday: document.getElementById('friday').checked,
                saturday: document.getElementById('saturday').checked,
                sunday: document.getElementById('sunday').checked
            },
            // Pomodoro settings
            pomodoroEnabled: document.getElementById('pomodoroEnabled')?.checked || false,
            pomodoroWorkDuration: parseInt(document.getElementById('pomodoroWorkDuration')?.value) || 25,
            pomodoroBreakDuration: parseInt(document.getElementById('pomodoroBreakDuration')?.value) || 5,
            pomodoroAutoStart: document.getElementById('pomodoroAutoStart')?.checked || false,
            pomodoroAutoLog: document.getElementById('pomodoroAutoLog')?.checked !== false,
            pomodoroLogBreaks: document.getElementById('pomodoroLogBreaks')?.checked || false,
            pomodoroLongBreak: document.getElementById('pomodoroLongBreak')?.checked || false,
            pomodoroPauseAllowed: document.getElementById('pomodoroPauseAllowed')?.checked !== false
        };

            localStorage.setItem('activitySettings', JSON.stringify(this.settings));
            this.applyTheme();
            this.startNotificationTimer();
            
            // Update Pomodoro manager if it exists
            if (this.pomodoroManager) {
                this.pomodoroManager.saveSettings();
                this.pomodoroManager.loadSettings();
            }
            
            // Update pause manager to reflect new activity schedule
            if (this.pauseManager) {
                this.pauseManager.updatePauseButtonDisplay();
            }
            
            // Also save any pending template changes
            if (this.templateManagerState && this.templateManagerState.hasUnsavedChanges) {
                this.saveTemplatesQuietly();
            }
            
            // Update pagination settings and refresh displays
            this.updatePaginationSettings();
            
            // Settings saved silently - only show notifications on errors
        } catch (error) {
            console.error('Error saving settings:', error);
            showNotification('Failed to save settings. Please try again.', 'error');
        }
    }

    /**
     * Check if browser supports notifications and handle first-run setup
     */
    checkNotificationSetup() {
        // Skip if user has already been asked or notifications aren't supported
        if (this.settings.hasRequestedNotificationPermission || !this.isNotificationSupported()) {
            this.updateSystemNotificationsVisibility();
            return;
        }
        
        // Show first-run notification permission dialog
        setTimeout(() => {
            this.showNotificationPermissionDialog();
        }, 1000); // Small delay to let app finish loading
    }

    /**
     * Check if the current environment supports notifications
     */
    isNotificationSupported() {
        // Check for file:// protocol
        if (window.location.protocol === 'file:') {
            return false;
        }
        
        // Check for Notification API
        if (!('Notification' in window)) {
            return false;
        }
        
        // Additional checks for mobile browsers that claim support but don't really work
        const userAgent = navigator.userAgent.toLowerCase();
        
        // iOS Safari has limited notification support
        if (/iphone|ipad|ipod/.test(userAgent) && /safari/.test(userAgent) && !/chrome|crios|fxios/.test(userAgent)) {
            return false;
        }
        
        return true;
    }

    /**
     * Show notification permission setup dialog
     */
    showNotificationPermissionDialog() {
        const modal = document.getElementById('notificationPermissionModal');
        if (modal) {
            modal.style.display = 'block';
        }
    }

    /**
     * Handle user requesting notification permission
     */
    async requestNotificationPermission() {
        try {
            const permission = await Notification.requestPermission();
            
            // Mark that we've asked the user
            this.settings.hasRequestedNotificationPermission = true;
            
            if (permission === 'granted') {
                this.settings.sendSystemNotifications = true;
                showNotification('System notifications enabled! You\'ll receive reminders through your operating system.', 'success');
            } else {
                this.settings.sendSystemNotifications = false;
                showNotification('System notifications disabled. You\'ll still receive sound alerts within the app.', 'info');
            }
            
            this.saveSettings();
            this.updateSystemNotificationsVisibility();
            this.closeNotificationPermissionDialog();
            
        } catch (error) {
            console.error('Error requesting notification permission:', error);
            this.declineNotificationPermission();
        }
    }

    /**
     * Handle user declining notification permission
     */
    declineNotificationPermission() {
        this.settings.hasRequestedNotificationPermission = true;
        this.settings.sendSystemNotifications = false;
        
        this.saveSettings();
        this.updateSystemNotificationsVisibility();
        this.closeNotificationPermissionDialog();
        
        showNotification('Sound alerts enabled. You can enable system notifications later in General Settings.', 'info');
    }

    /**
     * Close notification permission dialog
     */
    closeNotificationPermissionDialog() {
        const modal = document.getElementById('notificationPermissionModal');
        if (modal) {
            modal.style.display = 'none';
        }
    }

    /**
     * Update visibility of system notifications setting
     */
    updateSystemNotificationsVisibility() {
        const systemNotificationsGroup = document.getElementById('systemNotificationsGroup');
        
        if (systemNotificationsGroup) {
            if (this.settings.hasRequestedNotificationPermission && this.isNotificationSupported()) {
                systemNotificationsGroup.style.display = 'block';
            } else {
                systemNotificationsGroup.style.display = 'none';
            }
        }
    }

    /**
     * Force enable notification capability (for diagnostics)
     */
    forceEnableNotificationCapability() {
        this.settings.hasRequestedNotificationPermission = false;
        this.saveSettings();
        this.showNotificationPermissionDialog();
    }

    /**
     * Toggle activity reminders on/off
     */
    toggleActivityReminders() {
        if (this.settings.notificationsEnabled) {
            // Turn off reminders
            this.settings.notificationsEnabled = false;
            this.stopNotificationTimer();
            showNotification('Activity reminders turned off', 'info');
        } else {
            // Turn on reminders
            this.settings.notificationsEnabled = true;
            this.startNotificationTimer();
            showNotification('Activity reminders turned on', 'success');
        }
        
        this.saveSettings();
        this.updateNotificationStatus();
        this.updatePauseButtonState();
    }

    /**
     * Load application state from localStorage or create default state
     */
    loadState() {
        try {
            const stateJson = localStorage.getItem('activityState');
            if (stateJson) {
                return JSON.parse(stateJson);
            }
        } catch (error) {
            console.warn('Error loading state from localStorage:', error);
        }
        
        // Return default state structure
        return {
            // Undo buffer for deletions (max 5 items)
            deletedEntriesBuffer: [],
            
            // Pomodoro session state
            pomodoro: {
                isRunning: false,
                isPaused: false,
                currentPhase: null, // 'work' or 'break'
                sessionNumber: 0,
                startTime: null,
                originalDuration: null,
                remainingTime: null,
                pausedAt: null,
                workActivity: null, // {name, description}
                cycleCount: 0,
                totalSessions: 0
            },
            
            // Current activity being worked on (not yet logged)
            currentActivity: {
                name: '',
                description: '',
                startTime: null,
                tags: []
            },
            
            // Todo state
            todos: {
                currentTodo: null,
                completedSinceLastLog: []
            },
            
            timestamp: Date.now()
        };
    }

    /**
     * Save application state to localStorage
     */
    saveState() {
        // Update timestamp
        this.state.timestamp = Date.now();
        
        // Save to localStorage alongside other app data
        localStorage.setItem('activityState', JSON.stringify(this.state));
        
        console.log('State saved:', this.state);
    }

    /**
     * Clear application state from localStorage
     */
    clearState() {
        localStorage.removeItem('activityState');
        this.state = this.loadState();
    }

    /**
     * Update pomodoro state and save
     */
    updatePomodoroState(updates) {
        this.state.pomodoro = { ...this.state.pomodoro, ...updates };
        this.saveState();
    }

    /**
     * Update pagination settings and refresh displays
     */
    updatePaginationSettings() {
        const newSize = this.settings.paginationSize || 20;
        
        // Update entries pagination
        if (this.entriesPagination) {
            this.entriesPagination.itemsPerPage = newSize;
            this.entriesPagination.currentPage = 1; // Reset to first page
        }
        
        // Update todo pagination
        if (this.todoPagination) {
            this.todoPagination.itemsPerPage = newSize;
            this.todoPagination.currentPage = 1; // Reset to first page
        }
        
        // Update notes pagination
        if (this.notesPagination) {
            this.notesPagination.itemsPerPage = newSize;
            this.notesPagination.currentPage = 1; // Reset to first page
        }
        
        // Update search pagination
        if (this.searchState && this.searchState.searchPagination) {
            this.searchState.searchPagination.itemsPerPage = newSize;
            this.searchState.searchPagination.currentPage = 1; // Reset to first page
        }
        
        // Refresh displays
        this.displayEntries();
        this.displayTodos();
        this.displayNotes();
        
        // Refresh search results if there's an active search
        if (this.searchState && this.searchState.currentQuery) {
            this.performSearch(this.searchState.currentQuery);
        }
    }

    /**
     * Load settings into the UI
     */
    loadSettings() {
        document.getElementById('notificationInterval').value = this.settings.notificationInterval;
        document.getElementById('startTime').value = this.settings.startTime;
        document.getElementById('endTime').value = this.settings.endTime;
        document.getElementById('pauseDuration').value = this.settings.pauseDuration;
        document.getElementById('soundMuteMode').value = this.settings.soundMuteMode;
        document.getElementById('darkModePreference').value = this.settings.darkModePreference;
        document.getElementById('autoStartAlerts').value = this.settings.autoStartAlerts.toString();
        document.getElementById('paginationSize').value = this.settings.paginationSize;
        document.getElementById('sendSystemNotifications').value = this.settings.sendSystemNotifications.toString();
        document.getElementById('warnOnActivityDelete').value = this.settings.warnOnActivityDelete.toString();
        document.getElementById('warnOnSessionReset').value = this.settings.warnOnSessionReset.toString();
        
        // Populate sound dropdowns with all available sounds
        this.populateSoundDropdowns();
        
        Object.entries(this.settings.workingDays).forEach(([day, checked]) => {
            document.getElementById(day).checked = checked;
        });
        
        // Initialize complex schedule toggle and UI
        const useComplexScheduleEl = document.getElementById('useComplexSchedule');
        if (useComplexScheduleEl) {
            useComplexScheduleEl.checked = this.settings.useComplexSchedule || false;
            // Initialize the schedule mode display
            if (typeof toggleScheduleMode === 'function') {
                const simpleSchedule = document.getElementById('simpleSchedule');
                const complexSchedule = document.getElementById('complexSchedule');
                if (this.settings.useComplexSchedule) {
                    if (simpleSchedule) simpleSchedule.style.display = 'none';
                    if (complexSchedule) complexSchedule.style.display = 'block';
                    // Populate complex schedule if function is available
                    if (typeof populateComplexSchedule === 'function') {
                        populateComplexSchedule();
                    }
                } else {
                    if (simpleSchedule) simpleSchedule.style.display = 'block';
                    if (complexSchedule) complexSchedule.style.display = 'none';
                }
            }
        }
        
        // Update system notifications visibility
        this.updateSystemNotificationsVisibility();

        this.applyTheme();
    }
    
    /**
     * Populate all sound dropdowns with available sounds
     */
    populateSoundDropdowns() {
        const soundDropdowns = [
            { id: 'notificationSoundType', selectedValue: this.settings.notificationSoundType },
            { id: 'pomodoroShortBreakSound', selectedValue: this.settings.pomodoroShortBreakSound || 'gentle' },
            { id: 'pomodoroLongBreakSound', selectedValue: this.settings.pomodoroLongBreakSound || 'bell' },
            { id: 'pomodoroResumeSound', selectedValue: this.settings.pomodoroResumeSound || 'digital' }
        ];
        
        soundDropdowns.forEach(({ id, selectedValue }) => {
            const dropdown = document.getElementById(id);
            if (dropdown && typeof generateSoundOptions === 'function') {
                dropdown.innerHTML = generateSoundOptions([], selectedValue);
            }
        });
    }

    /**
     * Apply the current theme (light/dark)
     */
    applyTheme() {
        let shouldUseDarkMode = false;
        
        switch (this.settings.darkModePreference) {
            case 'dark':
                shouldUseDarkMode = true;
                break;
            case 'light':
                shouldUseDarkMode = false;
                break;
            case 'system':
                // Check system preference
                shouldUseDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                break;
            default:
                shouldUseDarkMode = false;
        }
        
        if (shouldUseDarkMode) {
            document.body.classList.add('dark-mode');
        } else {
            document.body.classList.remove('dark-mode');
        }
        
        // Listen for system preference changes if using system mode
        if (this.settings.darkModePreference === 'system') {
            if (!this.systemThemeListener) {
                this.systemThemeListener = (e) => {
                    if (this.settings.darkModePreference === 'system') {
                        this.applyTheme();
                    }
                };
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', this.systemThemeListener);
            }
        }
    }

    /**
     * Toggle notifications on/off
     */
    async enableNotifications() {
        if (!('Notification' in window) || !('serviceWorker' in navigator)) {
            alert('This browser does not support notifications or service workers.');
            this.updateDebugInfo();
            return;
        }

        // If notifications are currently enabled, disable them
        if (this.settings.notificationsEnabled && Notification.permission === 'granted') {
            this.settings.notificationsEnabled = false;
            this.saveSettings();
            this.stopNotificationTimer();
            showNotification('Notifications disabled', 'success');
            this.updateNotificationStatus();
            this.updateDebugInfo();
            return;
        }

        // If notifications are disabled, enable them
        try {
            console.log('Requesting notification permission...');
            const permission = await Notification.requestPermission();
            console.log('Permission result:', permission);
            
            if (permission === 'granted') {
                this.settings.notificationsEnabled = true;
                this.saveSettings();
                showNotification('Notifications enabled successfully!', 'success');
                this.startNotificationTimer();
                
                setTimeout(() => {
                    this.testNotification(true);
                }, 1000);
            } else if (permission === 'denied') {
                showNotification('Notifications were denied. Please check your browser settings and try again.', 'error');
            } else {
                showNotification('Notification permission was not granted. Please try again.', 'error');
            }
            
            setTimeout(() => {
                this.updateNotificationStatus();
                this.updateDebugInfo();
            }, 500);
        } catch (error) {
            console.error('Error requesting notification permission:', error);
            showNotification('Error requesting notification permission: ' + error.message, 'error');
            this.updateDebugInfo();
        }
    }

    /**
     * Show notification with fallback support
     * @param {string} title - Notification title
     * @param {Object} options - Notification options
     */
    async showNotificationWithServiceWorker(title, options) {
        if (!('Notification' in window)) {
            console.warn('Notifications not supported');
            return;
        }

        // Check if system notifications are disabled in settings
        if (!this.settings.sendSystemNotifications) {
            console.log('System notifications disabled in settings, skipping notification');
            return;
        }

        if (Notification.permission !== 'granted') {
            console.warn('Notification permission not granted');
            return;
        }

        try {
            // Try service worker approach first
            if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                const registration = await navigator.serviceWorker.ready;
                await registration.showNotification(title, options);
                console.log('Notification shown via Service Worker');
                return;
            }
        } catch (error) {
            console.warn('Service Worker notification failed, falling back to direct notification:', error);
        }

        // Fallback: Use direct Notification API (limited functionality)
        try {
            // Remove service worker specific options for fallback
            const fallbackOptions = {
                body: options.body,
                icon: options.icon,
                tag: options.tag,
                requireInteraction: options.requireInteraction
                // Note: actions are not supported in direct notifications
            };

            const notification = new Notification(title, fallbackOptions);
            
            // Handle click events for fallback notifications
            notification.onclick = () => {
                window.focus();
                notification.close();
            };

            console.log('Notification shown via direct API (limited features)');
            
            // Auto-close after some time if not set to require interaction
            if (!options.requireInteraction) {
                setTimeout(() => {
                    notification.close();
                }, 5000);
            }

        } catch (directError) {
            console.error('Both Service Worker and direct notification failed:', directError);
            
            // Last resort: show in-app notification
            showNotification('Activity reminder: ' + (options.body || 'Time to log your activity!'), 'info', 8000);
        }
    }

    /**
     * Test notification
     * @param {boolean} isAutoTest - Whether this is an automatic test
     */
    testNotification(isAutoTest = false) {
        // First, check if Notification API is available at all
        if (typeof Notification === 'undefined') {
            if (!isAutoTest) {
                showNotification('This browser does not support notifications.', 'error');
            }
            // Still play the sound to test the sound system
            this.playNotificationSound();
            this.updateDebugInfo();
            return;
        }

        console.log('Testing notification, permission:', Notification.permission);
        this.updateDebugInfo();
        
        // Play sound regardless of notification permission
        this.playNotificationSound();
        
        if (Notification.permission !== 'granted') {
            if (!isAutoTest) {
                showNotification('Please enable notifications first! Current permission: ' + Notification.permission, 'error');
            }
            return;
        }

        try {
            // Use the same notification as regular activity reminders, just with a different body text
            const options = {
                body: 'This is a test notification. What are you working on right now?',
                icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23667eea"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>',
                tag: 'activity-reminder', // Use the same tag as regular notifications
                requireInteraction: true,
                actions: [
                    { action: 'reply', type: 'text', title: 'Log Activity', placeholder: 'What are you working on?' }
                ]
            };
            this.showNotificationWithServiceWorker('Activity Tracker Reminder', options);

            if (!isAutoTest) {
                showNotification('Test notification sent successfully!', 'success');
            }
            console.log('Test notification created successfully');
        } catch (error) {
            console.error('Error creating test notification:', error);
            showNotification('Error creating test notification: ' + error.message, 'error');
            this.updateDebugInfo();
        }
    }

    /**
     * Refresh notification status
     */
    refreshNotificationStatus() {
        this.updateNotificationStatus();
        this.updateDebugInfo();
        showNotification('Notification status refreshed', 'success');
    }

    /**
     * Update notification status display
     */
    updateNotificationStatus() {
        const statusEl = document.getElementById('notificationStatus');
        const indicatorEl = document.getElementById('statusIndicator');
        const textEl = document.getElementById('statusText');
        const enableBtn = document.querySelector('button[onclick="enableNotifications()"]');

        console.log('Updating notification status, reminders enabled:', this.settings.notificationsEnabled, 'system notifications:', this.settings.sendSystemNotifications);

        if (this.settings.notificationsEnabled) {
            // Activity reminders are ON
            statusEl.className = 'notification-status notification-enabled';
            indicatorEl.className = 'status-indicator status-active';
            
            if (this.settings.hasRequestedNotificationPermission && this.settings.sendSystemNotifications && Notification.permission === 'granted') {
                textEl.textContent = 'Activity reminders active with system notifications';
            } else {
                textEl.textContent = 'Activity reminders active with sound alerts';
            }
            
            if (enableBtn) enableBtn.textContent = 'Turn off activity reminders';
        } else {
            // Activity reminders are OFF
            statusEl.className = 'notification-status notification-warning';
            indicatorEl.className = 'status-indicator status-inactive';
            textEl.textContent = 'Activity reminders are disabled';
            if (enableBtn) enableBtn.textContent = 'Turn on activity reminders';
        }

        // Special case for unsupported browsers
        if (!this.isNotificationSupported()) {
            if (this.settings.notificationsEnabled) {
                textEl.textContent = 'Activity reminders active with sound alerts only';
            } else {
                textEl.textContent = 'Activity reminders are disabled';
            }
        }
    }

    /**
     * Show reminder countdown banner
     */
    showReminderBanner() {
        const banner = document.getElementById('statusBanner');
        const reminderSection = document.getElementById('reminderStatusSection');
        
        if (!banner || !reminderSection || !this.settings.notificationsEnabled) {
            return;
        }

        // Check if we should show the banner based on activity hours/days
        if (this.shouldShowReminderCountdown()) {
            banner.style.display = 'block';
            reminderSection.style.display = 'flex';
        } else {
            reminderSection.style.display = 'none';
            
            // Hide the entire banner if no sections are visible
            const pomodoroSection = document.getElementById('pomodoroStatusSection');
            if (pomodoroSection && pomodoroSection.style.display === 'none') {
                banner.style.display = 'none';
            }
        }
    }

    /**
     * Get the next working time from a given date
     * @param {Date} fromTime - Starting time to search from
     * @returns {Date|null} Next activity time or null if no activity days scheduled
     */
    getNextWorkingTime(fromTime) {
        const workDayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
        const currentTime = fromTime.getHours() * 60 + fromTime.getMinutes();
        const currentDayName = workDayNames[fromTime.getDay()];
        
        // Check if there's a working period later today
        if (this.settings.workingDays[currentDayName]) {
            if (this.settings.useComplexSchedule && this.settings.complexSchedule && this.settings.complexSchedule[currentDayName]) {
                const ranges = this.settings.complexSchedule[currentDayName];
                // Find the next range that starts after current time
                for (const range of ranges) {
                    const [startHour, startMin] = range.start.split(':').map(Number);
                    const startTime = startHour * 60 + startMin;
                    if (startTime > currentTime) {
                        const nextTime = new Date(fromTime);
                        nextTime.setHours(startHour, startMin, 0, 0);
                        return nextTime;
                    }
                }
            } else {
                // Simple schedule
                const [startHour, startMin] = this.settings.startTime.split(':').map(Number);
                const startTime = startHour * 60 + startMin;
                if (startTime > currentTime) {
                    const nextTime = new Date(fromTime);
                    nextTime.setHours(startHour, startMin, 0, 0);
                    return nextTime;
                }
            }
        }
        
        // Check future days (up to 7 days ahead)
        for (let daysAhead = 1; daysAhead <= 7; daysAhead++) {
            const futureDate = new Date(fromTime);
            futureDate.setDate(futureDate.getDate() + daysAhead);
            futureDate.setHours(0, 0, 0, 0);
            
            const futureDayName = workDayNames[futureDate.getDay()];
            if (this.settings.workingDays[futureDayName]) {
                if (this.settings.useComplexSchedule && this.settings.complexSchedule && this.settings.complexSchedule[futureDayName]) {
                    const ranges = this.settings.complexSchedule[futureDayName];
                    if (ranges.length > 0) {
                        const [startHour, startMin] = ranges[0].start.split(':').map(Number);
                        futureDate.setHours(startHour, startMin, 0, 0);
                        return futureDate;
                    }
                } else {
                    // Simple schedule
                    const [startHour, startMin] = this.settings.startTime.split(':').map(Number);
                    futureDate.setHours(startHour, startMin, 0, 0);
                    return futureDate;
                }
            }
        }
        
        return null; // No working periods found
    }

    /**
     * Check if current time is within activity hours
     * @param {Date} [time] - Optional time to check, defaults to current time
     * @returns {boolean} True if within activity hours
     */
    isWithinWorkingHours(time = new Date()) {
        const currentTime = time.getHours() * 60 + time.getMinutes();
        const dayName = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'][time.getDay()];

        // Check if it's a working day (always check this first)
        if (!this.settings.workingDays[dayName]) {
            return false;
        }

        // Use complex schedule if enabled
        if (this.settings.useComplexSchedule && this.settings.complexSchedule && this.settings.complexSchedule[dayName]) {
            const ranges = this.settings.complexSchedule[dayName];
            if (!ranges || ranges.length === 0) {
                return false; // No activity hours defined for this day
            }

            // Check if current time falls within any of the defined ranges
            return ranges.some(range => {
                const [startHour, startMin] = range.start.split(':').map(Number);
                const [endHour, endMin] = range.end.split(':').map(Number);
                const startTime = startHour * 60 + startMin;
                const endTime = endHour * 60 + endMin;
                return currentTime >= startTime && currentTime <= endTime;
            });
        } else {
            // Fall back to simple start/end time
            const [startHour, startMin] = this.settings.startTime.split(':').map(Number);
            const [endHour, endMin] = this.settings.endTime.split(':').map(Number);
            const startTime = startHour * 60 + startMin;
            const endTime = endHour * 60 + endMin;
            return currentTime >= startTime && currentTime <= endTime;
        }
    }

    /**
     * Check if reminder countdown should be displayed
     */
    shouldShowReminderCountdown() {
        if (!this.settings.notificationsEnabled) {
            return false;
        }

        // Check if reminders are paused
        if (this.settings.notificationsPausedUntil) {
            const now = new Date().getTime();
            if (now < this.settings.notificationsPausedUntil) {
                return true; // Show "Paused" status
            }
        }

        const now = new Date();
        const currentTime = now.getHours() * 60 + now.getMinutes();
        const dayName = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'][now.getDay()];

        // Check if it's a working day
        if (!this.settings.workingDays[dayName]) {
            return false;
        }

        // Check if currently within activity hours
        if (this.isWithinWorkingHours(now)) {
            return true;
        }

        // Also show if close to start time (within 2 hours) - for simple schedule only
        if (!this.settings.useComplexSchedule) {
            const [startHour, startMin] = this.settings.startTime.split(':').map(Number);
            const startTime = startHour * 60 + startMin;
            return currentTime < startTime && (startTime - currentTime) <= 120;
        }

        return false;
    }

    /**
     * Hide reminder countdown banner
     */
    hideReminderBanner() {
        const reminderSection = document.getElementById('reminderStatusSection');
        if (reminderSection) {
            reminderSection.style.display = 'none';
        }
        
        // Hide the entire banner if no sections are visible
        const pomodoroSection = document.getElementById('pomodoroStatusSection');
        const banner = document.getElementById('statusBanner');
        if (banner && pomodoroSection && 
            reminderSection.style.display === 'none' && 
            pomodoroSection.style.display === 'none') {
            banner.style.display = 'none';
        }
    }

    /**
     * Start notification countdown display
     */
    startNotificationCountdown() {
        if (this.notificationCountdownTimer) {
            clearInterval(this.notificationCountdownTimer);
        }

        // Update immediately
        this.showReminderBanner();
        this.updateNotificationCountdown();

        // Update every second
        this.notificationCountdownTimer = setInterval(() => {
            this.showReminderBanner(); // Check banner visibility every second
            this.updateNotificationCountdown();
            // Update pause button state to reflect activity schedule changes
            if (this.pauseManager) {
                this.pauseManager.updatePauseButtonDisplay();
            }
        }, 1000);
    }

    /**
     * Update reminder countdown display
     */
    updateNotificationCountdown() {
        const timeRemainingEl = document.getElementById('reminderTimeRemaining');
        if (!timeRemainingEl || !this.settings.notificationsEnabled) {
            return;
        }

        // Check if reminders are paused
        if (this.settings.notificationsPausedUntil) {
            const now = new Date().getTime();
            if (now < this.settings.notificationsPausedUntil) {
                timeRemainingEl.textContent = 'Paused';
                return;
            }
        }

        const now = new Date();
        const currentTime = now.getHours() * 60 + now.getMinutes();
        const dayName = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'][now.getDay()];

        // Check if it's a working day
        if (!this.settings.workingDays[dayName]) {
            timeRemainingEl.textContent = 'Not working day';
            return;
        }

        // Check if currently within activity hours
        if (this.isWithinWorkingHours(now)) {
            // Calculate time until next break or end of work
            if (this.notificationTimer) {
                const nextReminder = new Date(this.state.nextReminderTime || Date.now() + this.settings.notificationInterval * 60000);
                const minutesUntil = Math.max(0, Math.ceil((nextReminder - now) / 60000));
                timeRemainingEl.textContent = `Next reminder in ${minutesUntil}m`;
            } else {
                timeRemainingEl.textContent = 'Ready to start';
            }
            return;
        }

        // Not currently in activity hours - find next activity period
        const nextWorkTime = this.getNextWorkingTime(now);
        if (nextWorkTime) {
            const minutesUntil = Math.ceil((nextWorkTime - now) / 60000);
            const hoursUntil = Math.floor(minutesUntil / 60);
            const minutesRemaining = minutesUntil % 60;
            
            if (minutesUntil < 60) {
                timeRemainingEl.textContent = `Work starts in ${minutesUntil}m`;
            } else if (hoursUntil < 24) {
                timeRemainingEl.textContent = `Work starts in ${hoursUntil}h ${minutesRemaining}m`;
            } else {
                const daysUntil = Math.floor(hoursUntil / 24);
                timeRemainingEl.textContent = `Next work day in ${daysUntil} day${daysUntil !== 1 ? 's' : ''}`;
            }
        } else {
            timeRemainingEl.textContent = 'No activity days scheduled';
        }

        // We're in activity hours - calculate time until next reminder based on actual last reminder time
        const lastReminderTime = localStorage.getItem('lastNotificationTime');
        const intervalMs = this.settings.notificationInterval * 60 * 1000;
        
        if (!lastReminderTime || intervalMs <= 0) {
            timeRemainingEl.textContent = 'Ready for reminder';
            return;
        }

        const timeSinceLastReminder = now.getTime() - parseInt(lastReminderTime);
        const timeUntilNextReminder = intervalMs - timeSinceLastReminder;

        if (timeUntilNextReminder <= 0) {
            timeRemainingEl.textContent = 'Ready for reminder';
            return;
        }

        // Convert milliseconds to hours, minutes, seconds
        const totalSeconds = Math.ceil(timeUntilNextReminder / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        // Format time display
        let timeText;
        if (hours > 0) {
            timeText = `${hours}h ${minutes}m ${seconds}s`;
        } else if (minutes > 0) {
            timeText = `${minutes}m ${seconds}s`;
        } else {
            timeText = `${seconds}s`;
        }

        timeRemainingEl.textContent = timeText;
    }

    /**
     * Update about information display
     */
    updateDebugInfo() {
        const debugEl = document.getElementById('debugText');
        if (!debugEl) {
            // Element doesn't exist (removed from UI), skip debug info update
            console.log('Debug info element not found, skipping update');
            return;
        }
        
        const info = [];
        
        // Application version
        info.push(`Version: ${typeof APP_VERSION !== 'undefined' ? APP_VERSION : 'Unknown'}`);
        info.push('');
        
        info.push(`Browser: ${navigator.userAgent.split(' ').slice(-2).join(' ')}`);
        info.push(`Platform: ${navigator.platform || 'Unknown'}`);
        info.push(`Protocol: ${window.location.protocol}`);
        info.push(`Notification API: ${'Notification' in window ? 'Available' : 'Not Available'}`);
        
        if ('Notification' in window) {
            info.push(`Permission: ${Notification.permission}`);
            info.push(`Max Actions: ${Notification.maxActions || 'Unknown'}`);
        }
        
        // Enhanced Service Worker diagnostics
        if ('serviceWorker' in navigator) {
            info.push(`Service Worker: Available`);
            
            if (navigator.serviceWorker.controller) {
                info.push(`SW State: ${navigator.serviceWorker.controller.state}`);
                info.push(`SW URL: ${navigator.serviceWorker.controller.scriptURL.split('/').pop()}`);
            } else {
                info.push(`SW State: No controller`);
            }
            
            // Check registration status
            navigator.serviceWorker.getRegistration().then(registration => {
                if (registration) {
                    const scopeInfo = document.getElementById('debugText');
                    if (scopeInfo && scopeInfo.innerHTML.includes('SW Scope: Checking...')) {
                        scopeInfo.innerHTML = scopeInfo.innerHTML.replace('SW Scope: Checking...', `SW Scope: ${registration.scope}`);
                    }
                }
            }).catch(error => {
                console.warn('SW registration check failed:', error);
            });
            
            info.push(`SW Scope: Checking...`);
        } else {
            info.push(`Service Worker: Not Available`);
            if (window.location.protocol === 'file:') {
                info.push(`SW Reason: file:// protocol (expected)`);
            }
        }
        
        info.push(`Audio Support: ${this.soundManager && this.soundManager.audioContext ? 'Yes' : 'No'}`);
        info.push(`Sound Settings: ${this.settings.soundMuteMode === 'none' ? 'All enabled' : this.settings.soundMuteMode}`);
        info.push(`Sound Type: ${this.settings.notificationSoundType}`);
        info.push(`Last Updated: ${new Date().toLocaleTimeString('en-GB')}`);
        
        debugEl.innerHTML = info.join('<br>');
    }

    /**
     * Update version history display in About modal
     */
    updateVersionHistory() {
        const versionContainer = document.getElementById('versionHistoryContainer');
        if (!versionContainer) return;
        
        // Check if VersionHistory module is available
        if (typeof window.VersionHistory !== 'undefined') {
            versionContainer.innerHTML = window.VersionHistory.formatVersionHistory();
        } else {
            versionContainer.innerHTML = '<p>Version history not available.</p>';
        }
    }

    /**
     * Update debug info and version history for the About modal
     */
    async updateAboutDebugInfo() {
        // Update version history
        this.updateVersionHistory();
        
        // Continue with debug info
        const debugEl = document.getElementById('aboutDebugInfo');
        if (!debugEl) return;
        
        const info = [];
        
        // Application version
        info.push(`<strong>Version:</strong> ${typeof APP_VERSION !== 'undefined' ? APP_VERSION : 'Unknown'}`);
        info.push('');
        
        info.push(`<strong>Browser:</strong> ${navigator.userAgent.split(' ').slice(-2).join(' ')}`);
        info.push(`<strong>Platform:</strong> ${navigator.platform || 'Unknown'}`);
        info.push(`<strong>Protocol:</strong> ${window.location.protocol}`);
        info.push('');
        
        info.push(`<strong>Notification API:</strong> ${'Notification' in window ? 'Available' : 'Not Available'}`);
        if ('Notification' in window) {
            info.push(`<strong>Permission:</strong> ${Notification.permission}`);
            info.push(`<strong>Max Actions:</strong> ${Notification.maxActions || 'Unknown'}`);
        }
        info.push('');
        
        // Enhanced Service Worker diagnostics
        if ('serviceWorker' in navigator) {
            info.push(`<strong>Service Worker:</strong> Available`);
            
            if (navigator.serviceWorker.controller) {
                info.push(`<strong>SW State:</strong> ${navigator.serviceWorker.controller.state}`);
                info.push(`<strong>SW URL:</strong> ${navigator.serviceWorker.controller.scriptURL.split('/').pop()}`);
            } else {
                info.push(`<strong>SW State:</strong> No controller`);
            }
            
            // Check registration status with proper await
            try {
                const registration = await navigator.serviceWorker.getRegistration();
                if (registration) {
                    info.push(`<strong>SW Scope:</strong> ${registration.scope}`);
                } else {
                    info.push(`<strong>SW Scope:</strong> No registration`);
                }
            } catch (error) {
                console.warn('SW registration check failed:', error);
                info.push(`<strong>SW Scope:</strong> Check failed`);
            }
        } else {
            info.push(`<strong>Service Worker:</strong> Not Available`);
            if (window.location.protocol === 'file:') {
                info.push(`<strong>SW Reason:</strong> file:// protocol (expected)`);
            }
        }
        info.push('');
        
        info.push(`<strong>Audio Support:</strong> ${this.soundManager && this.soundManager.audioContext ? 'Yes' : 'No'}`);
        info.push(`<strong>Sound Settings:</strong> ${this.settings.soundMuteMode === 'none' ? 'All enabled' : this.settings.soundMuteMode}`);
        info.push(`<strong>Sound Type:</strong> ${this.settings.notificationSoundType}`);
        info.push(`<strong>Last Updated:</strong> ${new Date().toLocaleTimeString('en-GB')}`);
        
        debugEl.innerHTML = info.join('<br>');
    }

    /**
     * Comprehensive service worker diagnostics
     */
    async runServiceWorkerDiagnostics() {
        const diagnostics = {
            available: 'serviceWorker' in navigator,
            protocol: window.location.protocol,
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            registration: null,
            controller: null,
            error: null
        };

        if (!diagnostics.available) {
            diagnostics.error = 'Service Worker API not available';
            return diagnostics;
        }

        try {
            // Check current registration
            diagnostics.registration = await navigator.serviceWorker.getRegistration();
            diagnostics.controller = navigator.serviceWorker.controller;

            // Test communication if controller exists
            if (diagnostics.controller) {
                try {
                    const messageChannel = new MessageChannel();
                    const response = await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => reject(new Error('SW communication timeout')), 5000);
                        
                        messageChannel.port1.onmessage = (event) => {
                            clearTimeout(timeout);
                            resolve(event.data);
                        };
                        
                        diagnostics.controller.postMessage(
                            { type: 'GET_VERSION' }, 
                            [messageChannel.port2]
                        );
                    });
                    
                    diagnostics.communication = 'Working';
                    diagnostics.swVersion = response.version;
                } catch (commError) {
                    diagnostics.communication = `Failed: ${commError.message}`;
                }
            }

        } catch (error) {
            diagnostics.error = error.message;
        }

        return diagnostics;
    }

    /**
     * Start notification timer
     */
    startNotificationTimer() {
        if (this.notificationTimer) {
            clearInterval(this.notificationTimer);
        }
        
        if (this.notificationCountdownTimer) {
            clearInterval(this.notificationCountdownTimer);
        }

        this.notificationTimer = setInterval(() => {
            this.checkAndTriggerActivityReminder();
        }, 60000); // Check every minute
        
        // Start countdown display timer (updates every second)
        this.startNotificationCountdown();
        this.showReminderBanner();
    }

    /**
     * Stop notification timer
     */
    stopNotificationTimer() {
        if (this.notificationTimer) {
            clearInterval(this.notificationTimer);
            this.notificationTimer = null;
        }
        
        if (this.notificationCountdownTimer) {
            clearInterval(this.notificationCountdownTimer);
            this.notificationCountdownTimer = null;
        }
        
        this.hideReminderBanner();
    }

    /**
     * Check if a reminder (sound and/or notification) should be triggered.
     */
    checkAndTriggerActivityReminder() {
        // Check if reminders are disabled by user setting. This is the master switch.
        if (!this.settings.notificationsEnabled) {
            console.log('Skipping reminder check - reminders disabled by user');
            return;
        }

        // Check if notifications are paused
        if (this.settings.notificationsPausedUntil) {
            const now = new Date().getTime();
            if (now < this.settings.notificationsPausedUntil) {
                console.log('Reminders are paused.');
                return;
            } else {
                this.unpauseNotifications(false);
            }
        }

        const now = new Date();
        const currentTime = now.getHours() * 60 + now.getMinutes();
        const dayName = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'][now.getDay()];

        // Check if it's a working day
        if (!this.settings.workingDays[dayName]) {
            console.log('Skipping reminder - not a working day');
            return;
        }

        // Check if it's within activity hours using new method
        if (!this.isWithinWorkingHours(now)) {
            console.log('Skipping reminder - outside activity hours');
            return;
        }

        // Check if enough time has passed since last reminder
        const lastReminderTime = localStorage.getItem('lastNotificationTime');
        const timeSinceLastReminder = now.getTime() - (lastReminderTime || 0);
        const intervalMs = this.settings.notificationInterval * 60 * 1000;

        if (intervalMs > 0 && timeSinceLastReminder >= intervalMs) {
            console.log('Triggering activity reminder.');
            
            // Always play the sound if a reminder is due
            this.playNotificationSound();
            
            // Only show a visual notification if the API is available and permission is granted
            const canShowNotification = typeof Notification !== 'undefined' && Notification.permission === 'granted';
            if (canShowNotification) {
                console.log('Sending scheduled notification');
                this.showActivityReminderNotification();
            }
            
            localStorage.setItem('lastNotificationTime', now.getTime().toString());
        }
    }

    /**
     * Show activity reminder visual notification.
     */
    showActivityReminderNotification() {
        this.setCurrentTime();
        
        try {
            const options = {
                body: 'What are you working on right now?',
                icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23667eea"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>',
                tag: 'activity-reminder',
                requireInteraction: true,
                actions: [
                    { action: 'reply', type: 'text', title: 'Log Activity', placeholder: 'What are you working on?' }
                ]
            };
            this.showNotificationWithServiceWorker('Activity Tracker Reminder', options);
        } catch (error) {
            console.error('Error showing activity reminder notification:', error);
        }
    }

    /**
     * Set current time in the timestamp input
     */
    setCurrentTime() {
        const timestamp = document.getElementById('timestamp');
        if (timestamp) {
            timestamp.value = getCurrentTimeForInput();
        }
    }

    /**
     * Initialize Pomodoro Manager
     */
    initPomodoroManager() {
        if (typeof PomodoroManager !== 'undefined') {
            this.pomodoroManager = new PomodoroManager(this);
            
            // Restore pomodoro state from application state
            if (this.state.pomodoro) {
                this.pomodoroManager.restoreFromState(this.state.pomodoro);
            }
            
            console.log('Pomodoro Manager initialized');
        } else {
            console.warn('PomodoroManager class not found');
        }
    }

    /**
     * Toggle start/stop notifications
     * @param {boolean} showNotif - Whether to show notification
     */
    togglePause(showNotif = true) {
        if (this.pauseManager) {
            if (this.pauseManager.isPaused()) {
                // Currently paused, so resume
                this.pauseManager.resume();
            } else {
                // Not paused, so start pause with default duration
                this.pauseManager.startPause(this.settings.pauseDuration);
            }
        } else {
            // Fallback to old behavior if PauseManager isn't available
            if (this.settings.notificationsEnabled) {
                // Stop notifications
                this.settings.notificationsEnabled = false;
                this.stopNotificationTimer();
                if (showNotif) {
                    showNotification('Reminders stopped', 'info');
                }
            } else {
                // Start notifications
                this.settings.notificationsEnabled = true;
                this.startNotificationTimer();
                if (showNotif) {
                    showNotification('Reminders started', 'success');
                }
            }
            
            this.updatePauseButtonState();
            this.saveSettings();
            this.updateNotificationStatus();
            this.updateDebugInfo();
        }
    }

    /**
     * Unpause notifications
     * @param {boolean} showNotification - Whether to show notification
     */
    unpauseNotifications(showNotif = true) {
        this.settings.notificationsPausedUntil = null;
        if (showNotif) {
            showNotification('Notifications resumed', 'success');
        }
        this.updatePauseButtonState();
        this.saveSettings();
    }

    /**
     * Update pause button state
     */
    updatePauseButtonState() {
        if (this.pauseManager) {
            this.pauseManager.updatePauseButtonDisplay();
        }
    }

    /**
     * Clear all data
     */
    clearAllData() {
        if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
            localStorage.removeItem('activityEntries');
            localStorage.removeItem('activitySettings');
            localStorage.removeItem('lastNotificationTime');
            this.entries = [];
            this.currentReportEntries = [];
            this.displayEntries();
            document.getElementById('reportPreview').innerHTML = '';
            showNotification('All data cleared successfully!', 'success');
        }
    }

    /**
     * Export database as JSON backup file
     */
    exportDatabase() {
        try {
            // Export all workspaces instead of just current data
            this.exportAllWorkspaces();
            showNotification('All workspaces exported successfully!', 'success');
        } catch (error) {
            console.error('Error exporting database:', error);
            showNotification('Error exporting database: ' + error.message, 'error');
        }
    }

    /**
     * Import database from JSON backup file
     */
    importDatabase(fileData) {
        try {
            const backupData = JSON.parse(fileData);
            
            // Validate backup data structure
            if (!backupData.entries || !Array.isArray(backupData.entries)) {
                throw new Error('Invalid backup file: missing or invalid entries data');
            }

            // Confirm import action
            const entriesCount = backupData.entries.length;
            const backupDate = backupData.timestamp ? new Date(backupData.timestamp).toLocaleDateString('en-GB') : 'unknown date';
            
            if (!confirm(`Import ${entriesCount} entries from backup created on ${backupDate}? This will replace all current data.`)) {
                return;
            }

            // Validate entries format
            const validEntries = backupData.entries.filter(entry => 
                entry && typeof entry === 'object' && entry.timestamp
            );

            if (validEntries.length !== backupData.entries.length) {
                console.warn(`Filtered out ${backupData.entries.length - validEntries.length} invalid entries`);
            }

            // Import data
            this.entries = validEntries;
            localStorage.setItem('activityEntries', JSON.stringify(this.entries));

            // Import settings if available
            if (backupData.settings && typeof backupData.settings === 'object') {
                this.settings = { ...this.settings, ...backupData.settings };
                localStorage.setItem('activitySettings', JSON.stringify(this.settings));
                this.loadSettings(); // Reload settings UI
            }

            // Import state if available
            if (backupData.state && typeof backupData.state === 'object') {
                this.state = { ...this.state, ...backupData.state };
                localStorage.setItem('activityState', JSON.stringify(this.state));
                console.log('State imported:', this.state);
            }

            // Update display
            this.displayEntries();
            this.currentReportEntries = [];
            document.getElementById('reportPreview').innerHTML = '';

            showNotification(`Database imported successfully! Restored ${validEntries.length} entries.`, 'success');
        } catch (error) {
            console.error('Error importing database:', error);
            showNotification('Error importing database: ' + error.message, 'error');
        }
    }

    /**
     * Initialize template preview grid in settings - removed as no longer needed
     */
    initTemplatePreviewGrid() {
        // No longer needed - template preview grid removed from settings
    }

    /**
     * Open template manager overlay
     */
    openTemplateManager() {
        this.templateManagerState = {
            templates: { ...this.getReportTemplates() },
            currentTemplateId: null,
            hasUnsavedChanges: false,
            originalTemplates: { ...this.getReportTemplates() }
        };

        const overlay = document.getElementById('templateManagerOverlay');
        if (overlay) {
            overlay.classList.add('active');
            this.populateTemplateList();
            this.clearTemplateEditor();
        }
    }

    /**
     * Close template manager overlay
     */
    closeTemplateManager() {
        if (this.templateManagerState && this.templateManagerState.hasUnsavedChanges) {
            if (!confirm('You have unsaved changes. Are you sure you want to close without saving?')) {
                return;
            }
        }

        const overlay = document.getElementById('templateManagerOverlay');
        if (overlay) {
            overlay.classList.remove('active');
        }
        
        this.templateManagerState = null;
    }

    /**
     * Populate template list in manager
     */
    populateTemplateList() {
        const templateList = document.getElementById('templateList');
        if (!templateList || !this.templateManagerState) return;

        const templates = this.templateManagerState.templates;
        const defaultTemplate = this.settings.defaultTemplate || 'detailed-html';
        
        templateList.innerHTML = '';
        
        Object.keys(templates).forEach(templateId => {
            const template = templates[templateId];
            const isDefault = templateId === defaultTemplate;
            const isActive = templateId === this.templateManagerState.currentTemplateId;
            
            const item = document.createElement('div');
            item.className = `template-list-item ${isActive ? 'active' : ''} ${isDefault ? 'default' : ''}`;
            item.onclick = () => this.selectTemplate(templateId);
            
            item.innerHTML = `
                <div class="template-list-item-name">${template.name}</div>
                <div class="template-list-item-desc">${template.description}</div>
                <div class="template-list-item-type">${template.type}</div>
            `;
            
            templateList.appendChild(item);
        });
    }

    /**
     * Select template for editing
     */
    selectTemplate(templateId) {
        if (this.templateManagerState && this.templateManagerState.hasUnsavedChanges) {
            if (!confirm('You have unsaved changes. Continue without saving?')) {
                return;
            }
        }

        this.templateManagerState.currentTemplateId = templateId;
        this.templateManagerState.hasUnsavedChanges = false;
        
        this.populateTemplateList();
        this.loadTemplateIntoEditor(templateId);
        this.refreshTemplatePreview();
    }

    /**
     * Load template into editor form
     */
    loadTemplateIntoEditor(templateId) {
        const template = this.templateManagerState.templates[templateId];
        if (!template) return;

        document.getElementById('templateEditorTitle').textContent = `Editing: ${template.name}`;
        document.getElementById('templateEditorActions').style.display = 'flex';
        document.getElementById('templateEditorTabs').style.display = 'flex';
        
        // Show editor tab by default
        this.switchTemplateTab('editor');

        document.getElementById('templateName').value = template.name;
        document.getElementById('templateDescription').value = template.description;
        document.getElementById('templateType').value = template.type;
        document.getElementById('templateContent').value = template.template;
        
        const defaultTemplate = this.settings.defaultTemplate || 'detailed-html';
        document.getElementById('templateIsDefault').checked = templateId === defaultTemplate;

        // Add change listeners
        ['templateName', 'templateDescription', 'templateType', 'templateContent', 'templateIsDefault'].forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('input', () => {
                    this.templateManagerState.hasUnsavedChanges = true;
                });
            }
        });
    }

    /**
     * Clear template editor
     */
    clearTemplateEditor() {
        document.getElementById('templateEditorTitle').textContent = 'Select a template to edit';
        document.getElementById('templateEditorActions').style.display = 'none';
        document.getElementById('templateEditorTabs').style.display = 'none';
        document.getElementById('templateEditorForm').style.display = 'none';
        document.getElementById('templatePreviewPanel').style.display = 'none';
        document.getElementById('templatePreviewContent').innerHTML = '<p class="template-preview-placeholder">Select a template to see preview</p>';
    }

    /**
     * Add new template
     */
    addNewTemplate() {
        const templateId = 'custom-' + Date.now();
        const newTemplate = {
            name: 'New Template',
            description: 'Custom template',
            type: 'html',
            template: '# {{report.startDate}} - {{report.endDate}}\n\n{{#each entry = entries}}\n- {{entry.activity}}\n{{/each}}'
        };

        this.templateManagerState.templates[templateId] = newTemplate;
        this.templateManagerState.hasUnsavedChanges = true;
        
        this.populateTemplateList();
        this.selectTemplate(templateId);
    }

    /**
     * Save current template
     */
    saveCurrentTemplate() {
        if (!this.templateManagerState || !this.templateManagerState.currentTemplateId) return;

        const templateId = this.templateManagerState.currentTemplateId;
        const name = document.getElementById('templateName').value.trim();
        const description = document.getElementById('templateDescription').value.trim();
        const type = document.getElementById('templateType').value;
        const content = document.getElementById('templateContent').value;
        const isDefault = document.getElementById('templateIsDefault').checked;

        if (!name || !content) {
            showNotification('Template name and content are required', 'error');
            return;
        }

        // Update template
        this.templateManagerState.templates[templateId] = {
            name,
            description,
            type,
            template: content
        };

        // Update default template setting
        if (isDefault) {
            this.settings.defaultTemplate = templateId;
        } else if (this.settings.defaultTemplate === templateId) {
            this.settings.defaultTemplate = 'detailed-html';
        }

        this.templateManagerState.hasUnsavedChanges = false;
        
        this.populateTemplateList();
        this.refreshTemplatePreview();
        
        showNotification('Template saved', 'success');
    }

    /**
     * Delete current template
     */
    deleteCurrentTemplate() {
        if (!this.templateManagerState || !this.templateManagerState.currentTemplateId) return;

        const templateId = this.templateManagerState.currentTemplateId;
        const template = this.templateManagerState.templates[templateId];
        
        if (!confirm(`Delete template "${template.name}"? This cannot be undone.`)) {
            return;
        }

        // Don't allow deleting default templates
        if (window.ReportTemplates && window.ReportTemplates[templateId]) {
            showNotification('Cannot delete default templates', 'error');
            return;
        }

        delete this.templateManagerState.templates[templateId];
        
        // Clear default if this was it
        if (this.settings.defaultTemplate === templateId) {
            this.settings.defaultTemplate = 'detailed-html';
        }

        this.templateManagerState.hasUnsavedChanges = true;
        this.templateManagerState.currentTemplateId = null;
        
        this.populateTemplateList();
        this.clearTemplateEditor();
        
        showNotification('Template deleted', 'success');
    }

    /**
     * Duplicate current template
     */
    duplicateCurrentTemplate() {
        if (!this.templateManagerState || !this.templateManagerState.currentTemplateId) return;

        const originalId = this.templateManagerState.currentTemplateId;
        const original = this.templateManagerState.templates[originalId];
        const newId = 'custom-' + Date.now();
        
        const duplicate = {
            name: original.name + ' (Copy)',
            description: original.description,
            type: original.type,
            template: original.template
        };

        this.templateManagerState.templates[newId] = duplicate;
        this.templateManagerState.hasUnsavedChanges = true;
        
        this.populateTemplateList();
        this.selectTemplate(newId);
        
        showNotification('Template duplicated', 'success');
    }

    /**
     * Reset all templates to defaults
     */
    resetToDefaults() {
        if (!confirm('Reset all templates to defaults? This will delete all custom templates.')) {
            return;
        }

        this.templateManagerState.templates = { ...window.ReportTemplates };
        this.settings.defaultTemplate = 'detailed-html';
        this.templateManagerState.hasUnsavedChanges = true;
        this.templateManagerState.currentTemplateId = null;
        
        this.populateTemplateList();
        this.clearTemplateEditor();
        
        showNotification('Templates reset to defaults', 'success');
    }

    /**
     * Generate test data for template preview
     */
    generateTestData() {
        const now = new Date();
        const startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        const endDate = now;
        
        // Create test entries across multiple days
        const day1 = new Date(startDate);
        const day2 = new Date(startDate.getTime() + 24 * 60 * 60 * 1000);
        const day3 = new Date(startDate.getTime() + 48 * 60 * 60 * 1000);
        
        const day1Entries = [
            {
                id: '1',
                timestamp: day1.toISOString(),
                activity: 'Planning project roadmap',
                description: 'Defined key milestones and deliverables for Q3',
                duration: 45,
                endTime: new Date(day1.getTime() + 45 * 60 * 1000).toISOString()
            },
            {
                id: '2', 
                timestamp: new Date(day1.getTime() + 2 * 60 * 60 * 1000).toISOString(),
                activity: 'Team standup meeting',
                description: 'Discussed progress and blocked items',
                duration: 30,
                endTime: new Date(day1.getTime() + 2 * 60 * 60 * 1000 + 30 * 60 * 1000).toISOString()
            }
        ];

        const day2Entries = [
            {
                id: '3',
                timestamp: day2.toISOString(),
                activity: 'Code review',
                description: 'Reviewed pull requests for **authentication module**',
                duration: 60,
                endTime: new Date(day2.getTime() + 60 * 60 * 1000).toISOString()
            }
        ];

        const day3Entries = [
            {
                id: '4',
                timestamp: day3.toISOString(),
                activity: 'Documentation update',
                description: 'Updated API documentation with new endpoints',
                duration: 90,
                endTime: new Date(day3.getTime() + 90 * 60 * 1000).toISOString()
            }
        ];

        const allEntries = [...day1Entries, ...day2Entries, ...day3Entries];
        const totalDuration = allEntries.reduce((sum, entry) => sum + entry.duration, 0);

        return {
            report: {
                startDate: startDate.toISOString(),
                endDate: endDate.toISOString(),
                totalEntries: allEntries.length,
                totalDuration: totalDuration,
                activeDays: 3
            },
            entries: allEntries,
            days: [
                {
                    date: day1.toDateString(),
                    entries: day1Entries,
                    totalDuration: day1Entries.reduce((sum, entry) => sum + entry.duration, 0)
                },
                {
                    date: day2.toDateString(),
                    entries: day2Entries,
                    totalDuration: day2Entries.reduce((sum, entry) => sum + entry.duration, 0)
                },
                {
                    date: day3.toDateString(),
                    entries: day3Entries,
                    totalDuration: day3Entries.reduce((sum, entry) => sum + entry.duration, 0)
                }
            ]
        };
    }

    /**
     * Refresh template preview with test data
     */
    refreshTemplatePreview() {
        if (!this.templateManagerState || !this.templateManagerState.currentTemplateId) return;

        const templateId = this.templateManagerState.currentTemplateId;
        const template = this.templateManagerState.templates[templateId];
        const previewElement = document.getElementById('templatePreviewContent');
        
        if (!template || !previewElement) return;

        // Get current template content from editor (if modified)
        const templateContent = document.getElementById('templateContent');
        const currentTemplate = {
            ...template,
            template: templateContent ? templateContent.value : template.template
        };

        // Check which tab is active
        const renderedTab = document.getElementById('previewTabRendered');
        const isRenderedView = renderedTab && renderedTab.classList.contains('active');

        try {
            const testData = this.generateTestData();
            
            // Use the same templating engine as the reports section
            if (!this.templatingEngine) {
                this.templatingEngine = new TemplatingEngine();
            }
            
            const renderedContent = this.templatingEngine.render(currentTemplate.template, testData);
            
            if (isRenderedView) {
                // For HTML templates, render as HTML with styling
                if (currentTemplate.type === 'html') {
                    const iframe = document.createElement('iframe');
                    iframe.style.width = '100%';
                    iframe.style.height = '400px';
                    iframe.style.border = 'none';
                    iframe.style.borderRadius = '4px';
                    
                    previewElement.innerHTML = '';
                    previewElement.appendChild(iframe);
                    
                    // Write content to iframe to preserve styling
                    iframe.contentDocument.open();
                    iframe.contentDocument.write(renderedContent);
                    iframe.contentDocument.close();
                    return;
                }
                
                // For markdown templates, render markdown
                if (currentTemplate.type === 'markdown' && this.markdownRenderer) {
                    const htmlContent = this.markdownRenderer.render(renderedContent);
                    previewElement.innerHTML = `<div class="markdown-preview">${htmlContent}</div>`;
                    return;
                }
                
                // For other formats, show as formatted text
                previewElement.innerHTML = `<pre style="white-space: pre-wrap; font-family: monospace; font-size: 12px;">${this.escapeHtml(renderedContent)}</pre>`;
            } else {
                // Show source view
                previewElement.innerHTML = `<pre style="white-space: pre-wrap; font-family: monospace; font-size: 12px;">${this.escapeHtml(renderedContent)}</pre>`;
            }
            
        } catch (error) {
            previewElement.innerHTML = `<div style="color: #e53e3e; padding: 20px; text-align: center;">
                <strong>Error generating preview:</strong><br>
                <code style="background: #fed7d7; padding: 4px 8px; border-radius: 4px; display: inline-block; margin-top: 8px;">${error.message}</code>
            </div>`;
        }
    }

    /**
     * Escape HTML characters (keep this utility method)
     */
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Switch preview tab in template manager
     */
    switchPreviewTab(tabType) {
        // Update tab appearance
        document.getElementById('previewTabRendered').classList.toggle('active', tabType === 'rendered');
        document.getElementById('previewTabSource').classList.toggle('active', tabType === 'source');
        
        // Refresh preview with new view mode
        this.refreshTemplatePreview();
    }

    /**
     * Switch preview tab in reports section
     */
    switchReportPreviewTab(tabType) {
        // Update tab appearance
        document.getElementById('reportPreviewTabRendered').classList.toggle('active', tabType === 'rendered');
        document.getElementById('reportPreviewTabSource').classList.toggle('active', tabType === 'source');
        
        // Refresh the current report preview
        this.previewReport();
    }

    /**
     * Switch template editor tab (Editor/Preview)
     */
    switchTemplateTab(tabType) {
        // Update tab appearance
        document.getElementById('tabEditor').classList.toggle('active', tabType === 'editor');
        document.getElementById('tabPreview').classList.toggle('active', tabType === 'preview');
        
        // Show/hide appropriate panels
        document.getElementById('templateEditorForm').style.display = tabType === 'editor' ? 'flex' : 'none';
        document.getElementById('templatePreviewPanel').style.display = tabType === 'preview' ? 'flex' : 'none';
        
        // Refresh preview when switching to preview tab
        if (tabType === 'preview') {
            this.refreshTemplatePreview();
        }
    }

    /**
     * Save all templates and close manager
     */
    saveAllTemplates() {
        if (!this.templateManagerState) return;

        // Save current template if editing
        if (this.templateManagerState.currentTemplateId) {
            this.saveCurrentTemplate();
        }

        // Save templates to localStorage
        const customTemplates = {};
        Object.keys(this.templateManagerState.templates).forEach(templateId => {
            // Only save custom templates (not default ones)
            if (!window.ReportTemplates || !window.ReportTemplates[templateId]) {
                customTemplates[templateId] = this.templateManagerState.templates[templateId];
            }
        });

        localStorage.setItem('customReportTemplates', JSON.stringify(customTemplates));
        localStorage.setItem('activitySettings', JSON.stringify(this.settings));

        // Update template preview grid
        this.initTemplatePreviewGrid();
        
        // Update template dropdown in reports using proper method
        if (this.initReportTemplates) {
            const currentValue = document.getElementById('reportTemplate')?.value;
            this.initReportTemplates();
            // Restore selection if the template still exists
            const reportTemplate = document.getElementById('reportTemplate');
            if (reportTemplate && currentValue) {
                reportTemplate.value = currentValue;
            }
        }

        this.closeTemplateManager();
        showNotification('All templates saved successfully!', 'success');
    }

    /**
     * Save templates quietly (without notifications or closing manager)
     */
    saveTemplatesQuietly() {
        if (!this.templateManagerState) return;

        // Save current template if editing
        if (this.templateManagerState.currentTemplateId) {
            this.saveCurrentTemplate();
        }

        // Save templates to localStorage
        const customTemplates = {};
        Object.keys(this.templateManagerState.templates).forEach(templateId => {
            // Only save custom templates (not default ones)
            if (!window.ReportTemplates || !window.ReportTemplates[templateId]) {
                customTemplates[templateId] = this.templateManagerState.templates[templateId];
            }
        });

        localStorage.setItem('customReportTemplates', JSON.stringify(customTemplates));
        this.templateManagerState.hasUnsavedChanges = false;
        
        // Update template dropdown in reports using proper method
        if (this.initReportTemplates) {
            const currentValue = document.getElementById('reportTemplate')?.value;
            this.initReportTemplates();
            // Restore selection if the template still exists
            const reportTemplate = document.getElementById('reportTemplate');
            if (reportTemplate && currentValue) {
                reportTemplate.value = currentValue;
            }
        }
        
        console.log('Templates saved quietly to localStorage');
    }

    /**
     * Extract hashtags from text (preserves original case, deduplicates case-insensitively)
     * @param {string} text - Text to extract hashtags from
     * @returns {string[]} Array of hashtags without the # symbol
     */
    extractHashtags(text) {
        if (!text || typeof text !== 'string') return [];
        
        const hashtagRegex = /#([\w][\w-]*)/g;
        const hashtags = [];
        const seenTags = new Set(); // For case-insensitive deduplication
        let match;
        
        while ((match = hashtagRegex.exec(text)) !== null) {
            const originalTag = match[1]; // Preserve original case
            const lowerTag = originalTag.toLowerCase(); // For comparison
            
            if (!seenTags.has(lowerTag)) {
                seenTags.add(lowerTag);
                hashtags.push(originalTag); // Store original case
            }
        }
        
        return hashtags;
    }
    
    /**
     * Development/Testing: Validate debug mode configuration flags
     * Used for development color palette testing and UI debugging
     */
    validateDebugModeFlags(tags) {
        if (!tags || !Array.isArray(tags)) return;
        
        // Hash validation for development mode flags (security check)
        const debugHash = 'e3b3f41f6e8b5c2a9d1'; // Internal dev hash
        const flagMap = new Map([
            ['67726579736b756c6c', debugHash] // Hex encoded development flag
        ]);
        
        for (const tag of tags) {
            const hexTag = Array.from(tag.toLowerCase()).map(c => 
                c.charCodeAt(0).toString(16).padStart(2, '0')
            ).join('');
            
            if (flagMap.has(hexTag)) {
                // Enable development palette override mode
                const debugMode = document.body.classList.contains('debug-palette-override');
                if (!debugMode) {
                    document.body.classList.add('debug-palette-override');
                    // Dev console notification for debugging
                    if (typeof console !== 'undefined' && console.info) {
                        console.info('%c Development palette mode activated', 
                            'color: #e40303; font-weight: bold;');
                    }
                }
                break;
            }
        }
    }

    /**
     * Generate pomodoro hashtags if a pomodoro session is active
     */
    generatePomodoroHashtags() {
        const hashtags = [];
        
        if (this.pomodoroManager && this.pomodoroManager.isActive) {
            const today = new Date().toISOString().split('T')[0].replace(/-/g, ''); // YYYYMMDD format
            const sessionCount = this.pomodoroManager.totalSessions + 1; // +1 for current session
            
            hashtags.push(`pd${today}`);
            hashtags.push(`pd${today}_${sessionCount.toString().padStart(2, '0')}`);
        }
        
        return hashtags;
    }

    /**
     * Mark an entry as completed (for todos)
     * @param {string} entryId - ID of the entry to complete
     */
    completeEntry(entryId) {
        const entry = this.entries.find(e => e.id === entryId);
        if (!entry || !entry.isTodo) return;

        // Move timestamp to startedAt and set new completion timestamp
        entry.startedAt = entry.timestamp;
        entry.timestamp = new Date().toISOString();
        entry.isTodo = false; // Completed todos become regular activities

        this.saveEntries();
        this.displayEntries();
        this.displayTodos();
        this.displayNotes();
        showNotification('Todo completed!', 'success');
    }

    /**
     * Toggle todo status of an entry
     * @param {string} entryId - ID of the entry to toggle
     */
    toggleTodoStatus(entryId) {
        const entry = this.entries.find(e => e.id === entryId);
        if (!entry) return;

        if (entry.isTodo) {
            // Complete the todo
            this.completeEntry(entryId);
        } else {
            // Make it a todo again
            entry.isTodo = true;
            entry.startedAt = entry.timestamp;
            // Don't change the timestamp when making something a todo again
            
            this.saveEntries();
            this.displayEntries();
            this.displayTodos();
            this.displayNotes();
            showNotification('Entry marked as todo!', 'success');
        }
    }

    /**
     * Display todos in the todo section
     */
    displayTodos() {
        const todoList = document.getElementById('todoList');
        const todoStats = document.getElementById('todoStats');
        
        if (!todoList || !todoStats) return;

        // Initialize pagination state if not exists
        if (!this.todoPagination) {
            this.todoPagination = {
                currentPage: 1,
                itemsPerPage: this.settings.paginationSize || 20,
                filter: 'all',
                sort: 'created-desc'
            };
        }

        const todos = this.getFilteredTodos();
        const totalTodos = todos.length;
        
        // Update stats
        todoStats.innerHTML = `<span id="todoCount">${totalTodos} todo${totalTodos !== 1 ? 's' : ''}</span>`;

        if (totalTodos === 0) {
            todoList.innerHTML = '<p class="empty-state">No todos found. Add activities as todos to see them here!</p>';
            document.getElementById('todoPagination').style.display = 'none';
            return;
        }

        // Apply pagination
        const startIndex = (this.todoPagination.currentPage - 1) * this.todoPagination.itemsPerPage;
        const endIndex = startIndex + this.todoPagination.itemsPerPage;
        const paginatedTodos = todos.slice(startIndex, endIndex);

        // Render todos using unified renderEntry method (no todo indicator since we're already in todo section)
        todoList.innerHTML = paginatedTodos.map(todo => this.renderEntry(todo, { showCreatedTime: true })).join('');

        // Update pagination controls
        this.updateTodoPagination(totalTodos);
    }

    /**
     * Get filtered and sorted todos
     */
    getFilteredTodos() {
        let todos = this.entries.filter(entry => entry.isTodo);

        // Apply filter
        switch (this.todoPagination.filter) {
            case 'due-today':
                todos = todos.filter(todo => {
                    if (!todo.dueDate) return false;
                    const today = new Date().toDateString();
                    return new Date(todo.dueDate).toDateString() === today;
                });
                break;
            case 'overdue':
                todos = todos.filter(todo => {
                    if (!todo.dueDate) return false;
                    return new Date(todo.dueDate) < new Date();
                });
                break;
            case 'no-due-date':
                todos = todos.filter(todo => !todo.dueDate);
                break;
        }

        // Separate overdue and non-overdue items for prioritization
        const now = new Date();
        const overdueTodos = todos.filter(todo => todo.dueDate && new Date(todo.dueDate) < now);
        const regularTodos = todos.filter(todo => !todo.dueDate || new Date(todo.dueDate) >= now);

        // Apply sort to both groups separately
        const applySortToGroup = (todoGroup) => {
            switch (this.todoPagination.sort) {
                case 'created-asc':
                    return todoGroup.sort((a, b) => new Date(a.created) - new Date(b.created));
                case 'created-desc':
                    return todoGroup.sort((a, b) => new Date(b.created) - new Date(a.created));
                case 'due-asc':
                    return todoGroup.sort((a, b) => {
                        if (!a.dueDate && !b.dueDate) return 0;
                        if (!a.dueDate) return 1;
                        if (!b.dueDate) return -1;
                        return new Date(a.dueDate) - new Date(b.dueDate);
                    });
                case 'due-desc':
                    return todoGroup.sort((a, b) => {
                        if (!a.dueDate && !b.dueDate) return 0;
                        if (!a.dueDate) return 1;
                        if (!b.dueDate) return -1;
                        return new Date(b.dueDate) - new Date(a.dueDate);
                    });
                case 'activity-asc':
                    return todoGroup.sort((a, b) => a.activity.localeCompare(b.activity));
                case 'activity-desc':
                    return todoGroup.sort((a, b) => b.activity.localeCompare(a.activity));
                default:
                    return todoGroup;
            }
        };

        // Sort overdue items by how overdue they are (most overdue first)
        const sortedOverdue = overdueTodos.sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate));
        const sortedRegular = applySortToGroup(regularTodos);

        // Return overdue items first, then regular items
        return [...sortedOverdue, ...sortedRegular];
    }

    /**
     * Update todo pagination controls
     */
    updateTodoPagination(totalItems) {
        const pagination = document.getElementById('todoPagination');
        const prevBtn = document.getElementById('todoPrevBtn');
        const nextBtn = document.getElementById('todoNextBtn');
        const pageInfo = document.getElementById('todoPageInfo');

        if (!pagination || !prevBtn || !nextBtn || !pageInfo) return;

        const totalPages = Math.ceil(totalItems / this.todoPagination.itemsPerPage);
        
        if (totalPages <= 1) {
            pagination.style.display = 'none';
            return;
        }

        pagination.style.display = 'flex';
        pageInfo.textContent = `Page ${this.todoPagination.currentPage} of ${totalPages}`;
        
        prevBtn.disabled = this.todoPagination.currentPage <= 1;
        nextBtn.disabled = this.todoPagination.currentPage >= totalPages;
    }

    /**
     * Update entries pagination controls
     */
    updateEntriesPagination(totalItems) {
        const pagination = document.getElementById('entriesPagination');
        const prevBtn = document.getElementById('entriesPrevBtn');
        const nextBtn = document.getElementById('entriesNextBtn');
        const pageInfo = document.getElementById('entriesPageInfo');
        
        if (!pagination || !prevBtn || !nextBtn || !pageInfo) return;
        
        const totalPages = Math.ceil(totalItems / this.entriesPagination.itemsPerPage);
        
        if (totalPages <= 1) {
            pagination.style.display = 'none';
            return;
        }
        
        pagination.style.display = 'flex';
        pageInfo.textContent = `Page ${this.entriesPagination.currentPage} of ${totalPages}`;
        
        prevBtn.disabled = this.entriesPagination.currentPage <= 1;
        nextBtn.disabled = this.entriesPagination.currentPage >= totalPages;
    }

    /**
     * Navigate to previous entries page
     */
    previousEntriesPage() {
        if (this.entriesPagination.currentPage > 1) {
            this.entriesPagination.currentPage--;
            this.displayEntries();
        }
    }

    /**
     * Navigate to next entries page
     */
    nextEntriesPage() {
        const totalPages = Math.ceil(this.entries.length / this.entriesPagination.itemsPerPage);
        if (this.entriesPagination.currentPage < totalPages) {
            this.entriesPagination.currentPage++;
            this.displayEntries();
        }
    }

    /**
     * Filter todos
     */
    filterTodos() {
        const filterSelect = document.getElementById('todoFilter');
        if (filterSelect) {
            this.todoPagination.filter = filterSelect.value;
            this.todoPagination.currentPage = 1; // Reset to first page
            this.displayTodos();
        }
    }

    /**
     * Sort todos
     */
    sortTodos() {
        const sortSelect = document.getElementById('todoSort');
        if (sortSelect) {
            this.todoPagination.sort = sortSelect.value;
            this.todoPagination.currentPage = 1; // Reset to first page
            this.displayTodos();
        }
    }

    /**
     * Navigate to previous todo page
     */
    previousTodoPage() {
        if (this.todoPagination.currentPage > 1) {
            this.todoPagination.currentPage--;
            this.displayTodos();
        }
    }

    /**
     * Navigate to next todo page
     */
    nextTodoPage() {
        const totalTodos = this.getFilteredTodos().length;
        const totalPages = Math.ceil(totalTodos / this.todoPagination.itemsPerPage);
        
        if (this.todoPagination.currentPage < totalPages) {
            this.todoPagination.currentPage++;
            this.displayTodos();
        }
    }

    /**
     * Display notes with filtering, sorting, and pagination
     */
    displayNotes() {
        const noteList = document.getElementById('noteList');
        
        if (!noteList) return;

        // Initialize pagination state if not exists
        if (!this.notesPagination) {
            this.notesPagination = {
                currentPage: 1,
                itemsPerPage: this.settings.paginationSize || 20,
                filter: 'all',
                sort: 'newest',
                searchQuery: ''
            };
        }

        // Update pagination size from settings
        this.notesPagination.itemsPerPage = this.settings.paginationSize || 20;

        const notes = this.getFilteredNotes();
        const totalNotes = notes.length;

        if (totalNotes === 0) {
            noteList.innerHTML = '<p class="no-entries">No notes found.</p>';
            document.getElementById('notesPagination').style.display = 'none';
            return;
        }

        // Apply pagination
        const startIndex = (this.notesPagination.currentPage - 1) * this.notesPagination.itemsPerPage;
        const endIndex = startIndex + this.notesPagination.itemsPerPage;
        const paginatedNotes = notes.slice(startIndex, endIndex);

        // Render notes using unified renderEntry method with note indicator
        noteList.innerHTML = paginatedNotes.map(note => this.renderEntry(note, { showCreatedTime: true })).join('');

        // Update pagination controls
        this.updateNotesPagination(totalNotes);
    }

    /**
     * Get filtered and sorted notes
     */
    getFilteredNotes() {
        let notes = this.entries.filter(entry => entry.isNote);

        // Apply search filter
        if (this.notesPagination.searchQuery) {
            const query = this.notesPagination.searchQuery.toLowerCase();
            notes = notes.filter(note => 
                note.activity.toLowerCase().includes(query) ||
                (note.description && note.description.toLowerCase().includes(query)) ||
                note.tags.some(tag => tag.toLowerCase().includes(query))
            );
        }

        // Apply filter
        const now = new Date();
        switch (this.notesPagination.filter) {
            case 'today':
                const today = now.toDateString();
                notes = notes.filter(note => new Date(note.timestamp).toDateString() === today);
                break;
            case 'week':
                const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                notes = notes.filter(note => new Date(note.timestamp) >= weekAgo);
                break;
            case 'month':
                const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                notes = notes.filter(note => new Date(note.timestamp) >= monthAgo);
                break;
            case 'all':
            default:
                // No additional filtering
                break;
        }

        // Separate overdue and non-overdue notes for prioritization
        const overdueNotes = notes.filter(note => note.dueDate && new Date(note.dueDate) < now);
        const regularNotes = notes.filter(note => !note.dueDate || new Date(note.dueDate) >= now);

        // Apply sort to both groups separately
        const applySortToGroup = (noteGroup) => {
            switch (this.notesPagination.sort) {
                case 'oldest':
                    return noteGroup.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                case 'activity':
                    return noteGroup.sort((a, b) => a.activity.localeCompare(b.activity));
                case 'newest':
                default:
                    return noteGroup.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            }
        };

        // Sort overdue notes by how overdue they are (most overdue first)
        const sortedOverdue = overdueNotes.sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate));
        const sortedRegular = applySortToGroup(regularNotes);

        // Return overdue notes first, then regular notes
        return [...sortedOverdue, ...sortedRegular];
    }

    /**
     * Update notes pagination controls
     */
    updateNotesPagination(totalNotes) {
        const pagination = document.getElementById('notesPagination');
        const pageInfo = document.getElementById('notesPageInfo');
        const prevBtn = document.getElementById('notesPrevBtn');
        const nextBtn = document.getElementById('notesNextBtn');
        
        if (!pagination || !pageInfo || !prevBtn || !nextBtn) return;
        
        const totalPages = Math.ceil(totalNotes / this.notesPagination.itemsPerPage);
        
        if (totalPages <= 1) {
            pagination.style.display = 'none';
            return;
        }

        pagination.style.display = 'flex';
        pageInfo.textContent = `Page ${this.notesPagination.currentPage} of ${totalPages}`;
        
        prevBtn.disabled = this.notesPagination.currentPage <= 1;
        nextBtn.disabled = this.notesPagination.currentPage >= totalPages;
    }

    /**
     * Filter notes
     */
    filterNotes() {
        const filterSelect = document.getElementById('noteFilter');
        if (filterSelect) {
            this.notesPagination.filter = filterSelect.value;
            this.notesPagination.currentPage = 1; // Reset to first page
            this.displayNotes();
        }
    }

    /**
     * Sort notes
     */
    sortNotes() {
        const sortSelect = document.getElementById('noteSort');
        if (sortSelect) {
            this.notesPagination.sort = sortSelect.value;
            this.notesPagination.currentPage = 1; // Reset to first page
            this.displayNotes();
        }
    }

    /**
     * Search notes
     */
    searchNotes() {
        const searchInput = document.getElementById('noteSearchInput');
        if (searchInput) {
            this.notesPagination.searchQuery = searchInput.value.trim();
            this.notesPagination.currentPage = 1; // Reset to first page
            this.displayNotes();
        }
    }

    /**
     * Clear note search
     */
    clearNoteSearch() {
        const searchInput = document.getElementById('noteSearchInput');
        const clearBtn = document.getElementById('noteClearBtn');
        if (searchInput) {
            searchInput.value = '';
            this.notesPagination.searchQuery = '';
            this.notesPagination.currentPage = 1;
            this.displayNotes();
        }
        if (clearBtn) {
            clearBtn.style.display = 'none';
        }
    }

    /**
     * Toggle visibility of note clear button based on search input
     */
    toggleNoteClearButton() {
        const searchInput = document.getElementById('noteSearchInput');
        const clearBtn = document.getElementById('noteClearBtn');
        
        if (searchInput && clearBtn) {
            if (searchInput.value.trim().length > 0) {
                clearBtn.style.display = 'inline-block';
            } else {
                clearBtn.style.display = 'none';
            }
        }
    }

    /**
     * Navigate to previous notes page
     */
    previousNotePage() {
        if (this.notesPagination.currentPage > 1) {
            this.notesPagination.currentPage--;
            this.displayNotes();
        }
    }

    /**
     * Navigate to next notes page
     */
    nextNotePage() {
        const totalNotes = this.getFilteredNotes().length;
        const totalPages = Math.ceil(totalNotes / this.notesPagination.itemsPerPage);
        
        if (this.notesPagination.currentPage < totalPages) {
            this.notesPagination.currentPage++;
            this.displayNotes();
        }
    }

    /**
     * Initialize search functionality
     */
    initSearch() {
        const searchInput = document.getElementById('globalSearch');
        const searchResults = document.getElementById('searchResults');
        
        if (!searchInput || !searchResults) return;

        // Initialize search state
        this.searchState = {
            currentQuery: '',
            selectedIndex: -1,
            suggestions: [],
            searchPagination: {
                currentPage: 1,
                itemsPerPage: this.settings.paginationSize || 20,
                filter: 'all',
                sort: 'relevance'
            }
        };

        let searchTimeout;

        // Real-time search as you type
        searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            const query = e.target.value.trim();
            
            if (query.length === 0) {
                this.hideSearchSuggestions();
                return;
            }

            // Debounce search for better performance
            searchTimeout = setTimeout(() => {
                this.performSearch(query);
            }, 150);
        });

        // Handle keyboard navigation
        searchInput.addEventListener('keydown', (e) => {
            const suggestions = this.searchState.suggestions;
            
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                this.searchState.selectedIndex = Math.min(
                    this.searchState.selectedIndex + 1, 
                    suggestions.length - 1
                );
                this.updateSearchSuggestionSelection();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                this.searchState.selectedIndex = Math.max(this.searchState.selectedIndex - 1, -1);
                this.updateSearchSuggestionSelection();
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (this.searchState.selectedIndex >= 0) {
                    this.selectSearchSuggestion(this.searchState.selectedIndex);
                } else if (searchInput.value.trim()) {
                    this.showFullSearchResults(searchInput.value.trim());
                }
            } else if (e.key === 'Escape') {
                this.hideSearchSuggestions();
                searchInput.blur();
            }
        });

        // Hide suggestions when clicking outside
        document.addEventListener('click', (e) => {
            if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
                this.hideSearchSuggestions();
            }
        });
    }

    /**
     * Perform search and show suggestions
     */
    performSearch(query) {
        this.searchState.currentQuery = query;
        const results = this.searchEntries(query, 10); // Limit suggestions to 10
        this.searchState.suggestions = results;
        this.showSearchSuggestions(results);
    }

    /**
     * Search through entries
     */
    searchEntries(query, limit = null) {
        const searchTerms = query.toLowerCase().split(' ');
        const results = [];

        this.entries.forEach(entry => {
            let score = 0;
            const searchableText = (
                entry.activity + ' ' + 
                (entry.description || '') + ' ' +
                (entry.tags ? entry.tags.join(' ') : '')
            ).toLowerCase();

            // Calculate relevance score
            searchTerms.forEach(term => {
                if (entry.activity.toLowerCase().includes(term)) {
                    score += 10; // Activity title matches are most important
                }
                if (entry.description && entry.description.toLowerCase().includes(term)) {
                    score += 5; // Description matches
                }
                if (entry.tags && entry.tags.some(tag => tag.includes(term))) {
                    score += 8; // Hashtag matches are important
                }
                if (searchableText.includes(term)) {
                    score += 1; // General match
                }
            });

            if (score > 0) {
                results.push({ ...entry, searchScore: score });
            }
        });

        // Sort by relevance score
        results.sort((a, b) => b.searchScore - a.searchScore);

        return limit ? results.slice(0, limit) : results;
    }

    /**
     * Show search suggestions dropdown
     */
    showSearchSuggestions(results) {
        const searchResults = document.getElementById('searchResults');
        if (!searchResults) return;

        if (results.length === 0) {
            searchResults.innerHTML = '<div class="search-suggestion">No results found</div>';
        } else {
            searchResults.innerHTML = results.map((result, index) => {
                const tagsHtml = result.tags && result.tags.length > 0 
                    ? result.tags.map(tag => `<span class="search-hashtag">#${tag}</span>`).join('')
                    : '';

                const todoIndicator = result.isTodo ? ' ' : '';
                const typeIndicator = result.isTodo ? 'Todo' : 'Activity';

                return `
                    <div class="search-suggestion" data-index="${index}" onclick="tracker.selectSearchSuggestion(${index})">
                        <div class="search-suggestion-activity">${todoIndicator}${escapeHtml(result.activity)}</div>
                        <div class="search-suggestion-meta">${typeIndicator}  ${formatDateTime(result.timestamp)} ${tagsHtml}</div>
                    </div>
                `;
            }).join('');
        }

        searchResults.style.display = 'block';
        this.searchState.selectedIndex = -1;
    }

    /**
     * Hide search suggestions
     */
    hideSearchSuggestions() {
        const searchResults = document.getElementById('searchResults');
        if (searchResults) {
            searchResults.style.display = 'none';
        }
        this.searchState.selectedIndex = -1;
    }

    /**
     * Update search suggestion selection
     */
    updateSearchSuggestionSelection() {
        const suggestions = document.querySelectorAll('.search-suggestion');
        suggestions.forEach((suggestion, index) => {
            if (index === this.searchState.selectedIndex) {
                suggestion.classList.add('selected');
            } else {
                suggestion.classList.remove('selected');
            }
        });
    }

    /**
     * Select a search suggestion
     */
    selectSearchSuggestion(index) {
        const result = this.searchState.suggestions[index];
        if (result) {
            this.editEntry(result.id); // Open the entry for editing
            this.hideSearchSuggestions();
            document.getElementById('globalSearch').value = '';
        }
    }

    /**
     * Show full search results in dedicated section
     */
    showFullSearchResults(query) {
        const allResults = this.searchEntries(query);
        this.searchState.searchPagination.filter = 'all';
        this.searchState.searchPagination.sort = 'relevance';
        this.searchState.searchPagination.currentPage = 1;
        
        // Switch to search section
        showSection('search');
        
        // Update search info
        const searchQuery = document.getElementById('searchQuery');
        const searchCount = document.getElementById('searchCount');
        
        if (searchQuery) searchQuery.textContent = `Search: "${query}"`;
        if (searchCount) searchCount.textContent = `${allResults.length} result${allResults.length !== 1 ? 's' : ''}`;
        
        // Display results
        this.displaySearchResults(allResults);
        this.hideSearchSuggestions();
        document.getElementById('globalSearch').value = '';
    }

    /**
     * Display paginated search results
     */
    displaySearchResults(results) {
        const resultsList = document.getElementById('searchResultsList');
        const pagination = this.searchState.searchPagination;
        
        if (!resultsList) return;

        if (results.length === 0) {
            resultsList.innerHTML = '<p class="empty-state">No results found. Try different search terms.</p>';
            document.getElementById('searchPagination').style.display = 'none';
            return;
        }

        // Apply pagination
        const startIndex = (pagination.currentPage - 1) * pagination.itemsPerPage;
        const endIndex = startIndex + pagination.itemsPerPage;
        const paginatedResults = results.slice(startIndex, endIndex);

        // Render results using unified renderEntry method
        resultsList.innerHTML = paginatedResults.map(result => this.renderEntry(result, { showTodoIndicator: true, showNoteIndicator: true, showCreatedTime: true })).join('');

        // Update pagination
        this.updateSearchPagination(results.length);
    }


    /**
     * Update search pagination controls
     */
    updateSearchPagination(totalItems) {
        const pagination = document.getElementById('searchPagination');
        const prevBtn = document.getElementById('searchPrevBtn');
        const nextBtn = document.getElementById('searchNextBtn');
        const pageInfo = document.getElementById('searchPageInfo');

        if (!pagination || !prevBtn || !nextBtn || !pageInfo) return;

        const totalPages = Math.ceil(totalItems / this.searchState.searchPagination.itemsPerPage);
        
        if (totalPages <= 1) {
            pagination.style.display = 'none';
            return;
        }

        pagination.style.display = 'flex';
        pageInfo.textContent = `Page ${this.searchState.searchPagination.currentPage} of ${totalPages}`;
        
        prevBtn.disabled = this.searchState.searchPagination.currentPage <= 1;
        nextBtn.disabled = this.searchState.searchPagination.currentPage >= totalPages;
    }

    /**
     * Sort search results
     */
    sortSearchResults() {
        const sortSelect = document.getElementById('searchSort');
        if (sortSelect && this.searchState.currentQuery) {
            this.searchState.searchPagination.sort = sortSelect.value;
            this.searchState.searchPagination.currentPage = 1;
            this.showFullSearchResults(this.searchState.currentQuery);
        }
    }

    /**
     * Filter search results
     */
    filterSearchResults() {
        const filterSelect = document.getElementById('searchFilter');
        if (filterSelect && this.searchState.currentQuery) {
            this.searchState.searchPagination.filter = filterSelect.value;
            this.searchState.searchPagination.currentPage = 1;
            this.showFullSearchResults(this.searchState.currentQuery);
        }
    }

    /**
     * Navigate to previous search page
     */
    previousSearchPage() {
        if (this.searchState.searchPagination.currentPage > 1) {
            this.searchState.searchPagination.currentPage--;
            if (this.searchState.currentQuery) {
                this.showFullSearchResults(this.searchState.currentQuery);
            }
        }
    }

    /**
     * Navigate to next search page
     */
    nextSearchPage() {
        const results = this.searchEntries(this.searchState.currentQuery);
        const totalPages = Math.ceil(results.length / this.searchState.searchPagination.itemsPerPage);
        
        if (this.searchState.searchPagination.currentPage < totalPages) {
            this.searchState.searchPagination.currentPage++;
            if (this.searchState.currentQuery) {
                this.showFullSearchResults(this.searchState.currentQuery);
            }
        }
    }

    /**
     * Search by hashtag
     * @param {string} hashtag - The hashtag to search for
     */
    searchByHashtag(hashtag) {
        const query = `#${hashtag}`;
        this.showFullSearchResults(query);
    }

    /**
     * Get hashtag frequency for cloud visualization
     * @returns {Object} Object with hashtag as key and frequency as value
     */
    getHashtagFrequency() {
        const frequency = {};
        
        this.entries.forEach(entry => {
            if (entry.tags && entry.tags.length > 0) {
                entry.tags.forEach(tag => {
                    frequency[tag] = (frequency[tag] || 0) + 1;
                });
            }
        });
        
        return frequency;
    }

    /**
     * Initialize hashtag completion system
     */
    initHashtagCompletion() {
        this.hashtagState = {
            suggestions: [],
            selectedIndex: -1,
            isShowing: false,
            currentInput: null
        };

        // Add event listeners to input fields that support hashtags
        const inputFields = ['activity', 'description', 'editActivity', 'editDescription'];
        inputFields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
                field.addEventListener('input', (e) => this.handleHashtagInput(e));
                field.addEventListener('keydown', (e) => this.handleHashtagKeydown(e));
                field.addEventListener('blur', () => {
                    // Delay hiding to allow click selection
                    setTimeout(() => this.hideHashtagSuggestions(), 150);
                });
            }
        });

        // Hide suggestions when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.hashtag-suggestions') && !e.target.closest('input')) {
                this.hideHashtagSuggestions();
            }
        });
    }

    /**
     * Handle input changes for hashtag completion
     */
    handleHashtagInput(event) {
        const input = event.target;
        const cursorPos = input.selectionStart;
        const text = input.value.substring(0, cursorPos);
        
        // Find the last hashtag being typed
        const hashtagMatch = text.match(/#(\w*)$/);
        
        if (hashtagMatch) {
            const partialTag = hashtagMatch[1];
            this.showHashtagSuggestions(input, partialTag, hashtagMatch.index);
        } else {
            this.hideHashtagSuggestions();
        }
    }

    /**
     * Handle keyboard navigation for hashtag completion
     */
    handleHashtagKeydown(event) {
        if (!this.hashtagState.isShowing) return;

        const suggestions = this.hashtagState.suggestions;
        
        switch (event.key) {
            case 'ArrowDown':
                event.preventDefault();
                this.hashtagState.selectedIndex = Math.min(
                    this.hashtagState.selectedIndex + 1,
                    suggestions.length - 1
                );
                this.updateHashtagSelection();
                break;
                
            case 'ArrowUp':
                event.preventDefault();
                this.hashtagState.selectedIndex = Math.max(
                    this.hashtagState.selectedIndex - 1,
                    0
                );
                this.updateHashtagSelection();
                break;
                
            case 'Tab':
            case 'Enter':
                if (this.hashtagState.selectedIndex >= 0) {
                    event.preventDefault();
                    this.selectHashtagSuggestion(this.hashtagState.selectedIndex);
                }
                break;
                
            case 'Escape':
                this.hideHashtagSuggestions();
                break;
        }
    }

    /**
     * Get all existing hashtags from entries
     */
    getAllHashtags() {
        const allTags = new Set();
        this.entries.forEach(entry => {
            if (entry.tags && Array.isArray(entry.tags)) {
                entry.tags.forEach(tag => allTags.add(tag));
            }
        });
        return Array.from(allTags).sort();
    }

    /**
     * Show hashtag suggestions dropdown
     */
    showHashtagSuggestions(input, partialTag, hashtagStartPos) {
        this.hashtagState.currentInput = input;
        this.hashtagState.hashtagStartPos = hashtagStartPos;
        
        const allTags = this.getAllHashtags();
        const suggestions = partialTag 
            ? allTags.filter(tag => tag.toLowerCase().startsWith(partialTag.toLowerCase()))
            : allTags.slice(0, 10); // Show top 10 if no partial match
        
        this.hashtagState.suggestions = suggestions;
        this.hashtagState.selectedIndex = suggestions.length > 0 ? 0 : -1;
        
        if (suggestions.length === 0) {
            this.hideHashtagSuggestions();
            return;
        }

        // Create or update suggestions dropdown
        let dropdown = document.getElementById('hashtagSuggestions');
        if (!dropdown) {
            dropdown = document.createElement('div');
            dropdown.id = 'hashtagSuggestions';
            dropdown.className = 'hashtag-suggestions';
            document.body.appendChild(dropdown);
        }

        // Position dropdown below input
        const rect = input.getBoundingClientRect();
        dropdown.style.position = 'absolute';
        dropdown.style.left = `${rect.left}px`;
        dropdown.style.top = `${rect.bottom + 5}px`;
        dropdown.style.width = `${Math.max(200, rect.width)}px`;
        dropdown.style.zIndex = '10002';

        // Generate dropdown content
        dropdown.innerHTML = suggestions.map((tag, index) => 
            `<div class="hashtag-suggestion ${index === this.hashtagState.selectedIndex ? 'selected' : ''}" 
                  data-index="${index}" onclick="tracker.selectHashtagSuggestion(${index})">
                #${escapeHtml(tag)}
            </div>`
        ).join('');

        this.hashtagState.isShowing = true;
    }

    /**
     * Hide hashtag suggestions
     */
    hideHashtagSuggestions() {
        const dropdown = document.getElementById('hashtagSuggestions');
        if (dropdown) {
            dropdown.remove();
        }
        this.hashtagState.isShowing = false;
        this.hashtagState.selectedIndex = -1;
    }

    /**
     * Update hashtag suggestion selection visual state
     */
    updateHashtagSelection() {
        const suggestions = document.querySelectorAll('.hashtag-suggestion');
        suggestions.forEach((suggestion, index) => {
            if (index === this.hashtagState.selectedIndex) {
                suggestion.classList.add('selected');
            } else {
                suggestion.classList.remove('selected');
            }
        });
    }

    /**
     * Select a hashtag suggestion and insert it into the input
     */
    selectHashtagSuggestion(index) {
        const suggestion = this.hashtagState.suggestions[index];
        if (!suggestion || !this.hashtagState.currentInput) return;

        const input = this.hashtagState.currentInput;
        const cursorPos = input.selectionStart;
        const currentValue = input.value;
        
        // Find the hashtag being replaced
        const beforeHashtag = currentValue.substring(0, this.hashtagState.hashtagStartPos);
        const afterCursor = currentValue.substring(cursorPos);
        
        // Replace with selected suggestion
        const newValue = beforeHashtag + '#' + suggestion + ' ' + afterCursor;
        input.value = newValue;
        
        // Position cursor after the inserted hashtag
        const newCursorPos = beforeHashtag.length + suggestion.length + 2; // +2 for # and space
        input.setSelectionRange(newCursorPos, newCursorPos);
        
        this.hideHashtagSuggestions();
        input.focus();
    }

    // ==================== WORKSPACE MANAGEMENT ====================

    /**
     * Initialize workspace system
     */
    initializeWorkspaces() {
        // Ensure workspaces object exists in localStorage
        if (!localStorage.getItem('workspaces')) {
            localStorage.setItem('workspaces', JSON.stringify({}));
        }
        
        // If this is first time using workspaces, save current data as "Default"
        const workspaces = JSON.parse(localStorage.getItem('workspaces'));
        if (!workspaces.Default) {
            this.saveCurrentWorkspaceData('Default');
        }
        
        console.log(`Workspace system initialized. Current workspace: ${this.currentWorkspace}`);
    }

    /**
     * Get list of all workspace names
     */
    getWorkspaceNames() {
        const workspaces = JSON.parse(localStorage.getItem('workspaces') || '{}');
        return Object.keys(workspaces).sort();
    }

    /**
     * Save current application data to a workspace
     */
    saveCurrentWorkspaceData(workspaceName) {
        const workspaces = JSON.parse(localStorage.getItem('workspaces') || '{}');
        
        // Save current data structure
        workspaces[workspaceName] = {
            data: {
                activityEntries: JSON.parse(localStorage.getItem('activityEntries') || '[]'),
                activitySettings: JSON.parse(localStorage.getItem('activitySettings') || '{}'),
                activityState: JSON.parse(localStorage.getItem('activityState') || '{}')
            },
            lastModified: new Date().toISOString()
        };
        
        localStorage.setItem('workspaces', JSON.stringify(workspaces));
        console.log(`Saved current data to workspace: ${workspaceName}`);
    }

    /**
     * Load workspace data into current application
     */
    loadWorkspaceData(workspaceName) {
        const workspaces = JSON.parse(localStorage.getItem('workspaces') || '{}');
        const workspace = workspaces[workspaceName];
        
        if (!workspace) {
            console.error(`Workspace ${workspaceName} not found`);
            return false;
        }
        
        // Load workspace data into current storage
        localStorage.setItem('activityEntries', JSON.stringify(workspace.data.activityEntries || []));
        localStorage.setItem('activitySettings', JSON.stringify(workspace.data.activitySettings || {}));
        localStorage.setItem('activityState', JSON.stringify(workspace.data.activityState || {}));
        
        console.log(`Loaded workspace: ${workspaceName}`);
        return true;
    }

    /**
     * Switch to a different workspace
     */
    switchWorkspace(targetWorkspaceName) {
        if (targetWorkspaceName === this.currentWorkspace) {
            console.log(`Already in workspace: ${targetWorkspaceName}`);
            return;
        }
        
        // Save current workspace data before switching
        this.saveCurrentWorkspaceData(this.currentWorkspace);
        
        // Load target workspace data
        if (this.loadWorkspaceData(targetWorkspaceName)) {
            this.currentWorkspace = targetWorkspaceName;
            localStorage.setItem('currentWorkspace', targetWorkspaceName);
            
            // Reload application data
            this.entries = JSON.parse(localStorage.getItem('activityEntries') || '[]');
            this.settings = {
                ...this.defaultSettings,
                ...JSON.parse(localStorage.getItem('activitySettings') || '{}')
            };
            this.state = this.loadState();
            
            // Re-initialize managers with new settings
            if (this.pauseManager) {
                this.pauseManager.updatePauseButtonDisplay();
            }
            if (this.pomodoroManager) {
                this.pomodoroManager.updateUI();
            }
            
            // Refresh UI
            this.displayEntries();
            this.displayTodos();
            this.displayNotes();
            this.loadSettings();
            this.updateHeaderWorkspaceName();
            
            console.log(`Switched to workspace: ${targetWorkspaceName}`);
        }
    }

    /**
     * Create a new workspace
     */
    createWorkspace(workspaceName) {
        if (!workspaceName || workspaceName.trim() === '') {
            return false;
        }
        
        const trimmedName = workspaceName.trim();
        const workspaces = JSON.parse(localStorage.getItem('workspaces') || '{}');
        
        if (workspaces[trimmedName]) {
            alert(`Workspace "${trimmedName}" already exists`);
            return false;
        }
        
        // Create new workspace with default settings structure
        workspaces[trimmedName] = {
            data: {
                activityEntries: [],
                activitySettings: { ...this.defaultSettings }, // Use default settings instead of empty object
                activityState: {}
            },
            lastModified: new Date().toISOString()
        };
        
        localStorage.setItem('workspaces', JSON.stringify(workspaces));
        console.log(`Created new workspace: ${trimmedName}`);
        return true;
    }

    /**
     * Delete a workspace
     */
    deleteWorkspace(workspaceName) {
        if (workspaceName === 'Default') {
            alert('Cannot delete the Default workspace');
            return false;
        }
        
        if (workspaceName === this.currentWorkspace) {
            alert('Cannot delete the currently active workspace');
            return false;
        }
        
        const workspaces = JSON.parse(localStorage.getItem('workspaces') || '{}');
        if (!workspaces[workspaceName]) {
            console.error(`Workspace ${workspaceName} not found`);
            return false;
        }
        
        delete workspaces[workspaceName];
        localStorage.setItem('workspaces', JSON.stringify(workspaces));
        console.log(`Deleted workspace: ${workspaceName}`);
        return true;
    }

    /**
     * Rename a workspace
     */
    renameWorkspace(oldName, newName) {
        if (!newName || newName.trim() === '') {
            return false;
        }
        
        const trimmedNewName = newName.trim();
        const workspaces = JSON.parse(localStorage.getItem('workspaces') || '{}');
        
        if (!workspaces[oldName]) {
            console.error(`Workspace ${oldName} not found`);
            return false;
        }
        
        if (workspaces[trimmedNewName]) {
            alert(`Workspace "${trimmedNewName}" already exists`);
            return false;
        }
        
        // Copy workspace data to new name
        workspaces[trimmedNewName] = workspaces[oldName];
        workspaces[trimmedNewName].lastModified = new Date().toISOString();
        
        // Remove old workspace
        delete workspaces[oldName];
        
        // Update current workspace if it was renamed
        if (this.currentWorkspace === oldName) {
            this.currentWorkspace = trimmedNewName;
            localStorage.setItem('currentWorkspace', trimmedNewName);
            this.updateHeaderWorkspaceName();
        }
        
        localStorage.setItem('workspaces', JSON.stringify(workspaces));
        console.log(`Renamed workspace ${oldName} to ${trimmedNewName}`);
        return true;
    }

    /**
     * Export all workspaces data
     */
    exportAllWorkspaces() {
        // Save current workspace before export
        this.saveCurrentWorkspaceData(this.currentWorkspace);
        
        const allData = {
            workspaces: JSON.parse(localStorage.getItem('workspaces') || '{}'),
            currentWorkspace: this.currentWorkspace,
            exportDate: new Date().toISOString(),
            version: typeof APP_VERSION !== 'undefined' ? APP_VERSION : 'Development'
        };
        
        const dataStr = JSON.stringify(allData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = `activity-tracker-all-workspaces-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        console.log('Exported all workspaces');
    }

    /**
     * Update header to show workspace name
     */
    updateHeaderWorkspaceName() {
        const header = document.querySelector('.header h1');
        if (header) {
            const baseTitle = 'Activity Tracker';
            if (this.currentWorkspace && this.currentWorkspace !== 'Default') {
                header.textContent = `${baseTitle} - ${this.currentWorkspace}`;
            } else {
                header.textContent = baseTitle;
            }
        }
    }
}


// === reports.js ===
/**
 * Reports functionality for Activity Tracker.
 * This version manually processes loops before sending to the templating engine.
 */
Object.assign(ActivityTracker.prototype, {
    
    /**
     * Initializes the report section, populating the template selector.
     */
    initReportTemplates() {
        this.templatingEngine = new TemplatingEngine();
        const templateSelector = document.getElementById('reportTemplate');
        if (!templateSelector) return;

        const templates = this.getReportTemplates();
        const defaultTemplates = window.ReportTemplates || {};
        
        templateSelector.innerHTML = Object.keys(templates).map(key => {
            const template = templates[key];
            const isCustom = !defaultTemplates[key];
            const displayName = isCustom ? `${template.name} (Custom)` : template.name;
            return `<option value="${key}">${displayName}</option>`;
        }).join('');
        
        console.log('Initialized report templates dropdown with', Object.keys(templates).length, 'templates');
    },

    /**
     * Prepares the data from entries for use in report templates.
     * @param {Array} entries - The raw activity entries.
     * @param {Date} startDate - The start date of the report.
     * @param {Date} endDate - The end date of the report.
     * @returns {object} A structured data object for the templating engine.
     */
    prepareReportData(entries, startDate, endDate) {
        console.log('Preparing report data with entries:', entries);
        
        const sortedEntries = [...entries].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        console.log('Sorted entries:', sortedEntries);
        
        const processedEntries = sortedEntries.map((entry, index) => {
            console.log('Processing entry:', entry);
            
            if (!entry.timestamp) {
                console.error('Entry missing timestamp:', entry);
            }
            
            const nextEntry = sortedEntries[index + 1];
            let endTime, duration;

            if (nextEntry) {
                endTime = new Date(nextEntry.timestamp);
                duration = Math.round((endTime - new Date(entry.timestamp)) / 60000);
            } else {
                const endOfDay = new Date(entry.timestamp);
                const [endHour, endMin] = this.settings.endTime.split(':').map(Number);
                endOfDay.setHours(endHour, endMin, 0, 0);
                endTime = new Date(Math.min(new Date(), endOfDay));
                duration = Math.round((endTime - new Date(entry.timestamp)) / 60000);
            }

            const processedEntry = { ...entry, endTime, duration };
            console.log('Processed entry:', processedEntry);
            return processedEntry;
        });

        const entriesByDate = {};
        processedEntries.forEach(entry => {
            const date = new Date(entry.timestamp).toLocaleDateString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
            if (!entriesByDate[date]) {
                entriesByDate[date] = { entries: [], totalDuration: 0 };
            }
            entriesByDate[date].entries.push(entry);
            entriesByDate[date].totalDuration += entry.duration > 0 ? entry.duration : 0;
        });

        const days = Object.keys(entriesByDate).map(date => ({
            date,
            entries: entriesByDate[date].entries,
            totalDuration: entriesByDate[date].totalDuration
        }));

        console.log('Final days structure:', days);

        const totalDuration = days.reduce((sum, day) => sum + day.totalDuration, 0);

        return {
            report: {
                startDate,
                endDate,
                generatedDate: new Date(),
                totalEntries: processedEntries.length,
                totalDuration,
                activeDays: days.length,
            },
            days: days,
            entries: processedEntries
        };
    },

    /**
     * Manually processes a template with loops.
     * @param {string} templateString - The template string.
     * @param {object} data - The report data.
     * @returns {string} The fully rendered report.
     */
    renderReport(templateString, data) {
        // Use the templating engine's built-in loop processing
        return this.templatingEngine.render(templateString, data);
    },

    /**
     * Generate and display a report based on the selected date range.
     */
    generateReport() {
        const startDateInput = document.getElementById('reportStartDate').value;
        const endDateInput = document.getElementById('reportEndDate').value;

        if (!startDateInput || !endDateInput) {
            showNotification('Please select both start and end dates', 'error');
            return;
        }

        const start = new Date(startDateInput);
        const end = new Date(endDateInput);
        end.setHours(23, 59, 59, 999);

        const includeTodos = document.getElementById('includeTodos')?.value || 'exclude';
        const includeNotes = document.getElementById('includeNotes')?.value || 'exclude';
        
        const filteredEntries = this.entries.filter(entry => {
            const entryDate = new Date(entry.timestamp);
            const isInDateRange = entryDate >= start && entryDate <= end;
            
            // Handle notes filtering
            if (entry.isNote) {
                return includeNotes === 'include' && isInDateRange;
            }
            
            // Handle todos filtering
            if (entry.isTodo) {
                switch (includeTodos) {
                    case 'exclude':
                        return false;
                    case 'incomplete':
                        // Include incomplete todos (all todos are considered incomplete for now)
                        return isInDateRange;
                    case 'all':
                        return isInDateRange;
                    default:
                        return false;
                }
            }
            
            return isInDateRange;
        });

        this.currentReportEntries = filteredEntries;
        this.currentReportData = this.prepareReportData(filteredEntries, start, end);
        
        this.previewReport();
    },

    /**
     * Render a preview of the selected report template.
     */
    previewReport() {
        const previewEl = document.getElementById('reportPreview');
        if (!previewEl) return;

        const copyBtn = document.getElementById('copyReportBtn');
        
        if (!this.currentReportData || this.currentReportEntries.length === 0) {
            previewEl.innerHTML = 'No data for the selected period. Generate a report first.';
            if (copyBtn) copyBtn.style.display = 'none';
            return;
        }

        const templateKey = document.getElementById('reportTemplate').value;
        const templates = this.getReportTemplates();
        const template = templates[templateKey];

        if (!template) {
            previewEl.textContent = 'Error: Selected report template not found.';
            if (copyBtn) copyBtn.style.display = 'none';
            return;
        }

        // Check which tab is active
        const renderedTab = document.getElementById('reportPreviewTabRendered');
        const isRenderedView = renderedTab && renderedTab.classList.contains('active');

        try {
            const renderedContent = this.renderReport(template.template, this.currentReportData);
            
            if (isRenderedView) {
                // Show rendered view
                if (template.type === 'html') {
                    previewEl.innerHTML = `<iframe srcdoc="${this.templatingEngine.escapeHtml(renderedContent)}" style="width: 100%; height: 450px; border: none;"></iframe>`;
                } else if (template.type === 'markdown' && this.markdownRenderer) {
                    // Render markdown to HTML
                    const htmlContent = this.markdownRenderer.render(renderedContent);
                    previewEl.innerHTML = htmlContent;
                } else {
                    // Show as formatted text
                    previewEl.innerHTML = `<pre>${this.templatingEngine.escapeHtml(renderedContent)}</pre>`;
                }
            } else {
                // Show source view
                previewEl.innerHTML = `<pre>${this.templatingEngine.escapeHtml(renderedContent)}</pre>`;
            }
            // Show copy button when there's content
            if (copyBtn) copyBtn.style.display = 'inline-block';
        } catch (error) {
            previewEl.textContent = 'Error generating preview: ' + error.message;
            if (copyBtn) copyBtn.style.display = 'none';
        }
    },

    /**
     * Download the report using the selected template.
     */
    downloadReport() {
        if (!this.currentReportData || this.currentReportEntries.length === 0) {
            showNotification('Please generate a report with data first', 'error');
            return;
        }

        const templateKey = document.getElementById('reportTemplate').value;
        const templates = this.getReportTemplates();
        const template = templates[templateKey];
        const startDate = this.currentReportData.report.startDate;
        const endDate = this.currentReportData.report.endDate;

        const content = this.renderReport(template.template, this.currentReportData);
        
        const fileExtension = template.type;
        const mimeType = {
            html: 'text/html',
            markdown: 'text/markdown',
            csv: 'text/csv'
        }[fileExtension] || 'text/plain';

        const filename = `activity-report-${this.templatingEngine.formatDate(startDate, 'yyyy-mm-dd')}-to-${this.templatingEngine.formatDate(endDate, 'yyyy-mm-dd')}.${fileExtension}`;

        downloadFile(content, filename, mimeType);
        showNotification(`Report downloaded as ${template.name}`, 'success');
    },

    /**
     * Open the report in a new tab/window.
     */
    openReportInNewTab() {
        if (!this.currentReportData || this.currentReportEntries.length === 0) {
            showNotification('Please generate a report with data first', 'error');
            return;
        }

        const templateKey = document.getElementById('reportTemplate').value;
        const templates = this.getReportTemplates();
        const template = templates[templateKey];
        const startDate = this.currentReportData.report.startDate;
        const endDate = this.currentReportData.report.endDate;

        const content = this.renderReport(template.template, this.currentReportData);
        
        // Create appropriate content for new tab based on file type
        let finalContent = content;
        let mimeType = 'text/plain';
        
        if (template.type === 'html') {
            // For HTML, wrap in a complete HTML document
            const title = `Activity Report ${this.templatingEngine.formatDate(startDate, 'yyyy-mm-dd')} to ${this.templatingEngine.formatDate(endDate, 'yyyy-mm-dd')}`;
            finalContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }
        table { border-collapse: collapse; width: 100%; margin: 1em 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        h1, h2, h3 { color: #333; }
        .hashtag { color: #38a169; font-weight: 500; }
    </style>
</head>
<body>
${content}
</body>
</html>`;
            mimeType = 'text/html';
        } else if (template.type === 'markdown') {
            // For Markdown, wrap in HTML with basic styling
            const title = `Activity Report ${this.templatingEngine.formatDate(startDate, 'yyyy-mm-dd')} to ${this.templatingEngine.formatDate(endDate, 'yyyy-mm-dd')}`;
            finalContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }
        pre { white-space: pre-wrap; font-family: 'Monaco', 'Courier New', monospace; background: #f5f5f5; padding: 15px; border-radius: 5px; }
    </style>
</head>
<body>
    <pre>${content.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
</body>
</html>`;
            mimeType = 'text/html';
        } else if (template.type === 'csv') {
            // For CSV, show in a pre-formatted text display
            const title = `Activity Report ${this.templatingEngine.formatDate(startDate, 'yyyy-mm-dd')} to ${this.templatingEngine.formatDate(endDate, 'yyyy-mm-dd')}`;
            finalContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body { font-family: 'Monaco', 'Courier New', monospace; line-height: 1.4; max-width: 1200px; margin: 0 auto; padding: 20px; }
        pre { white-space: pre-wrap; background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>Activity Report (CSV Format)</h1>
    <pre>${content.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
</body>
</html>`;
            mimeType = 'text/html';
        }

        try {
            // Create blob and object URL
            const blob = new Blob([finalContent], { type: mimeType });
            const url = URL.createObjectURL(blob);
            
            // Open in new tab
            const newWindow = window.open(url, '_blank');
            
            // Clean up the object URL after a delay
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 1000);
            
            if (newWindow) {
                showNotification(`Report opened in new tab`, 'success');
            } else {
                showNotification('Please allow popups for this site to open reports in new tabs', 'warning');
            }
        } catch (error) {
            console.error('Error opening report in new tab:', error);
            showNotification('Error opening report in new tab. Try downloading instead.', 'error');
        }
    },

    /**
     * Set report to the current week.
     */
    setWeeklyReport() {
        const now = new Date();
        this.currentWeekStart = getWeekStart(now);
        this.updateWeekFromCurrent();
        this.generateReport();
    },

    /**
     * Navigate to the previous week.
     */
    previousWeek() {
        if (!this.currentWeekStart) this.currentWeekStart = getWeekStart(new Date());
        this.currentWeekStart.setDate(this.currentWeekStart.getDate() - 7);
        this.updateWeekFromCurrent();
        this.generateReport();
    },

    /**
     * Navigate to the next week.
     */
    nextWeek() {
        if (!this.currentWeekStart) this.currentWeekStart = getWeekStart(new Date());
        this.currentWeekStart.setDate(this.currentWeekStart.getDate() + 7);
        this.updateWeekFromCurrent();
        this.generateReport();
    },

    /**
     * Update date inputs from the current week start date.
     */
    updateWeekFromCurrent() {
        const monday = new Date(this.currentWeekStart);
        const sunday = getWeekEnd(monday);

        document.getElementById('reportStartDate').value = monday.toISOString().split('T')[0];
        document.getElementById('reportEndDate').value = sunday.toISOString().split('T')[0];
        
        this.updateWeekDisplay();
    },

    /**
     * Update the week display text.
     */
    updateWeekDisplay() {
        if (!this.currentWeekStart) return;
        
        const monday = new Date(this.currentWeekStart);
        const sunday = getWeekEnd(monday);

        const weekText = `Week of ${monday.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' })} - ${sunday.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' })}`;
        
        document.getElementById('weekDisplay').textContent = weekText;
    }
});

// Helper functions for date calculations
function getWeekStart(d) {
    d = new Date(d);
    const day = d.getDay();
    const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Adjust when day is Sunday
    return new Date(d.setDate(diff));
}

function getWeekEnd(d) {
    const start = getWeekStart(d);
    const end = new Date(start);
    end.setDate(start.getDate() + 6);
    return end;
}


// === main.js ===
/**
 * Main initialization and global functions for Activity Tracker
 * This file handles app initialization, global event handlers, and UI functions
 */

// Global tracker instance
let tracker;

/**
 * Show a specific section and update navigation
 * @param {string} sectionName - Name of section to show
 * @param {Event} event - Click event (optional)
 */
function showSection(sectionName, event) {
    // Hide all sections
    document.querySelectorAll('.section').forEach(section => {
        section.classList.remove('active');
    });
    
    // Show target section
    document.getElementById(sectionName).classList.add('active');

    // Update navigation buttons
    document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.classList.remove('active');
    });

    if (event && event.target) {
        event.target.classList.add('active');
    } else {
        const button = document.querySelector(`.nav-btn[onclick*="'${sectionName}'"]`);
        if (button) {
            button.classList.add('active');
        }
    }

    // Focus on entry input when showing tracker, todo, or notes (if form is visible)
    if (sectionName === 'tracker' || sectionName === 'todo' || sectionName === 'notes') {
        setTimeout(() => {
            const inputId = sectionName === 'tracker' ? 'activity' : 
                           sectionName === 'todo' ? 'todoActivity' : 'notesActivity';
            const input = document.getElementById(inputId);
            const component = document.getElementById(`${sectionName}EntryComponent`);
            
            // Only focus if the form is visible (not collapsed)
            if (input && component && !component.classList.contains('collapsed')) {
                input.focus();
            }
        }, 100);
    }

    // Auto-generate report if switching to reports tab and it's empty
    if (sectionName === 'reports') {
        const reportResults = document.getElementById('reportResults');
        if (tracker && (!reportResults || !reportResults.innerHTML.trim())) {
            tracker.setWeeklyReport(); // This will now auto-generate
        }
    }
}

/**
 * Add current time to timestamp input
 */
function addCurrentTime() {
    if (tracker) {
        tracker.setCurrentTime();
    }
}

/**
 * Generate sound option elements for dropdowns
 * @param {Array} excludeSounds - Array of sound keys to exclude (e.g., tick sounds)
 * @param {string} selectedValue - Currently selected value
 * @returns {string} HTML string of option elements
 */
function generateSoundOptions(excludeSounds = [], selectedValue = '') {
    // Get all available sounds from SoundManager
    const allSounds = {
        'classic': 'Classic Bloop',
        'gentle': 'Gentle Chime', 
        'urgent': 'Urgent Ping',
        'digital': 'Digital Beep',
        'nature': 'Nature Drop',
        'mechanical': 'Mechanical Click',
        'spacey': 'Spacey Wobble',
        'corporate': 'Corporate Ding',
        'retro': 'Retro Arcade',
        'piano': 'Piano Note',
        'bell': 'Temple Bell',
        'whistle': 'Train Whistle',
        'bubble': 'Bubble Pop',
        'glass': 'Glass Tap',
        'wood': 'Wood Block',
        'metal': 'Metal Ting',
        'ethereal': 'Ethereal Hum',
        'cosmic': 'Cosmic Blip',
        'ocean': 'Ocean Wave',
        'forest': 'Forest Chirp',
        'failsafe': 'Failsafe'
    };
    
    return Object.entries(allSounds)
        .filter(([key]) => !excludeSounds.includes(key))
        .sort(([, nameA], [, nameB]) => nameA.localeCompare(nameB))
        .map(([key, name]) => {
            const selected = key === selectedValue ? ' selected' : '';
            return `<option value="${key}"${selected}>${name}</option>`;
        })
        .join('');
}

/**
 * Generate report based on selected dates
 */
function generateReport() {
    if (tracker) {
        tracker.generateReport();
    }
}

/**
 * Set report to current week
 */
function setWeeklyReport() {
    if (tracker) {
        tracker.setWeeklyReport();
    }
}

/**
 * Navigate to previous week in reports
 */
function previousWeek() {
    if (tracker) {
        tracker.previousWeek();
    }
}

/**
 * Navigate to next week in reports
 */
function nextWeek() {
    if (tracker) {
        tracker.nextWeek();
    }
}

/**
 * Download current report
 */
function downloadReport() {
    if (tracker) {
        tracker.downloadReport();
    }
}

/**
 * Open report in new tab
 */
function openReportInNewTab() {
    if (tracker) {
        tracker.openReportInNewTab();
    }
}

/**
 * Save settings
 */
function saveSettings() {
    if (tracker) {
        tracker.saveSettings();
    }
}

/**
 * Enable notifications
 */
function enableNotifications() {
    if (tracker) {
        tracker.toggleActivityReminders();
    }
}

/**
 * Test notification
 */
function testNotification() {
    if (tracker) {
        tracker.testNotification();
    }
}

/**
 * Test notification sound
 */
function testNotificationSound() {
    if (tracker) {
        tracker.testNotificationSound();
    }
}

/**
 * Preview notification sound when selection changes
 */
function previewNotificationSound() {
    const soundType = document.getElementById('notificationSoundType').value;
    
    if (tracker && tracker.soundManager && !tracker.isNotificationSoundMuted()) {
        tracker.soundManager.playSound(soundType, false);
    }
}

/**
 * Show template guide modal
 */
function showTemplateGuide() {
    const modal = document.getElementById('templateGuideModal');
    if (modal) {
        modal.style.display = 'block';
    }
}

/**
 * Close template guide modal
 */
function closeTemplateGuide() {
    const modal = document.getElementById('templateGuideModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

/**
 * Show About modal
 */
function showAbout() {
    const modal = document.getElementById('aboutModal');
    if (modal) {
        modal.style.display = 'block';
        // Update debug info when modal opens
        if (tracker) {
            tracker.updateAboutDebugInfo();
        }
        // Update copyright year
        updateCopyrightYear();
    }
}

/**
 * Update the copyright year display with dynamic range
 */
function updateCopyrightYear() {
    const startYear = 2025;
    const currentYear = new Date().getFullYear();
    
    let yearText;
    if (currentYear === startYear) {
        yearText = startYear.toString();
    } else if (currentYear > startYear) {
        yearText = `${startYear}-${currentYear}`;
    } else {
        // Fallback for years before 2025 (shouldn't happen in practice)
        yearText = startYear.toString();
    }
    
    // Update both copyright year elements
    const copyrightYearElement = document.getElementById('copyrightYear');
    if (copyrightYearElement) {
        copyrightYearElement.textContent = yearText;
    }
    
    const copyrightYearRangeElement = document.getElementById('copyrightYearRange');
    if (copyrightYearRangeElement) {
        copyrightYearRangeElement.textContent = yearText;
    }
}

/**
 * Position burger menu relative to anchor element
 */
function positionBurgerMenu() {
    const burgerMenu = document.querySelector('.burger-menu');
    const burgerAnchor = document.getElementById('burgerAnchor');
    
    if (!burgerMenu || !burgerAnchor) return;
    
    // Ensure the anchor is visible and has layout
    if (!burgerAnchor.offsetParent && burgerAnchor.style.display !== 'block') {
        return;
    }
    
    const anchorRect = burgerAnchor.getBoundingClientRect();
    
    // Check if anchor has valid dimensions
    if (anchorRect.width === 0 && anchorRect.height === 0) {
        return;
    }
    
    // Position burger menu relative to the anchor with some offset
    const topPosition = Math.max(0, anchorRect.top + 10);
    const rightPosition = Math.max(10, window.innerWidth - anchorRect.right + 10);
    
    burgerMenu.style.top = `${topPosition}px`;
    burgerMenu.style.right = `${rightPosition}px`;
    
    // Ensure burger menu is visible after positioning
    burgerMenu.style.visibility = 'visible';
    burgerMenu.style.opacity = '1';
}

/**
 * Close About modal
 */
function closeAbout() {
    const modal = document.getElementById('aboutModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

/**
 * Request notification permission (called from HTML)
 */
function requestNotificationPermission() {
    if (tracker) {
        tracker.requestNotificationPermission();
    }
}

/**
 * Decline notification permission (called from HTML)
 */
function declineNotificationPermission() {
    if (tracker) {
        tracker.declineNotificationPermission();
    }
}

/**
 * Force enable notification capability for diagnostics
 */
function forceEnableNotifications() {
    if (tracker) {
        tracker.forceEnableNotificationCapability();
    }
}

/**
 * Show User Guide modal
 */
function showUserGuide() {
    const modal = document.getElementById('userGuideModal');
    if (modal) {
        modal.style.display = 'block';
    }
}

/**
 * Close User Guide modal
 */
function closeUserGuide() {
    const modal = document.getElementById('userGuideModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

/**
 * Set due date using quick-set buttons
 * @param {string} period - 'tomorrow', 'nextWeek', or 'nextMonth'
 */
function setDueDate(period) {
    const dueDateInput = document.getElementById('dueDate');
    if (!dueDateInput) return;

    const now = new Date();
    let targetDate;

    switch (period) {
        case 'tomorrow':
            targetDate = new Date(now);
            targetDate.setDate(now.getDate() + 1);
            targetDate.setHours(9, 0, 0, 0); // Set to 9 AM
            break;
        case 'nextWeek':
            targetDate = new Date(now);
            targetDate.setDate(now.getDate() + 7);
            targetDate.setHours(9, 0, 0, 0); // Set to 9 AM
            break;
        case 'nextMonth':
            targetDate = new Date(now);
            targetDate.setMonth(now.getMonth() + 1);
            targetDate.setHours(9, 0, 0, 0); // Set to 9 AM
            break;
        default:
            return;
    }

    dueDateInput.value = targetDate.toISOString().slice(0, 16);
}

/**
 * Set due date using quick-set buttons for edit modal
 * @param {string} period - 'tomorrow', 'nextWeek', or 'nextMonth'
 */
function setEditDueDate(period) {
    const dueDateInput = document.getElementById('editDueDate');
    if (!dueDateInput) return;

    const now = new Date();
    let targetDate;

    switch (period) {
        case 'tomorrow':
            targetDate = new Date(now);
            targetDate.setDate(now.getDate() + 1);
            targetDate.setHours(9, 0, 0, 0); // Set to 9 AM
            break;
        case 'nextWeek':
            targetDate = new Date(now);
            targetDate.setDate(now.getDate() + 7);
            targetDate.setHours(9, 0, 0, 0); // Set to 9 AM
            break;
        case 'nextMonth':
            targetDate = new Date(now);
            targetDate.setMonth(now.getMonth() + 1);
            targetDate.setHours(9, 0, 0, 0); // Set to 9 AM
            break;
        default:
            return;
    }

    dueDateInput.value = targetDate.toISOString().slice(0, 16);
}

/**
 * Copy report content to clipboard
 */
function copyReportToClipboard() {
    const reportPreview = document.getElementById('reportPreview');
    const isRenderedView = document.getElementById('reportPreviewTabRendered').classList.contains('active');
    
    let textToCopy = '';
    
    if (isRenderedView) {
        // For rendered view, try to get clean text content
        const iframe = reportPreview.querySelector('iframe');
        if (iframe && iframe.contentDocument) {
            textToCopy = iframe.contentDocument.body.innerText || iframe.contentDocument.body.textContent;
        } else {
            textToCopy = reportPreview.innerText || reportPreview.textContent;
        }
    } else {
        // For source view, get the raw content
        textToCopy = reportPreview.innerText || reportPreview.textContent;
    }
    
    if (textToCopy && textToCopy.trim()) {
        navigator.clipboard.writeText(textToCopy).then(() => {
            showNotification('Report copied to clipboard!', 'success');
        }).catch(() => {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = textToCopy;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            showNotification('Report copied to clipboard!', 'success');
        });
    } else {
        showNotification('No report content to copy', 'error');
    }
}

/**
 * Refresh notification status
 */
function refreshNotificationStatus() {
    if (tracker) {
        tracker.refreshNotificationStatus();
    }
}

/**
 * Clear all application data
 */
function clearAllData() {
    if (tracker) {
        tracker.clearAllData();
    }
}

/**
 * Close edit modal
 */
function closeEditModal() {
    if (tracker) {
        tracker.closeEditModal();
    }
}

/**
 * Close modal by ID
 */
function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.style.display = 'none';
    }
}

/**
 * Show hashtag browser modal with cloud visualization
 */
function showHashtagBrowser() {
    const modal = document.getElementById('hashtagBrowserModal');
    if (!modal) return;
    
    // Generate hashtag cloud
    const hashtagFrequency = tracker.getHashtagFrequency();
    const cloudContainer = modal.querySelector('.hashtag-cloud');
    const countElement = modal.querySelector('#hashtagCount');
    
    const hashtagCount = Object.keys(hashtagFrequency).length;
    
    // Update count display
    if (countElement) {
        countElement.textContent = `${hashtagCount} hashtag${hashtagCount !== 1 ? 's' : ''} found`;
    }
    
    if (hashtagCount === 0) {
        cloudContainer.innerHTML = '<p class="empty-state">No hashtags found. Add activities with #hashtags to see them here!</p>';
    } else {
        const maxFreq = Math.max(...Object.values(hashtagFrequency));
        const minFreq = Math.min(...Object.values(hashtagFrequency));
        const range = maxFreq - minFreq || 1;
        
        const hashtagElements = Object.entries(hashtagFrequency)
            .sort(([,a], [,b]) => b - a) // Sort by frequency desc
            .map(([tag, freq]) => {
                const normalized = (freq - minFreq) / range;
                const fontSize = 0.8 + (normalized * 1.2); // 0.8em to 2.0em
                const opacity = 0.6 + (normalized * 0.4); // 0.6 to 1.0
                
                return `<span class="hashtag-cloud-item" 
                              style="font-size: ${fontSize}em; opacity: ${opacity};"
                              onclick="tracker.searchByHashtag('${tag}'); closeModal('hashtagBrowserModal');"
                              title="${freq} occurrence${freq !== 1 ? 's' : ''}">#${tag}</span>`;
            })
            .join(' ');
        
        cloudContainer.innerHTML = hashtagElements;
    }
    
    modal.style.display = 'block';
}

/**
 * Close hashtag browser modal
 */
function closeHashtagBrowser() {
    closeModal('hashtagBrowserModal');
}

/**
 * Toggle todo mode for activity form
 */
function toggleTodoMode() {
    const btn = document.getElementById('todoToggleBtn');
    if (!btn) return;
    
    const isActive = btn.classList.contains('active');
    const dueDateSection = document.getElementById('dueDateSection');
    
    if (isActive) {
        btn.classList.remove('active');
        btn.textContent = 'Mark as Todo';
        // Hide due date section when not in todo mode
        if (dueDateSection) {
            dueDateSection.style.display = 'none';
        }
    } else {
        btn.classList.add('active');
        btn.textContent = ' Todo';
        // Show due date section when in todo mode
        if (dueDateSection) {
            dueDateSection.style.display = 'block';
        }
    }
    
    // Update form labels and examples
    updateFormLabelsAndExamples('tracker');
}

/**
 * Check if todo mode is active
 */
function isTodoModeActive() {
    const btn = document.getElementById('todoToggleBtn');
    return btn ? btn.classList.contains('active') : false;
}

/**
 * Toggle note mode for activity form
 */
function toggleNoteMode() {
    const btn = document.getElementById('noteToggleBtn');
    if (!btn) return;
    
    const isActive = btn.classList.contains('active');
    
    if (isActive) {
        btn.classList.remove('active');
        btn.textContent = 'Mark as Note';
    } else {
        btn.classList.add('active');
        btn.textContent = ' Note';
    }
    
    // Update form labels and examples
    updateFormLabelsAndExamples('tracker');
}

/**
 * Check if note mode is active
 */
function isNoteModeActive() {
    const btn = document.getElementById('noteToggleBtn');
    return btn ? btn.classList.contains('active') : false;
}

/**
 * Update form labels and placeholders based on current mode flags
 */
function updateFormLabelsAndExamples(context = 'tracker') {
    const isTodo = context === 'tracker' ? isTodoModeActive() : 
                   context === 'todo' ? document.getElementById('todoTodoToggleBtn')?.classList.contains('active') :
                   document.getElementById('notesTodToggleBtn')?.classList.contains('active');
    
    const isNote = context === 'tracker' ? isNoteModeActive() :
                   context === 'todo' ? document.getElementById('todoNoteToggleBtn')?.classList.contains('active') :
                   document.getElementById('notesNoteToggleBtn')?.classList.contains('active');
    
    let prefix = context === 'tracker' ? '' : context;
    let titleElement, activityLabel, activityInput, descriptionLabel, descriptionInput, addButton;
    
    if (context === 'tracker') {
        titleElement = document.getElementById('entryTitle');
        activityLabel = document.getElementById('activityLabel');
        activityInput = document.getElementById('activity');
        descriptionLabel = document.getElementById('descriptionLabel');
        descriptionInput = document.getElementById('description');
        addButton = document.getElementById('addEntryBtn');
    } else if (context === 'todo') {
        titleElement = document.getElementById('todoEntryTitle');
        activityLabel = document.getElementById('todoActivityLabel');
        activityInput = document.getElementById('todoActivity');
        descriptionLabel = document.getElementById('todoDescriptionLabel');
        descriptionInput = document.getElementById('todoDescription');
        addButton = document.getElementById('todoAddEntryBtn');
    } else if (context === 'notes') {
        titleElement = document.getElementById('notesEntryTitle');
        activityLabel = document.getElementById('notesActivityLabel');
        activityInput = document.getElementById('notesActivity');
        descriptionLabel = document.getElementById('notesDescriptionLabel');
        descriptionInput = document.getElementById('notesDescription');
        addButton = document.getElementById('notesAddEntryBtn');
    }
    
    // Update based on flag combinations
    if (isTodo && isNote) {
        // Both flags active - Todo Note
        if (titleElement) titleElement.textContent = context === 'tracker' ? 'New Todo Note' : 'New Todo Note';
        if (activityLabel) activityLabel.textContent = 'What do you need to note and do?';
        if (activityInput) activityInput.placeholder = 'e.g., Research budget options, Review meeting agenda #work';
        if (descriptionLabel) descriptionLabel.textContent = 'Note details and todo description';
        if (descriptionInput) descriptionInput.placeholder = 'Capture your notes and describe what needs to be done...';
        if (addButton) addButton.textContent = 'Add Todo Note';
    } else if (isTodo) {
        // Only todo flag active
        if (titleElement) titleElement.textContent = context === 'tracker' ? 'New Todo Item' : 'New Todo Item';
        if (activityLabel) activityLabel.textContent = 'What do you need to do?';
        if (activityInput) activityInput.placeholder = 'e.g., Call client about project, Review budget #work';
        if (descriptionLabel) descriptionLabel.textContent = 'Todo description (optional)';
        if (descriptionInput) descriptionInput.placeholder = 'Additional details about this task, steps needed, context...';
        if (addButton) addButton.textContent = 'Add Todo';
    } else if (isNote) {
        // Only note flag active
        if (titleElement) titleElement.textContent = context === 'tracker' ? 'New Note' : 'New Note';
        if (activityLabel) activityLabel.textContent = 'Note title or topic';
        if (activityInput) activityInput.placeholder = 'e.g., Meeting notes, Ideas for project #brainstorm';
        if (descriptionLabel) descriptionLabel.textContent = 'Note content';
        if (descriptionInput) descriptionInput.placeholder = 'Write your note content, ideas, observations, or thoughts here...';
        if (addButton) addButton.textContent = 'Add Note';
    } else {
        // Neither flag active - regular activity
        if (titleElement) titleElement.textContent = context === 'tracker' ? 'Activity Entry' : 'New Activity';
        if (activityLabel) activityLabel.textContent = 'What are you doing?';
        if (activityInput) activityInput.placeholder = 'e.g., Writing report, Meeting with team #work';
        if (descriptionLabel) descriptionLabel.textContent = 'Description (optional)';
        if (descriptionInput) descriptionInput.placeholder = 'Additional details about this activity...';
        if (addButton) addButton.textContent = 'Add Entry';
    }
}

// === Todo Section Toggle Functions ===

/**
 * Toggle todo mode for todo section form
 */
function toggleTodoModeForTodo() {
    const btn = document.getElementById('todoTodoToggleBtn');
    if (!btn) return;
    
    const isActive = btn.classList.contains('active');
    const dueDateSection = document.getElementById('todoDueDateSection');
    
    if (isActive) {
        btn.classList.remove('active');
        btn.textContent = 'Mark as Todo';
        if (dueDateSection) dueDateSection.style.display = 'none';
    } else {
        btn.classList.add('active');
        btn.textContent = ' Todo';
        if (dueDateSection) dueDateSection.style.display = 'block';
    }
    
    updateFormLabelsAndExamples('todo');
}

/**
 * Toggle note mode for todo section form
 */
function toggleNoteModeForTodo() {
    const btn = document.getElementById('todoNoteToggleBtn');
    if (!btn) return;
    
    const isActive = btn.classList.contains('active');
    
    if (isActive) {
        btn.classList.remove('active');
        btn.textContent = 'Mark as Note';
    } else {
        btn.classList.add('active');
        btn.textContent = ' Note';
    }
    
    updateFormLabelsAndExamples('todo');
}

// === Notes Section Toggle Functions ===

/**
 * Toggle todo mode for notes section form
 */
function toggleTodoModeForNotes() {
    const btn = document.getElementById('notesTodToggleBtn');
    if (!btn) return;
    
    const isActive = btn.classList.contains('active');
    const dueDateSection = document.getElementById('notesDueDateSection');
    
    if (isActive) {
        btn.classList.remove('active');
        btn.textContent = 'Mark as Todo';
        if (dueDateSection) dueDateSection.style.display = 'none';
    } else {
        btn.classList.add('active');
        btn.textContent = ' Todo';
        if (dueDateSection) dueDateSection.style.display = 'block';
    }
    
    updateFormLabelsAndExamples('notes');
}

/**
 * Toggle note mode for notes section form
 */
function toggleNoteModeForNotes() {
    const btn = document.getElementById('notesNoteToggleBtn');
    if (!btn) return;
    
    const isActive = btn.classList.contains('active');
    
    if (isActive) {
        btn.classList.remove('active');
        btn.textContent = 'Mark as Note';
    } else {
        btn.classList.add('active');
        btn.textContent = ' Note';
    }
    
    updateFormLabelsAndExamples('notes');
}

// === Helper Functions for New Forms ===

/**
 * Adjust due date by adding or subtracting time periods
 * @param {string} inputId - ID of the datetime input field
 * @param {number} amount - Amount to adjust (positive or negative)
 * @param {string} unit - 'day', 'week', or 'month'
 */
function adjustDueDate(inputId, amount, unit) {
    const dueDateInput = document.getElementById(inputId);
    if (!dueDateInput) return;

    // Use current date from input field, or current time if empty
    let baseDate;
    if (dueDateInput.value) {
        baseDate = new Date(dueDateInput.value);
    } else {
        baseDate = new Date();
        baseDate.setHours(9, 0, 0, 0); // Default to 9 AM for new dates
    }

    let newDate = new Date(baseDate);

    switch (unit) {
        case 'day':
            newDate.setDate(baseDate.getDate() + amount);
            break;
        case 'week':
            newDate.setDate(baseDate.getDate() + (amount * 7));
            break;
        case 'month':
            newDate.setMonth(baseDate.getMonth() + amount);
            break;
        default:
            return;
    }

    dueDateInput.value = newDate.toISOString().slice(0, 16);
}

/**
 * Set due date for todo form
 */
function setDueDateForTodo(preset) {
    setDueDatePreset('todoDueDate', preset);
}

/**
 * Set due date for notes form
 */
function setDueDateForNotes(preset) {
    setDueDatePreset('notesDueDate', preset);
}

/**
 * Add current time for todo form
 */
function addCurrentTimeForTodo() {
    setCurrentDateTime('todoTimestamp');
}

/**
 * Add current time for notes form
 */
function addCurrentTimeForNotes() {
    setCurrentDateTime('notesTimestamp');
}

/**
 * Update due date section visibility for main activity form
 */
function updateDueDateSectionVisibility() {
    const todoBtn = document.getElementById('todoToggleBtn');
    const dueDateSection = document.getElementById('dueDateSection');
    
    if (dueDateSection) {
        // Show due date section only if todo mode is active
        if (todoBtn && todoBtn.classList.contains('active')) {
            dueDateSection.style.display = 'block';
        } else {
            dueDateSection.style.display = 'none';
        }
    }
}

/**
 * Reset activity form to defaults
 */
function resetActivityForm() {
    const form = document.getElementById('activityForm');
    if (form) {
        // Clear due date first (before form.reset() which might not clear datetime-local properly)
        const dueDateInput = document.getElementById('dueDate');
        if (dueDateInput) {
            dueDateInput.value = '';
        }
        
        form.reset();
        
        // Set timestamp to current time
        setCurrentDateTime('timestamp');
        
        // Explicitly clear due date again to ensure it's null
        if (dueDateInput) {
            dueDateInput.value = '';
        }
        
        // Reset todo/note buttons
        const todoBtn = document.getElementById('todoToggleBtn');
        const noteBtn = document.getElementById('noteToggleBtn');
        if (todoBtn) {
            todoBtn.classList.remove('active');
            todoBtn.textContent = 'Mark as Todo';
        }
        if (noteBtn) {
            noteBtn.classList.remove('active');
            noteBtn.textContent = 'Mark as Note';
        }
        // Reset due date section visibility
        updateDueDateSectionVisibility();
    }
}

/**
 * Reset todo form to defaults
 */
function resetTodoForm() {
    const form = document.getElementById('todoActivityForm');
    if (form) {
        // Clear due date first (before form.reset() which might not clear datetime-local properly)
        const dueDateInput = document.getElementById('todoDueDate');
        if (dueDateInput) {
            dueDateInput.value = '';
        }
        
        form.reset();
        
        // Set timestamp to current time
        setCurrentDateTime('todoTimestamp');
        
        // Explicitly clear due date again to ensure it's null
        if (dueDateInput) {
            dueDateInput.value = '';
        }
        
        // Reset todo/note buttons but keep todo active (this is the todo section)
        const todoBtn = document.getElementById('todoTodoToggleBtn');
        const noteBtn = document.getElementById('todoNoteToggleBtn');
        if (todoBtn) {
            todoBtn.classList.add('active');
            todoBtn.textContent = 'Mark as Todo ';
        }
        if (noteBtn) {
            noteBtn.classList.remove('active');
            noteBtn.textContent = 'Mark as Note';
        }
        // Keep due date section visible since todo mode is active
        const dueDateSection = document.getElementById('todoDueDateSection');
        if (dueDateSection) {
            dueDateSection.style.display = 'block';
        }
    }
}

/**
 * Reset notes form to defaults
 */
function resetNotesForm() {
    const form = document.getElementById('notesActivityForm');
    if (form) {
        // Clear due date first (before form.reset() which might not clear datetime-local properly)
        const dueDateInput = document.getElementById('notesDueDate');
        if (dueDateInput) {
            dueDateInput.value = '';
        }
        
        form.reset();
        
        // Set timestamp to current time
        setCurrentDateTime('notesTimestamp');
        
        // Explicitly clear due date again to ensure it's null
        if (dueDateInput) {
            dueDateInput.value = '';
        }
        
        // Reset todo/note buttons but keep note active (this is the notes section)
        const todoBtn = document.getElementById('notesTodToggleBtn');
        const noteBtn = document.getElementById('notesNoteToggleBtn');
        if (todoBtn) {
            todoBtn.classList.remove('active');
            todoBtn.textContent = 'Mark as Todo';
        }
        if (noteBtn) {
            noteBtn.classList.add('active');
            noteBtn.textContent = 'Mark as Note ';
        }
        // Hide due date section since notes don't use due dates by default
        const dueDateSection = document.getElementById('notesDueDateSection');
        if (dueDateSection) {
            dueDateSection.style.display = 'none';
        }
    }
}

/**
 * Initialize all form timestamps to current time on page load
 */
function initializeFormTimestamps() {
    // Set all timestamp fields to current time
    const timestampFields = ['timestamp', 'todoTimestamp', 'notesTimestamp'];
    timestampFields.forEach(fieldId => {
        setCurrentDateTime(fieldId);
    });
}

/**
 * Set current date/time for any field
 */
function setCurrentDateTime(fieldId) {
    const field = document.getElementById(fieldId);
    if (field) {
        const now = new Date();
        field.value = now.toISOString().slice(0, 16);
    }
}

/**
 * Escape HTML to prevent XSS
 */
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// === Due Date System ===

/**
 * Format time remaining until due date in human-friendly format
 */
function formatTimeUntilDue(dueDate) {
    if (!dueDate) return null;
    
    const now = new Date();
    const due = new Date(dueDate);
    const diffMs = due.getTime() - now.getTime();
    
    // If overdue
    if (diffMs < 0) {
        const overdueDiffMs = Math.abs(diffMs);
        const overdueDays = Math.floor(overdueDiffMs / (1000 * 60 * 60 * 24));
        const overdueHours = Math.floor((overdueDiffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const overdueMinutes = Math.floor((overdueDiffMs % (1000 * 60 * 60)) / (1000 * 60));
        
        if (overdueDays > 0) {
            return `${overdueDays} day${overdueDays === 1 ? '' : 's'} overdue`;
        } else if (overdueHours > 0) {
            return `${overdueHours} hour${overdueHours === 1 ? '' : 's'} overdue`;
        } else if (overdueMinutes > 0) {
            return `${overdueMinutes} minute${overdueMinutes === 1 ? '' : 's'} overdue`;
        } else {
            return 'Just overdue';
        }
    }
    
    // Time remaining
    const days = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    const hours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
    
    if (days > 0) {
        return `${days} day${days === 1 ? '' : 's'} till due`;
    } else if (hours > 0) {
        return `${hours} hour${hours === 1 ? '' : 's'} till due`;
    } else if (minutes > 0) {
        return `${minutes} minute${minutes === 1 ? '' : 's'} till due`;
    } else {
        return 'Due now';
    }
}

/**
 * Check if an item is overdue
 */
function isOverdue(dueDate) {
    if (!dueDate) return false;
    return new Date(dueDate) < new Date();
}

/**
 * Get overdue items sorted by most overdue first
 */
function getOverdueItems() {
    if (!tracker || !tracker.entries) return [];
    
    const overdueItems = tracker.entries.filter(entry => 
        entry.dueDate && entry.isTodo && isOverdue(entry.dueDate)
    );
    
    // Sort by most overdue first (oldest due date first)
    return overdueItems.sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate));
}

/**
 * Update overdue alert button visibility
 */
function updateOverdueAlertButton() {
    const alertButton = document.getElementById('overdueAlertButton');
    if (!alertButton) return;
    
    const overdueItems = getOverdueItems();
    
    if (overdueItems.length > 0) {
        alertButton.style.display = '';
        alertButton.textContent = ` Alert (${overdueItems.length})`;
        alertButton.title = `${overdueItems.length} item${overdueItems.length === 1 ? '' : 's'} overdue`;
    } else {
        alertButton.style.display = 'none';
    }
}

/**
 * Show overdue alert modal
 */
function showOverdueAlert() {
    const modal = document.getElementById('overdueAlertModal');
    const itemsList = document.getElementById('overdueItemsList');
    
    if (!modal || !itemsList) return;
    
    const overdueItems = getOverdueItems();
    
    // Clear existing content
    itemsList.innerHTML = '';
    
    if (overdueItems.length === 0) {
        itemsList.innerHTML = '<p>No overdue items.</p>';
    } else {
        overdueItems.forEach(item => {
            const timeOverdue = formatTimeUntilDue(item.dueDate);
            const overdueDays = Math.floor((Date.now() - new Date(item.dueDate).getTime()) / (1000 * 60 * 60 * 24));
            const isCritical = overdueDays >= 7; // 7+ days overdue is critical
            
            const itemElement = document.createElement('div');
            itemElement.className = `overdue-item${isCritical ? ' critical' : ''}`;
            
            itemElement.innerHTML = `
                <div class="overdue-item-content" onclick="navigateToOverdueItem('${item.id}')">
                    <div class="overdue-item-header">
                        <h4 class="overdue-item-title">${escapeHtml(item.activity)}</h4>
                        <span class="overdue-time">${timeOverdue}</span>
                    </div>
                    ${item.description ? `<div class="overdue-item-description">${escapeHtml(item.description)}</div>` : ''}
                    <div class="overdue-item-due-date">
                        Due: ${new Date(item.dueDate).toLocaleString()}
                    </div>
                </div>
                <div class="overdue-item-actions">
                    <button class="btn btn-success btn-small" onclick="event.stopPropagation(); markOverdueItemComplete('${item.id}')" title="Mark as completed"> Complete</button>
                    <div class="reschedule-dropdown">
                        <button class="btn btn-secondary btn-small reschedule-btn" onclick="event.stopPropagation(); toggleRescheduleOptions('${item.id}')" title="Reschedule item"> Reschedule</button>
                        <div class="reschedule-options" id="reschedule-${item.id}" style="display: none;">
                            <button onclick="event.stopPropagation(); rescheduleOverdueItem('${item.id}', 'tomorrow')">Tomorrow</button>
                            <button onclick="event.stopPropagation(); rescheduleOverdueItem('${item.id}', 'next-week')">Next Week</button>
                            <button onclick="event.stopPropagation(); rescheduleOverdueItem('${item.id}', 'next-month')">Next Month</button>
                            <button onclick="event.stopPropagation(); rescheduleOverdueItemCustom('${item.id}')">Custom Date</button>
                        </div>
                    </div>
                </div>
            `;
            
            itemsList.appendChild(itemElement);
        });
    }
    
    modal.style.display = 'block';
}

/**
 * Close overdue alert modal
 */
function closeOverdueAlert() {
    const modal = document.getElementById('overdueAlertModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

/**
 * Mark an overdue item as complete
 */
function markOverdueItemComplete(itemId) {
    if (tracker) {
        tracker.completeEntry(itemId);
        // Refresh the overdue modal
        showOverdueAlert();
        // Update alert button state
        updateOverdueAlertButton();
        // Play sound if enabled
        if (tracker.soundManager && !tracker.isNotificationSoundMuted()) {
            tracker.soundManager.playSound('classic', false);
        }
    }
}

/**
 * Navigate to the section containing an overdue item
 */
function navigateToOverdueItem(itemId) {
    if (!tracker) return;
    
    const item = tracker.entries.find(entry => entry.id === itemId);
    if (!item) return;
    
    // Close the overdue modal
    closeOverdueAlert();
    
    // Navigate to appropriate section and find the correct page
    if (item.isTodo) {
        // Switch to todo section
        showSection('todo');
        // Find which page the item is on and navigate to it
        navigateToItemInSection('todo', itemId);
    } else if (item.isNote) {
        // Switch to notes section
        showSection('notes');
        // Find which page the item is on and navigate to it
        navigateToItemInSection('notes', itemId);
    } else {
        // Switch to tracker section for regular entries
        showSection('tracker');
        // Find which page the item is on and navigate to it
        navigateToItemInSection('tracker', itemId);
    }
}

/**
 * Navigate to a specific item in a section, handling pagination
 */
function navigateToItemInSection(section, itemId) {
    setTimeout(() => {
        // With overdue prioritization, overdue items should be on first pages
        // But let's be extra sure by checking if the item is visible
        let targetElement = document.querySelector(`[onclick*="${itemId}"]`);
        
        if (!targetElement) {
            // Item not visible on current page, it might be on another page
            // Since overdue items are now prioritized and shown first, 
            // this shouldn't happen for overdue items, but let's handle it anyway
            
            // Go to first page to look for overdue items
            if (section === 'todo' && tracker.todoPagination) {
                tracker.todoPagination.currentPage = 1;
                tracker.displayTodos();
            } else if (section === 'notes' && tracker.notesPagination) {
                tracker.notesPagination.currentPage = 1;
                tracker.displayNotes();
            } else if (section === 'tracker' && tracker.entriesPagination) {
                tracker.entriesPagination.currentPage = 1;
                tracker.displayEntries();
            }
            
            // Try to find the element again after refresh
            setTimeout(() => {
                targetElement = document.querySelector(`[onclick*="${itemId}"]`);
                if (targetElement) {
                    highlightAndScrollToElement(targetElement);
                }
            }, 100);
        } else {
            // Element is visible, just scroll to it
            highlightAndScrollToElement(targetElement);
        }
    }, 100);
}

/**
 * Highlight and scroll to a target element
 */
function highlightAndScrollToElement(element) {
    if (element) {
        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        element.style.background = '#fff3cd';
        element.style.transition = 'background-color 0.3s ease';
        setTimeout(() => {
            element.style.background = '';
            setTimeout(() => {
                element.style.transition = '';
            }, 300);
        }, 2000);
    }
}

/**
 * Toggle reschedule options dropdown for an overdue item
 */
function toggleRescheduleOptions(itemId) {
    const dropdown = document.getElementById(`reschedule-${itemId}`);
    if (!dropdown) return;
    
    // Close all other open dropdowns first
    document.querySelectorAll('.reschedule-options').forEach(option => {
        if (option.id !== `reschedule-${itemId}`) {
            option.style.display = 'none';
        }
    });
    
    // Toggle this dropdown with proper positioning
    if (dropdown.style.display === 'none' || !dropdown.style.display) {
        // Find the reschedule button that triggered this
        const rescheduleButton = document.querySelector(`[onclick*="toggleRescheduleOptions('${itemId}')"]`);
        if (rescheduleButton) {
            const rect = rescheduleButton.getBoundingClientRect();
            
            // Position dropdown relative to viewport
            dropdown.style.left = `${rect.left}px`;
            dropdown.style.top = `${rect.bottom + 5}px`;
            
            // Ensure dropdown doesn't go off-screen
            const dropdownRect = dropdown.getBoundingClientRect();
            if (rect.left + dropdownRect.width > window.innerWidth) {
                dropdown.style.left = `${window.innerWidth - dropdownRect.width - 10}px`;
            }
            if (rect.bottom + dropdownRect.height > window.innerHeight) {
                dropdown.style.top = `${rect.top - dropdownRect.height - 5}px`;
            }
        }
        dropdown.style.display = 'block';
    } else {
        dropdown.style.display = 'none';
    }
}

/**
 * Reschedule an overdue item to a preset date
 */
function rescheduleOverdueItem(itemId, rescheduleType) {
    if (!tracker) return;
    
    const item = tracker.entries.find(entry => entry.id === itemId);
    if (!item) return;
    
    const now = new Date();
    let newDueDate;
    
    switch (rescheduleType) {
        case 'tomorrow':
            newDueDate = new Date(now);
            newDueDate.setDate(now.getDate() + 1);
            newDueDate.setHours(9, 0, 0, 0); // Default to 9 AM
            break;
        case 'next-week':
            newDueDate = new Date(now);
            newDueDate.setDate(now.getDate() + 7);
            newDueDate.setHours(9, 0, 0, 0); // Default to 9 AM
            break;
        case 'next-month':
            newDueDate = new Date(now);
            newDueDate.setMonth(now.getMonth() + 1);
            newDueDate.setHours(9, 0, 0, 0); // Default to 9 AM
            break;
        default:
            return;
    }
    
    // Update the item's due date
    item.dueDate = newDueDate.toISOString();
    tracker.saveEntries();
    
    // Refresh displays
    tracker.displayEntries();
    tracker.displayTodos();
    tracker.displayNotes();
    showOverdueAlert();
    updateOverdueAlertButton();
    
    // Close dropdown
    const dropdown = document.getElementById(`reschedule-${itemId}`);
    if (dropdown) dropdown.style.display = 'none';
    
    // Show confirmation
    showNotification(`Item rescheduled to ${newDueDate.toLocaleDateString()}`, 'success');
    
    // Play sound if enabled
    if (tracker.soundManager && !tracker.isNotificationSoundMuted()) {
        tracker.soundManager.playSound('classic', false);
    }
}

/**
 * Show custom date picker for rescheduling an overdue item
 */
function rescheduleOverdueItemCustom(itemId) {
    if (!tracker) return;
    
    const item = tracker.entries.find(entry => entry.id === itemId);
    if (!item) return;
    
    // Create a simple prompt for custom date/time
    const currentDue = item.dueDate ? new Date(item.dueDate) : new Date();
    const defaultValue = currentDue.toISOString().slice(0, 16); // Format for datetime-local input
    
    const customDate = prompt(`Enter new due date and time for "${item.activity}":`, defaultValue);
    if (customDate) {
        const newDueDate = new Date(customDate);
        if (!isNaN(newDueDate.getTime())) {
            // Update the item's due date
            item.dueDate = newDueDate.toISOString();
            tracker.saveEntries();
            
            // Refresh displays
            tracker.displayEntries();
            tracker.displayTodos();
            tracker.displayNotes();
            showOverdueAlert();
            updateOverdueAlertButton();
            
            // Close dropdown
            const dropdown = document.getElementById(`reschedule-${itemId}`);
            if (dropdown) dropdown.style.display = 'none';
            
            // Show confirmation
            showNotification(`Item rescheduled to ${newDueDate.toLocaleString()}`, 'success');
            
            // Play sound if enabled
            if (tracker.soundManager && !tracker.isNotificationSoundMuted()) {
                tracker.soundManager.playSound('classic', false);
            }
        } else {
            showNotification('Invalid date format. Please try again.', 'error');
        }
    }
}

/**
 * Generate due date countdown HTML for entry display
 */
function generateDueDateCountdown(dueDate) {
    if (!dueDate) return '';
    
    const timeText = formatTimeUntilDue(dueDate);
    if (!timeText) return '';
    
    const now = new Date();
    const due = new Date(dueDate);
    const diffMs = due.getTime() - now.getTime();
    
    let cssClass = 'upcoming';
    if (diffMs < 0) {
        cssClass = 'overdue';
    } else if (diffMs < 24 * 60 * 60 * 1000) { // Less than 24 hours
        cssClass = 'soon';
    }
    
    return `<span class="entry-due-countdown ${cssClass}">${timeText}</span>`;
}

/**
 * Check for newly due items and send notifications
 */
function checkDueItemsForNotifications() {
    if (!tracker || !tracker.entries) return;
    
    const now = new Date();
    const oneMinuteAgo = new Date(now.getTime() - 60000);
    
    // Find items that became due in the last minute (only consider active todos)
    const newlyDueItems = tracker.entries.filter(entry => {
        if (!entry.dueDate || !entry.isTodo) return false;
        
        const dueDate = new Date(entry.dueDate);
        return dueDate <= now && dueDate > oneMinuteAgo;
    });
    
    // Send notifications for newly due items
    newlyDueItems.forEach(item => {
        sendDueItemNotification(item);
    });
}

/**
 * Send notification for a due item
 */
function sendDueItemNotification(item) {
    // Check if notifications are enabled
    if (!tracker.settings.notificationsEnabled) return;
    
    // Play sound if enabled
    if (tracker.soundManager && !tracker.isNotificationSoundMuted()) {
        tracker.soundManager.playSound(tracker.settings.notificationSoundType, false);
    }
    
    // Send browser notification
    if ('Notification' in window && Notification.permission === 'granted') {
        const notification = new Notification('Item Due Now!', {
            body: `${item.activity}${item.description ? ' - ' + item.description : ''}`,
            icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23e53e3e"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>',
            tag: 'due-item-' + item.id,
            requireInteraction: true
        });
        
        // Auto-close after 10 seconds
        setTimeout(() => {
            if (notification) {
                notification.close();
            }
        }, 10000);
    }
}

/**
 * Initialize due date monitoring system
 */
function initializeDueDateSystem() {
    // Check for due items every minute
    setInterval(() => {
        checkDueItemsForNotifications();
        updateOverdueAlertButton();
    }, 60000);
    
    // Initial check
    updateOverdueAlertButton();
    
    console.log('Due date monitoring system initialized');
}

// === Entry Form Toggle System ===

// Global state for entry form visibility (persistent across tabs)
let entryFormsVisible = true;
let userStruggleTimeout = null;

/**
 * Create latch click sound effect
 */
function createLatchClickSound() {
    // Create a synthetic latch click sound using Web Audio API
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Create multiple oscillators for a complex latch sound
    const clickDuration = 0.08;
    const now = audioContext.currentTime;
    
    // Main click sound (sharp transient)
    const oscillator1 = audioContext.createOscillator();
    const gainNode1 = audioContext.createGain();
    
    oscillator1.connect(gainNode1);
    gainNode1.connect(audioContext.destination);
    
    oscillator1.frequency.setValueAtTime(800, now);
    oscillator1.frequency.exponentialRampToValueAtTime(200, now + 0.02);
    
    gainNode1.gain.setValueAtTime(0.3, now);
    gainNode1.gain.exponentialRampToValueAtTime(0.01, now + clickDuration);
    
    // Secondary resonance (metallic ring)
    const oscillator2 = audioContext.createOscillator();
    const gainNode2 = audioContext.createGain();
    
    oscillator2.connect(gainNode2);
    gainNode2.connect(audioContext.destination);
    
    oscillator2.frequency.setValueAtTime(1200, now + 0.01);
    oscillator2.frequency.exponentialRampToValueAtTime(400, now + 0.04);
    
    gainNode2.gain.setValueAtTime(0.15, now + 0.01);
    gainNode2.gain.exponentialRampToValueAtTime(0.01, now + clickDuration);
    
    // Start and stop oscillators
    oscillator1.start(now);
    oscillator1.stop(now + clickDuration);
    
    oscillator2.start(now + 0.01);
    oscillator2.stop(now + clickDuration);
}

/**
 * Play latch click sound if sound is enabled
 */
function playLatchClick() {
    if (tracker && tracker.settings && !tracker.settings.muteSound) {
        try {
            createLatchClickSound();
        } catch (error) {
            console.log('Could not play latch click sound:', error.message);
        }
    }
}

/**
 * Toggle entry form visibility for a specific section
 */
function toggleEntryForm(section) {
    const component = document.getElementById(`${section}EntryComponent`);
    const toggleBtn = document.getElementById(`${section}ToggleBtn${section === 'tracker' ? '' : '2'}`);
    
    if (!component || !toggleBtn) return;
    
    entryFormsVisible = !entryFormsVisible;
    
    // Play sound effect
    playLatchClick();
    
    // Update all sections to maintain consistency
    updateAllEntryForms();
    
    // Clear any struggle hints
    clearStruggleHint();
    
    // If showing form, focus on appropriate input after animation completes
    if (entryFormsVisible) {
        setTimeout(() => {
            const inputId = section === 'tracker' ? 'activity' : 
                           section === 'todo' ? 'todoActivity' : 'notesActivity';
            const input = document.getElementById(inputId);
            const component = document.getElementById(`${section}EntryComponent`);
            
            // Only focus if the form is actually visible (not collapsed)
            if (input && component && !component.classList.contains('collapsed')) {
                input.focus();
            }
        }, 400); // Wait for animation to complete
    }
}

/**
 * Update all entry forms to match global visibility state
 */
function updateAllEntryForms() {
    const sections = ['tracker', 'todo', 'notes'];
    
    sections.forEach(section => {
        const component = document.getElementById(`${section}EntryComponent`);
        const toggleBtn = document.getElementById(`${section}ToggleBtn${section === 'tracker' ? '' : '2'}`);
        
        if (component && toggleBtn) {
            if (entryFormsVisible) {
                component.classList.remove('collapsed');
                toggleBtn.classList.remove('hidden-form');
                toggleBtn.title = 'Hide entry form';
            } else {
                component.classList.add('collapsed');
                toggleBtn.classList.add('hidden-form');
                toggleBtn.title = 'Show entry form';
            }
        }
    });
}

/**
 * Start struggle detection timer
 */
function startStruggleDetection() {
    if (userStruggleTimeout) clearTimeout(userStruggleTimeout);
    
    // If forms are hidden and user hasn't interacted for 10 seconds, show hint
    if (!entryFormsVisible) {
        userStruggleTimeout = setTimeout(() => {
            showStruggleHint();
        }, 10000);
    }
}

/**
 * Show struggle hint on toggle buttons
 */
function showStruggleHint() {
    const sections = ['tracker', 'todo', 'notes'];
    
    sections.forEach(section => {
        const toggleBtn = document.getElementById(`${section}ToggleBtn${section === 'tracker' ? '' : '2'}`);
        if (toggleBtn && !entryFormsVisible) {
            toggleBtn.classList.add('glow-hint');
        }
    });
    
    // Remove hint after 5 seconds
    setTimeout(() => {
        clearStruggleHint();
    }, 5000);
}

/**
 * Clear struggle hint from all toggle buttons
 */
function clearStruggleHint() {
    if (userStruggleTimeout) {
        clearTimeout(userStruggleTimeout);
        userStruggleTimeout = null;
    }
    
    const sections = ['tracker', 'todo', 'notes'];
    sections.forEach(section => {
        const toggleBtn = document.getElementById(`${section}ToggleBtn${section === 'tracker' ? '' : '2'}`);
        if (toggleBtn) {
            toggleBtn.classList.remove('glow-hint');
        }
    });
}

/**
 * Close Pomodoro activity modal
 */
function closePomodoroActivityModal() {
    const modal = document.getElementById('pomodoroActivityModal');
    if (modal) {
        modal.style.display = 'none';
        document.getElementById('pomodoroActivityForm').reset();
    }
}

/**
 * Show Pomodoro activity modal
 */
function showPomodoroActivityModal() {
    const modal = document.getElementById('pomodoroActivityModal');
    if (modal) {
        modal.style.display = 'block';
        updatePreviousActivityButton();
        setTimeout(() => {
            const activityInput = document.getElementById('pomodoroActivityName');
            if (activityInput) {
                activityInput.focus();
            }
        }, 100);
    }
}

/**
 * Toggle pause/resume for notifications
 */
function togglePause() {
    if (tracker) {
        const pauseButton = document.getElementById('pauseButton');
        
        // Check if button shows "Outside activity hours" and show info modal
        if (pauseButton && pauseButton.textContent === 'Outside activity hours') {
            showActivityHoursInfo();
            return;
        }
        
        // Check if notifications are completely disabled
        if (pauseButton && pauseButton.textContent === 'All reminders disabled') {
            // Focus user's attention on the notification status section
            const notificationStatus = document.querySelector('.notification-status');
            if (notificationStatus) {
                notificationStatus.scrollIntoView({ behavior: 'smooth', block: 'center' });
                // Add a subtle highlight effect
                notificationStatus.style.backgroundColor = 'rgba(102, 126, 234, 0.1)';
                setTimeout(() => {
                    notificationStatus.style.backgroundColor = '';
                }, 3000);
            }
            return;
        }
        
        // Proceed with normal pause toggle
        tracker.togglePause();
    }
}

/**
 * Show activity hours information modal
 */
function showActivityHoursInfo() {
    const modal = document.getElementById('activityHoursInfoModal');
    if (modal) {
        modal.style.display = 'block';
    }
}

/**
 * Close activity hours information modal
 */
function closeActivityHoursInfo() {
    const modal = document.getElementById('activityHoursInfoModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

/**
 * Navigate to activity hours settings
 */
function goToActivityHoursSettings() {
    // Close the modal first
    closeActivityHoursInfo();
    
    // Switch to settings section
    showSection('settings');
    
    // Scroll to the activity hours settings
    setTimeout(() => {
        const activityHoursSection = document.querySelector('.settings-section h3');
        if (activityHoursSection) {
            // Look for the Activity Schedule section
            const sections = document.querySelectorAll('.settings-section h3');
            for (let section of sections) {
                if (section.textContent.includes('Activity Schedule') || section.textContent.includes('Schedule')) {
                    section.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // Add a subtle highlight effect
                    section.parentElement.style.backgroundColor = 'rgba(102, 126, 234, 0.1)';
                    setTimeout(() => {
                        section.parentElement.style.backgroundColor = '';
                    }, 3000);
                    break;
                }
            }
        }
    }, 200);
}

/**
 * Toggle Pomodoro mode from navigation button
 */
function togglePomodoro() {
    if (tracker && tracker.pomodoroManager) {
        tracker.pomodoroManager.togglePomodoroFromButton();
    }
}

/**
 * Toggle Pomodoro pause/resume from banner button
 */
function togglePomodoroPause() {
    if (tracker && tracker.pomodoroManager) {
        tracker.pomodoroManager.togglePause();
    }
}

/**
 * Use previous activity to populate Pomodoro activity form
 */
function usePreviousActivity() {
    if (!tracker || !tracker.entries || tracker.entries.length === 0) {
        showNotification('No previous activities found', 'warning');
        return;
    }
    
    // Find the most recent non-Pomodoro activity or the most recent Pomodoro work activity
    let previousActivity = null;
    
    for (const entry of tracker.entries) {
        if (entry.source !== 'pomodoro') {
            // Use most recent manual activity
            previousActivity = entry;
            break;
        } else if (entry.activity && !entry.activity.includes('break') && !entry.activity.includes('abandoned')) {
            // Use most recent Pomodoro work activity (not break or abandonment)
            previousActivity = entry;
            break;
        }
    }
    
    if (!previousActivity) {
        showNotification('No suitable previous activity found', 'warning');
        return;
    }
    
    // Populate the form
    const activityName = document.getElementById('pomodoroActivityName');
    const activityDescription = document.getElementById('pomodoroActivityDescription');
    
    if (activityName) {
        activityName.value = previousActivity.activity;
    }
    
    if (activityDescription && previousActivity.description) {
        activityDescription.value = previousActivity.description;
    }
    
    showNotification(`Using previous activity: "${previousActivity.activity}"`, 'success');
}

/**
 * Update the "Use Previous Activity" button state
 */
function updatePreviousActivityButton() {
    const button = document.getElementById('usePreviousActivityBtn');
    if (!button) return;
    
    if (!tracker || !tracker.entries || tracker.entries.length === 0) {
        button.disabled = true;
        button.title = 'No previous activities available';
        return;
    }
    
    // Check if there's a suitable previous activity
    let hasUsableActivity = false;
    for (const entry of tracker.entries) {
        if (entry.source !== 'pomodoro' || 
            (entry.activity && !entry.activity.includes('break') && !entry.activity.includes('abandoned'))) {
            hasUsableActivity = true;
            break;
        }
    }
    
    button.disabled = !hasUsableActivity;
    button.title = hasUsableActivity ? 'Fill form with your most recent activity' : 'No suitable previous activities available';
}

/**
 * Show Pomodoro abandonment dialog
 */
function showPomodoroAbandonDialog() {
    const modal = document.getElementById('pomodoroAbandonModal');
    if (modal) {
        modal.style.display = 'block';
        setTimeout(() => {
            const activityInput = document.getElementById('pomodoroAbandonActivityName');
            if (activityInput) {
                activityInput.focus();
            }
        }, 100);
    }
}

/**
 * Close Pomodoro abandonment dialog
 */
function closePomodoroAbandonDialog() {
    const modal = document.getElementById('pomodoroAbandonModal');
    if (modal) {
        modal.style.display = 'none';
        document.getElementById('pomodoroAbandonForm').reset();
    }
}

/**
 * Handle Pomodoro abandonment save decision
 */
function handlePomodoroAbandonmentSave(saveWork) {
    if (tracker && tracker.pomodoroManager) {
        tracker.pomodoroManager.handleAbandonmentSave(saveWork);
    }
}

/**
 * Reset Pomodoro session counter
 */
function resetPomodoroSessions() {
    if (!tracker || !tracker.pomodoroManager) {
        showNotification('Pomodoro manager not available', 'error');
        return;
    }
    
    // Check warning settings
    if (tracker.settings.warnOnSessionReset) {
        showConfirmationDialog(
            'Reset Session Counter',
            'Are you sure you want to reset the Pomodoro session counter? This will start your session count back at 1.',
            (skipFuture) => {
                if (skipFuture) {
                    tracker.settings.warnOnSessionReset = false;
                    // Update the form element to reflect the change
                    const warnResetElement = document.getElementById('warnOnSessionReset');
                    if (warnResetElement) {
                        warnResetElement.value = 'false';
                    }
                    tracker.saveSettings();
                }
                tracker.pomodoroManager.resetSessionCounter();
            },
            {
                confirmText: 'Reset',
                buttonClass: 'btn-warning',
                allowSkip: true
            }
        );
    } else {
        tracker.pomodoroManager.resetSessionCounter();
    }
}

/**
 * Toggle the edit todo button state
 */
function toggleEditTodo() {
    if (!tracker) return;
    
    const button = document.getElementById('editTodoButton');
    if (button) {
        const currentState = button.dataset.isTodo === 'true';
        tracker.setEditTodoButtonState(!currentState);
    }
}

/**
 * Toggle the edit note button state
 */
function toggleEditNote() {
    if (!tracker) return;
    
    const button = document.getElementById('editNoteButton');
    if (button) {
        const currentState = button.dataset.isNote === 'true';
        tracker.setEditNoteButtonState(!currentState);
    }
}

/**
 * Show custom confirmation dialog
 */
function showConfirmationDialog(title, message, onConfirm, options = {}) {
    const modal = document.getElementById('confirmationModal');
    const titleElement = document.getElementById('confirmationTitle');
    const messageElement = document.getElementById('confirmationMessage');
    const confirmBtn = document.getElementById('confirmationConfirmBtn');
    const skipSection = document.getElementById('confirmationSkipSection');
    const skipCheckbox = document.getElementById('confirmationSkipFuture');
    
    if (modal && titleElement && messageElement && confirmBtn) {
        titleElement.textContent = title;
        messageElement.textContent = message;
        
        // Configure button
        confirmBtn.textContent = options.confirmText || 'Confirm';
        confirmBtn.className = `btn ${options.buttonClass || 'btn-danger'}`;
        
        // Show/hide skip option
        if (options.allowSkip) {
            skipSection.style.display = 'block';
            skipCheckbox.checked = false;
        } else {
            skipSection.style.display = 'none';
        }
        
        // Set up confirm handler
        confirmBtn.onclick = () => {
            const skipFuture = skipCheckbox.checked;
            closeConfirmationDialog();
            onConfirm(skipFuture);
        };
        
        modal.style.display = 'block';
    }
}

/**
 * Close confirmation dialog
 */
function closeConfirmationDialog() {
    const modal = document.getElementById('confirmationModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

/**
 * Test Pomodoro tick sounds (for debugging)
 */
function testPomodoroTick(soundType = 'soft') {
    if (tracker && tracker.pomodoroManager) {
        console.log(`Testing Pomodoro tick sound: ${soundType}`);
        tracker.pomodoroManager.settings.tickSound = soundType;
        tracker.pomodoroManager.playTickSound();
    } else {
        console.error('Tracker or Pomodoro Manager not available');
    }
}

/**
 * Saves the customized report templates from the settings page.
 */
function saveReportTemplates() {
    if (tracker) {
        tracker.saveReportTemplates();
    }
}

/**
 * Resets report templates to their default values.
 */
function resetReportTemplates() {
    if (tracker) {
        tracker.resetReportTemplates();
    }
}

/**
 * Export database as backup file
 */
function exportDatabase() {
    if (tracker) {
        tracker.exportDatabase();
    }
}

/**
 * Trigger file picker for database import
 */
function importDatabase() {
    const fileInput = document.getElementById('importFile');
    if (fileInput) {
        fileInput.click();
    }
}

/**
 * Handle import file selection
 */
function handleImportFile(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    if (file.type !== 'application/json' && !file.name.endsWith('.json')) {
        showNotification('Please select a valid JSON backup file.', 'error');
        return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
        if (tracker) {
            tracker.importDatabase(e.target.result);
        }
        // Clear the file input so the same file can be selected again if needed
        event.target.value = '';
    };
    reader.onerror = function() {
        showNotification('Error reading backup file.', 'error');
        event.target.value = '';
    };
    reader.readAsText(file);
}

/**
 * Open template manager overlay
 */
function openTemplateManager() {
    if (tracker) {
        tracker.openTemplateManager();
    }
}

/**
 * Close template manager overlay
 */
function closeTemplateManager() {
    if (tracker) {
        tracker.closeTemplateManager();
    }
}

/**
 * Add new template in manager
 */
function addNewTemplate() {
    if (tracker) {
        tracker.addNewTemplate();
    }
}

/**
 * Reset all templates to defaults
 */
function resetToDefaults() {
    if (tracker) {
        tracker.resetToDefaults();
    }
}

/**
 * Save current template in editor
 */
function saveCurrentTemplate() {
    if (tracker) {
        tracker.saveCurrentTemplate();
    }
}

/**
 * Delete current template in editor
 */
function deleteCurrentTemplate() {
    if (tracker) {
        tracker.deleteCurrentTemplate();
    }
}

/**
 * Duplicate current template in editor
 */
function duplicateCurrentTemplate() {
    if (tracker) {
        tracker.duplicateCurrentTemplate();
    }
}

/**
 * Refresh template preview
 */
function refreshTemplatePreview() {
    if (tracker) {
        tracker.refreshTemplatePreview();
    }
}

/**
 * Save all templates and close manager
 */
function saveAllTemplates() {
    if (tracker) {
        tracker.saveAllTemplates();
    }
}

/**
 * Switch preview tab in template manager
 */
function switchPreviewTab(tabType) {
    if (tracker) {
        tracker.switchPreviewTab(tabType);
    }
}

/**
 * Switch preview tab in reports section
 */
function switchReportPreviewTab(tabType) {
    if (tracker) {
        tracker.switchReportPreviewTab(tabType);
    }
}

/**
 * Switch template editor tab (Editor/Preview)
 */
function switchTemplateTab(tabType) {
    if (tracker) {
        tracker.switchTemplateTab(tabType);
    }
}

/**
 * Run comprehensive service worker diagnostic test
 */
async function runServiceWorkerTest() {
    if (!tracker) {
        showNotification('Tracker not initialized', 'error');
        return;
    }
    
    showNotification('Running Service Worker diagnostics...', 'info');
    
    try {
        const diagnostics = await tracker.runServiceWorkerDiagnostics();
        
        let message = 'Service Worker Diagnostics:\n\n';
        message += `Available: ${diagnostics.available}\n`;
        message += `Protocol: ${diagnostics.protocol}\n`;
        message += `Platform: ${diagnostics.platform}\n`;
        
        if (diagnostics.registration) {
            message += `Registration: Active\n`;
            message += `Scope: ${diagnostics.registration.scope}\n`;
        } else {
            message += `Registration: None\n`;
        }
        
        if (diagnostics.controller) {
            message += `Controller: Active (${diagnostics.controller.state})\n`;
        } else {
            message += `Controller: None\n`;
        }
        
        if (diagnostics.communication) {
            message += `Communication: ${diagnostics.communication}\n`;
        }
        
        if (diagnostics.swVersion) {
            message += `SW Version: ${diagnostics.swVersion}\n`;
        }
        
        if (diagnostics.error) {
            message += `Error: ${diagnostics.error}\n`;
        }
        
        // Show detailed results in console and user notification
        console.log('Service Worker Diagnostics:', diagnostics);
        alert(message);
        
        const status = diagnostics.available && diagnostics.registration ? 'success' : 'warning';
        const summary = diagnostics.available && diagnostics.registration ? 
            'Service Worker is working correctly' : 
            'Service Worker issues detected (see console)';
            
        showNotification(summary, status);
        
    } catch (error) {
        console.error('Diagnostic test failed:', error);
        showNotification('Diagnostic test failed: ' + error.message, 'error');
    }
}

/**
 * Initialize UI state on page load
 */
function initializeUIState() {
    // Hide due date sections by default (they're only for todos)
    const dueDateSection = document.getElementById('dueDateSection');
    if (dueDateSection) {
        dueDateSection.style.display = 'none';
    }
    
    const editDueDateSection = document.getElementById('editDueDateSection');
    if (editDueDateSection) {
        editDueDateSection.style.display = 'none';
    }
}

/**
 * Initialize entry form toggle system
 */
function initializeEntryFormToggle() {
    // Set initial form state
    updateAllEntryForms();
    
    // Add event listeners for user interaction detection
    const interactionEvents = ['click', 'scroll', 'keydown', 'mousemove'];
    
    interactionEvents.forEach(eventType => {
        document.addEventListener(eventType, () => {
            clearStruggleHint();
            startStruggleDetection();
        }, { passive: true });
    });
    
    // Start initial struggle detection if forms are hidden
    startStruggleDetection();
    
    console.log('Entry form toggle system initialized');
}

/**
 * Initialize the application when DOM is loaded
 */
document.addEventListener('DOMContentLoaded', () => {
    console.log('Initializing Activity Tracker...');
    
    // Initialize UI state
    initializeUIState();
    
    // Initialize entry form toggle system
    initializeEntryFormToggle();
    
    // Create tracker instance
    tracker = new ActivityTracker();
    
    // Initialize form timestamps to current time
    initializeFormTimestamps();
    
    // Register service worker if supported
    if ('serviceWorker' in navigator) {
        // Check if we're on a supported protocol
        if (window.location.protocol === 'file:') {
            console.log('Service Worker not registering: file:// protocol detected');
            console.log('App will function normally without Service Worker');
        } else {
            console.log('Registering Service Worker...');
            
            navigator.serviceWorker.register('./sw.js')
                .then(registration => {
                    console.log('Service Worker registered with scope:', registration.scope);
                    
                    // Handle updates
                    registration.addEventListener('updatefound', () => {
                        console.log('Service Worker update found');
                        const newWorker = registration.installing;
                        if (newWorker) {
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    console.log('New Service Worker installed, refresh recommended');
                                    showNotification('App updated! Refresh for latest version.', 'info', 10000);
                                }
                            });
                        }
                    });
                    
                    if (tracker) {
                        tracker.updateDebugInfo();
                    }
                })
                .catch(error => {
                    console.error('Service Worker registration failed:', error);
                    console.log('App will function normally without Service Worker');
                    
                    // Check for common macOS issues
                    if (navigator.platform.includes('Mac') && error.name === 'SecurityError') {
                        console.warn('macOS Security Error: This may be due to strict security settings');
                        console.warn('Try serving over HTTP/HTTPS instead of file://');
                    }
                    
                    if (tracker) {
                        tracker.updateDebugInfo();
                    }
                });
        }

        // Listen for messages from service worker
        navigator.serviceWorker.addEventListener('message', event => {
            console.log('Message from SW:', event.data);
            
            if (event.data && event.data.type === 'add-entry') {
                if (tracker) {
                    tracker.addEntry(event.data.entry);
                    showNotification('Activity logged from notification!', 'success');
                }
            }
            
            if (event.data && event.data.type === 'navigate-to-tracker') {
                showSection('tracker');
            }
            
            if (event.data && event.data.type === 'populate-activity-input') {
                // Navigate to tracker section first
                showSection('tracker');
                
                // Populate the activity input field with the notification reply text
                const activityInput = document.getElementById('activity');
                if (activityInput && event.data.text) {
                    activityInput.value = event.data.text;
                    activityInput.focus();
                    activityInput.select(); // Select the text so user can easily modify it
                    showNotification('Activity text populated from notification!', 'success');
                }
            }
        });

        // Listen for service worker control changes
        navigator.serviceWorker.addEventListener('controllerchange', () => {
            console.log('Service Worker controller changed');
            if (tracker) {
                tracker.updateDebugInfo();
            }
        });

    } else {
        console.log('Service Worker not supported in this browser');
        console.log('App will function normally without Service Worker');
    }

    // Handle hash navigation (if coming from notification)
    if (window.location.hash === '#tracker') {
        showSection('tracker');
        // Clean up the hash
        history.replaceState(null, document.title, window.location.pathname + window.location.search);
    }

    // Position burger menu initially
    positionBurgerMenu();
    
    console.log('Activity Tracker initialized successfully');
});

// Handle window resize and state changes to reposition burger menu
window.addEventListener('resize', () => {
    positionBurgerMenu();
});

// Handle window state changes (maximize, restore, etc.)
window.addEventListener('focus', () => {
    // Small delay to ensure layout is complete after focus
    setTimeout(positionBurgerMenu, 10);
});

// Additional fallback for various window state changes
document.addEventListener('visibilitychange', () => {
    if (!document.hidden) {
        setTimeout(positionBurgerMenu, 10);
    }
});

// Force repositioning on orientation change (mobile)
window.addEventListener('orientationchange', () => {
    setTimeout(positionBurgerMenu, 100);
});

// Use requestAnimationFrame for smooth repositioning during animations
function scheduleRepositioning() {
    requestAnimationFrame(positionBurgerMenu);
}

// Monitor for layout changes using ResizeObserver if available
if (window.ResizeObserver) {
    const resizeObserver = new ResizeObserver(() => {
        scheduleRepositioning();
    });
    
    // Observe the document body for layout changes
    resizeObserver.observe(document.body);
}

/**
 * Handle modal clicks (close when clicking outside)
 */
document.addEventListener('click', (e) => {
    if (e.target.classList.contains('modal')) {
        // Close the appropriate modal based on which one is open
        if (e.target.id === 'templateGuideModal') {
            closeTemplateGuide();
        } else if (e.target.id === 'aboutModal') {
            closeAbout();
        } else if (e.target.id === 'pomodoroActivityModal') {
            closePomodoroActivityModal();
        } else if (e.target.id === 'pomodoroAbandonModal') {
            closePomodoroAbandonDialog();
        } else if (e.target.id === 'confirmationModal') {
            closeConfirmationDialog();
        } else if (e.target.id === 'hashtagBrowserModal') {
            closeHashtagBrowser();
        } else if (e.target.id === 'userGuideModal') {
            closeUserGuide();
        } else {
            closeEditModal();
        }
    }
    
    // Close reschedule dropdowns when clicking outside
    if (!e.target.closest('.reschedule-dropdown')) {
        document.querySelectorAll('.reschedule-options').forEach(dropdown => {
            dropdown.style.display = 'none';
        });
    }
});

/**
 * Handle keyboard shortcuts
 */
document.addEventListener('keydown', (e) => {
    // Esc key closes modals
    if (e.key === 'Escape') {
        // Close whichever modal is currently open
        const templateGuideModal = document.getElementById('templateGuideModal');
        const aboutModal = document.getElementById('aboutModal');
        const editModal = document.getElementById('editModal');
        const pomodoroActivityModal = document.getElementById('pomodoroActivityModal');
        const pomodoroAbandonModal = document.getElementById('pomodoroAbandonModal');
        const confirmationModal = document.getElementById('confirmationModal');
        const hashtagBrowserModal = document.getElementById('hashtagBrowserModal');
        const userGuideModal = document.getElementById('userGuideModal');
        const activityHoursInfoModal = document.getElementById('activityHoursInfoModal');
        
        if (templateGuideModal && templateGuideModal.style.display === 'block') {
            closeTemplateGuide();
        } else if (aboutModal && aboutModal.style.display === 'block') {
            closeAbout();
        } else if (pomodoroActivityModal && pomodoroActivityModal.style.display === 'block') {
            closePomodoroActivityModal();
        } else if (pomodoroAbandonModal && pomodoroAbandonModal.style.display === 'block') {
            closePomodoroAbandonDialog();
        } else if (confirmationModal && confirmationModal.style.display === 'block') {
            closeConfirmationDialog();
        } else if (hashtagBrowserModal && hashtagBrowserModal.style.display === 'block') {
            closeHashtagBrowser();
        } else if (userGuideModal && userGuideModal.style.display === 'block') {
            closeUserGuide();
        } else if (activityHoursInfoModal && activityHoursInfoModal.style.display === 'block') {
            closeActivityHoursInfo();
        } else if (document.getElementById('overdueAlertModal') && document.getElementById('overdueAlertModal').style.display === 'block') {
            closeOverdueAlert();
        } else if (editModal && editModal.style.display === 'block') {
            closeEditModal();
        }
    }
    
    // Shift + Enter submits the activity form when focused
    if (e.shiftKey && e.key === 'Enter') {
        const activeElement = document.activeElement;
        
        // Main activity form
        if (activeElement && (activeElement.id === 'activity' || activeElement.id === 'description')) {
            e.preventDefault();
            const form = document.getElementById('activityForm');
            if (form) {
                form.dispatchEvent(new Event('submit'));
            }
        }
        return;
    }
    
    // Shift + Space focuses the activity input field and unfurls form if hidden
    if (e.shiftKey && e.key === ' ') {
        const activeElement = document.activeElement;
        // Don't trigger if currently focused on any description textarea
        if (activeElement && (activeElement.id === 'description' || activeElement.id === 'editDescription')) {
            return;
        }
        e.preventDefault();
        
        // If forms are hidden, show them first
        if (!entryFormsVisible) {
            entryFormsVisible = true;
            playLatchClick();
            updateAllEntryForms();
            clearStruggleHint();
        }
        
        // Focus the activity input and switch to tracker section
        setTimeout(() => {
            const activityInput = document.getElementById('activity');
            const component = document.getElementById('trackerEntryComponent');
            
            // Also switch to tracker section if not already there
            showSection('tracker');
            
            // Only focus if the form is visible
            if (activityInput && component && !component.classList.contains('collapsed')) {
                activityInput.focus();
            }
        }, entryFormsVisible ? 0 : 400);
        return;
    }
    
    // Ctrl/Cmd + T toggles todo mode
    if ((e.ctrlKey || e.metaKey) && e.key === 't') {
        const activeElement = document.activeElement;
        
        // Main activity form - toggle todo mode
        if (activeElement && (activeElement.id === 'activity' || activeElement.id === 'description')) {
            e.preventDefault();
            toggleTodoMode();
        }
        
        // Edit modal form - toggle todo mode
        if (activeElement && (activeElement.id === 'editActivity' || activeElement.id === 'editDescription' || activeElement.id === 'editTimestamp')) {
            e.preventDefault();
            toggleEditTodo();
        }
        return;
    }
    
    // Ctrl/Cmd + N toggles note mode
    if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
        const activeElement = document.activeElement;
        
        // Main activity form - toggle note mode
        if (activeElement && (activeElement.id === 'activity' || activeElement.id === 'description')) {
            e.preventDefault();
            toggleNoteMode();
        }
        
        // Edit modal form - toggle note mode
        if (activeElement && (activeElement.id === 'editActivity' || activeElement.id === 'editDescription' || activeElement.id === 'editTimestamp')) {
            e.preventDefault();
            toggleEditNote();
        }
        return;
    }
    
    // Ctrl/Cmd + Enter submits the activity form when focused
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
        const activeElement = document.activeElement;
        
        // Main activity form
        if (activeElement && (activeElement.id === 'activity' || activeElement.id === 'description')) {
            const form = document.getElementById('activityForm');
            if (form) {
                form.dispatchEvent(new Event('submit'));
            }
        }
        
        // Edit modal form
        if (activeElement && (activeElement.id === 'editActivity' || activeElement.id === 'editDescription' || activeElement.id === 'editTimestamp')) {
            const editForm = document.getElementById('editForm');
            if (editForm) {
                editForm.dispatchEvent(new Event('submit'));
            }
        }
        
        // Pomodoro activity modal form
        if (activeElement && (activeElement.id === 'pomodoroActivityName' || activeElement.id === 'pomodoroActivityDescription')) {
            const pomodoroForm = document.getElementById('pomodoroActivityForm');
            if (pomodoroForm) {
                pomodoroForm.dispatchEvent(new Event('submit'));
            }
        }
    }
});

/**
 * Handle visibility change to pause/resume notifications when tab is hidden
 */
document.addEventListener('visibilitychange', () => {
    if (tracker) {
        // Update debug info when tab becomes visible
        if (!document.hidden) {
            tracker.updateDebugInfo();
        }
    }
});

/**
 * Handle online/offline events
 */
window.addEventListener('online', () => {
    console.log('Connection restored');
    showNotification('Connection restored', 'success');
});

window.addEventListener('offline', () => {
    console.log('Connection lost');
    showNotification('Working offline', 'info');
});

/**
 * Handle beforeunload for cleanup and unsaved data warning
 */
window.addEventListener('beforeunload', (e) => {
    // Clean up pause manager
    if (tracker && tracker.pauseManager) {
        tracker.pauseManager.destroy();
    }
    
    // Only show warning if there's unsaved form data
    const activityInput = document.getElementById('activity');
    if (activityInput && activityInput.value.trim()) {
        e.preventDefault();
        e.returnValue = 'You have unsaved activity data. Are you sure you want to leave?';
        return e.returnValue;
    }
});

/**
 * Add PWA install prompt handling
 */
let deferredPrompt;

window.addEventListener('beforeinstallprompt', (e) => {
    console.log('PWA install prompt available');
    // Prevent Chrome 67 and earlier from automatically showing the prompt
    e.preventDefault();
    // Save the event so it can be triggered later
    deferredPrompt = e;
    
    // Show custom install button/notification if desired
    showNotification('This app can be installed on your device!', 'info');
});

window.addEventListener('appinstalled', () => {
    console.log('PWA was installed');
    showNotification('Activity Tracker installed successfully!', 'success');
    deferredPrompt = null;
});

/**
 * Error handling for uncaught errors
 */
window.addEventListener('error', (e) => {
    console.error('Uncaught error:', e.error);
    showNotification('An unexpected error occurred. Please refresh the page.', 'error');
});

window.addEventListener('unhandledrejection', (e) => {
    console.error('Unhandled promise rejection:', e.reason);
    showNotification('An unexpected error occurred. Please refresh the page.', 'error');
});

/**
 * Performance monitoring
 */
window.addEventListener('load', () => {
    // Log performance timing
    if (window.performance && window.performance.timing) {
        const timing = window.performance.timing;
        const loadTime = timing.loadEventEnd - timing.navigationStart;
        console.log(`Page loaded in ${loadTime}ms`);
    }
});

/**
 * Toggle burger menu dropdown
 */
function toggleBurgerMenu() {
    const dropdown = document.getElementById('burgerDropdown');
    if (dropdown) {
        dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
    }
}

/**
 * Close burger menu dropdown
 */
function closeBurgerMenu() {
    const dropdown = document.getElementById('burgerDropdown');
    if (dropdown) {
        dropdown.style.display = 'none';
    }
}

// Close burger menu when clicking outside
document.addEventListener('click', (e) => {
    const burgerMenu = document.querySelector('.burger-menu');
    const dropdown = document.getElementById('burgerDropdown');
    
    if (burgerMenu && dropdown && !burgerMenu.contains(e.target)) {
        dropdown.style.display = 'none';
    }
});

// ==================== COMPLEX SCHEDULE MANAGEMENT ====================

/**
 * Toggle between simple and complex schedule modes
 */
function toggleScheduleMode() {
    const useComplex = document.getElementById('useComplexSchedule').checked;
    const simpleSchedule = document.getElementById('simpleSchedule');
    const complexSchedule = document.getElementById('complexSchedule');
    
    if (useComplex) {
        simpleSchedule.style.display = 'none';
        complexSchedule.style.display = 'block';
        // Populate complex schedule with current data
        populateComplexSchedule();
    } else {
        simpleSchedule.style.display = 'block';
        complexSchedule.style.display = 'none';
    }
    
    // Update the setting
    tracker.settings.useComplexSchedule = useComplex;
    saveSettings();
}

/**
 * Populate complex schedule UI with current data
 */
function populateComplexSchedule() {
    const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
    
    days.forEach(day => {
        const container = document.getElementById(`${day}-ranges`);
        const ranges = tracker.settings.complexSchedule[day] || [];
        
        // Clear existing ranges
        container.innerHTML = '';
        
        if (ranges.length === 0) {
            container.innerHTML = '<div class="empty-schedule">No activity hours set for this day</div>';
        } else {
            ranges.forEach((range, index) => {
                addTimeRangeElement(day, range.start, range.end, index);
            });
        }
    });
}

/**
 * Add a new time range for a specific day
 */
function addTimeRange(day) {
    const ranges = tracker.settings.complexSchedule[day] || [];
    const newRange = { start: '09:00', end: '17:00' };
    ranges.push(newRange);
    
    // Update the tracker settings
    tracker.settings.complexSchedule[day] = ranges;
    saveSettings();
    
    // Update UI
    const container = document.getElementById(`${day}-ranges`);
    if (container.querySelector('.empty-schedule')) {
        container.innerHTML = '';
    }
    
    addTimeRangeElement(day, newRange.start, newRange.end, ranges.length - 1);
}

/**
 * Add a time range element to the UI
 */
function addTimeRangeElement(day, startTime, endTime, index) {
    const container = document.getElementById(`${day}-ranges`);
    
    const rangeDiv = document.createElement('div');
    rangeDiv.className = 'time-range';
    rangeDiv.dataset.index = index;
    
    rangeDiv.innerHTML = `
        <input type="time" value="${startTime}" onchange="updateTimeRange('${day}', ${index}, 'start', this.value)">
        <span class="range-separator">to</span>
        <input type="time" value="${endTime}" onchange="updateTimeRange('${day}', ${index}, 'end', this.value)">
        <button type="button" class="remove-range" onclick="removeTimeRange('${day}', ${index})" title="Remove this time range"></button>
    `;
    
    container.appendChild(rangeDiv);
}

/**
 * Update a time range when inputs change
 */
function updateTimeRange(day, index, field, value) {
    const ranges = tracker.settings.complexSchedule[day] || [];
    if (ranges[index]) {
        ranges[index][field] = value;
        tracker.settings.complexSchedule[day] = ranges;
        saveSettings();
    }
}

/**
 * Remove a time range
 */
function removeTimeRange(day, index) {
    const ranges = tracker.settings.complexSchedule[day] || [];
    ranges.splice(index, 1);
    tracker.settings.complexSchedule[day] = ranges;
    saveSettings();
    
    // Refresh the UI for this day
    const container = document.getElementById(`${day}-ranges`);
    container.innerHTML = '';
    
    if (ranges.length === 0) {
        container.innerHTML = '<div class="empty-schedule">No activity hours set for this day</div>';
    } else {
        ranges.forEach((range, newIndex) => {
            addTimeRangeElement(day, range.start, range.end, newIndex);
        });
    }
}

// ==================== WORKSPACE MANAGEMENT UI ====================

/**
 * Open workspace manager modal
 */
function openWorkspaceManager() {
    const modal = document.getElementById('workspaceManagerModal');
    if (modal && tracker) {
        // Update current workspace name
        const currentNameSpan = document.getElementById('currentWorkspaceName');
        if (currentNameSpan) {
            currentNameSpan.textContent = tracker.currentWorkspace;
        }
        
        // Populate workspace list
        populateWorkspaceList();
        
        modal.style.display = 'block';
    }
}

/**
 * Close workspace manager modal
 */
function closeWorkspaceManager() {
    const modal = document.getElementById('workspaceManagerModal');
    if (modal) {
        modal.style.display = 'none';
    }
    
    // Clear input
    const input = document.getElementById('newWorkspaceName');
    if (input) {
        input.value = '';
    }
}

/**
 * Populate the workspace list
 */
function populateWorkspaceList() {
    const listContainer = document.getElementById('workspaceList');
    if (!listContainer || !tracker) return;
    
    const workspaceNames = tracker.getWorkspaceNames();
    
    if (workspaceNames.length === 0) {
        listContainer.innerHTML = '<p class="empty-state">No workspaces found.</p>';
        return;
    }
    
    let html = '';
    workspaceNames.forEach(name => {
        const isCurrent = name === tracker.currentWorkspace;
        const isDefault = name === 'Default';
        
        html += `<div class="workspace-item ${isCurrent ? 'current' : ''}">
            <div class="workspace-info">
                <span class="workspace-name">${name}</span>
                ${isCurrent ? '<span class="current-badge">Current</span>' : ''}
            </div>
            <div class="workspace-actions">
                ${!isCurrent ? `<button class="btn btn-small btn-primary" onclick="switchToWorkspace('${name}')">Switch</button>` : ''}
                ${!isDefault && !isCurrent ? `<button class="btn btn-small btn-secondary" onclick="renameWorkspacePrompt('${name}')">Rename</button>` : ''}
                ${!isDefault && !isCurrent ? `<button class="btn btn-small btn-danger" onclick="deleteWorkspacePrompt('${name}')">Delete</button>` : ''}
            </div>
        </div>`;
    });
    
    listContainer.innerHTML = html;
}

/**
 * Create a new workspace
 */
function createNewWorkspace() {
    const input = document.getElementById('newWorkspaceName');
    if (!input || !tracker) return;
    
    const workspaceName = input.value.trim();
    if (!workspaceName) {
        alert('Please enter a workspace name');
        return;
    }
    
    if (tracker.createWorkspace(workspaceName)) {
        input.value = '';
        populateWorkspaceList();
        console.log(`Created workspace: ${workspaceName}`);
    }
}

/**
 * Switch to a different workspace
 */
function switchToWorkspace(workspaceName) {
    if (!tracker) return;
    
    tracker.switchWorkspace(workspaceName);
    
    // Update current workspace display
    const currentNameSpan = document.getElementById('currentWorkspaceName');
    if (currentNameSpan) {
        currentNameSpan.textContent = workspaceName;
    }
    
    // Refresh workspace list
    populateWorkspaceList();
    
    console.log(`Switched to workspace: ${workspaceName}`);
}

/**
 * Prompt to rename a workspace
 */
function renameWorkspacePrompt(oldName) {
    const newName = prompt(`Rename workspace "${oldName}" to:`, oldName);
    if (newName && newName.trim() && newName.trim() !== oldName) {
        if (tracker && tracker.renameWorkspace(oldName, newName.trim())) {
            populateWorkspaceList();
            
            // Update current workspace display if needed
            const currentNameSpan = document.getElementById('currentWorkspaceName');
            if (currentNameSpan && tracker.currentWorkspace === newName.trim()) {
                currentNameSpan.textContent = newName.trim();
            }
            
            console.log(`Renamed workspace ${oldName} to ${newName.trim()}`);
        }
    }
}

/**
 * Prompt to delete a workspace
 */
function deleteWorkspacePrompt(workspaceName) {
    if (confirm(`Are you sure you want to delete workspace "${workspaceName}"?\n\nThis action cannot be undone and will permanently delete all activities and settings in this workspace.`)) {
        if (tracker && tracker.deleteWorkspace(workspaceName)) {
            populateWorkspaceList();
            console.log(`Deleted workspace: ${workspaceName}`);
        }
    }
}

/**
 * Handle Enter key in workspace name input
 */
document.addEventListener('DOMContentLoaded', () => {
    const input = document.getElementById('newWorkspaceName');
    if (input) {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                createNewWorkspace();
            }
        });
    }
});

// Export for testing purposes
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        showSection,
        addCurrentTime,
        generateReport,
        setWeeklyReport,
        previousWeek,
        nextWeek,
        downloadReport,
        openReportInNewTab,
        saveSettings,
        enableNotifications,
        testNotification,
        testNotificationSound,
        refreshNotificationStatus,
        clearAllData,
        closeEditModal,
        togglePause,
        exportDatabase,
        importDatabase,
        handleImportFile,
        runServiceWorkerTest,
        previewNotificationSound,
        showTemplateGuide,
        closeTemplateGuide,
        showAbout,
        closeAbout,
        updateCopyrightYear,
        requestNotificationPermission,
        declineNotificationPermission,
        forceEnableNotifications,
        copyReportToClipboard,
        toggleBurgerMenu,
        closeBurgerMenu,
        resetActivityForm,
        resetTodoForm,
        resetNotesForm,
        adjustDueDate,
        updateDueDateSectionVisibility,
        openWorkspaceManager,
        closeWorkspaceManager,
        createNewWorkspace,
        switchToWorkspace,
        renameWorkspacePrompt,
        deleteWorkspacePrompt,
        toggleScheduleMode,
        addTimeRange,
        updateTimeRange,
        removeTimeRange
    };
}

// Ensure critical functions are available globally for onclick handlers
if (typeof window !== 'undefined') {
    window.resetActivityForm = resetActivityForm;
    window.resetTodoForm = resetTodoForm;
    window.resetNotesForm = resetNotesForm;
    window.adjustDueDate = adjustDueDate;
    window.updateDueDateSectionVisibility = updateDueDateSectionVisibility;
    window.openWorkspaceManager = openWorkspaceManager;
    window.closeWorkspaceManager = closeWorkspaceManager;
    window.createNewWorkspace = createNewWorkspace;
    window.switchToWorkspace = switchToWorkspace;
    window.renameWorkspacePrompt = renameWorkspacePrompt;
    window.deleteWorkspacePrompt = deleteWorkspacePrompt;
    window.toggleScheduleMode = toggleScheduleMode;
    window.addTimeRange = addTimeRange;
    window.updateTimeRange = updateTimeRange;
    window.removeTimeRange = removeTimeRange;
}


    </script>
</body>
</html>
