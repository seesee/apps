<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hexspex - Hex to Binary Converter</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 100%;
            padding: 40px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }

        select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        select:hover {
            border-color: #667eea;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-section, .output-section {
            margin-bottom: 20px;
        }

        .section-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        textarea {
            width: 100%;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        #hexInput {
            min-height: 120px;
        }

        #output {
            min-height: 150px;
            background: #f8f9fa;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 117, 125, 0.4);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .error {
            color: #dc3545;
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .success {
            color: #155724;
            background: #d4edda;
            border: 1px solid #c3e6cb;
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .info {
            color: #004085;
            background: #cce5ff;
            border: 1px solid #b8daff;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        .hex-stats {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            font-size: 0.85em;
            color: #666;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat-value {
            font-weight: 600;
            color: #667eea;
        }

        .hex-preview {
            background: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 2;
            min-height: 60px;
            max-height: 200px;
            overflow-y: auto;
        }

        .hex-value {
            display: inline-block;
            padding: 2px 6px;
            margin: 2px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            border: 1px solid #ddd;
        }

        .hex-value:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .hex-value.selected {
            background: #764ba2;
            color: white;
            border-color: #764ba2;
        }

        .hex-value.invalid {
            background: #f8d7da;
            border-color: #dc3545;
            color: #dc3545;
        }

        .position-info {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 6px;
            padding: 12px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            display: none;
        }

        .position-info.visible {
            display: block;
        }

        .position-info-title {
            font-weight: 600;
            color: #856404;
            margin-bottom: 5px;
        }

        .position-info-detail {
            color: #856404;
            margin: 3px 0;
        }

        .output-clickable {
            cursor: pointer;
        }

        .preview-label {
            font-size: 0.85em;
            color: #666;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .preview-section {
            display: none;
            margin-top: 10px;
        }

        .preview-section.visible {
            display: block;
        }

        .toggle-preview {
            font-size: 0.85em;
            color: #667eea;
            cursor: pointer;
            text-decoration: underline;
            margin-top: 5px;
            display: inline-block;
        }

        .toggle-preview:hover {
            color: #764ba2;
        }

        .range-input-section {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            display: none;
        }

        .range-input-section.visible {
            display: block;
        }

        .range-controls {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            flex-wrap: wrap;
        }

        .range-input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .range-input-group label {
            font-size: 0.85em;
        }

        .range-input-group input {
            padding: 6px 10px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            width: 100px;
        }

        .range-input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn-small {
            padding: 6px 16px;
            font-size: 13px;
        }

        .highlight-marker {
            background: #fff3cd;
            border-bottom: 2px solid #ffc107;
        }

        .highlight-display {
            margin-top: 10px;
            padding: 12px;
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            display: none;
        }

        .highlight-display.visible {
            display: block;
        }

        .highlight-display-title {
            font-weight: 600;
            color: #856404;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .highlight-display-content {
            color: #333;
            background: white;
            padding: 10px;
            border-radius: 4px;
            word-break: break-all;
            line-height: 1.6;
        }

        .highlight-display-content div {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>hexspex</h1>
        <p class="subtitle">Convert hex strings to binary with optional EBCDIC support</p>

        <div class="info">
            Enter space-separated hex values (e.g., "01 10 f2 20 20 81"). The output updates automatically as you type. Click or select bytes in the input to see position details and highlight them in the output.
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="ebcdicMode">EBCDIC Conversion:</label>
                <select id="ebcdicMode" onchange="convertHex()">
                    <option value="false">Off (Raw bytes)</option>
                    <option value="true">On (EBCDIC → ASCII)</option>
                </select>
            </div>

            <div class="control-group">
                <label for="outputMode">Output Mode:</label>
                <select id="outputMode" onchange="convertHex()">
                    <option value="text">Text (if printable)</option>
                    <option value="hex">Hex dump</option>
                    <option value="both">Both</option>
                </select>
            </div>
        </div>

        <div class="input-section">
            <div class="section-title">Hex Input</div>
            <textarea id="hexInput" placeholder="Enter hex values separated by spaces (e.g., 01 10 f2 20 20 81)"></textarea>
            <div class="hex-stats">
                <div class="stat">
                    <span>Bytes:</span>
                    <span class="stat-value" id="byteCount">0</span>
                </div>
                <div class="stat">
                    <span>Valid hex values:</span>
                    <span class="stat-value" id="validCount">0</span>
                </div>
            </div>
            <div id="positionInfo" class="position-info"></div>

            <div class="range-input-section" id="rangeInputSection">
                <div style="font-weight: 600; margin-bottom: 10px;">Highlight Byte Range</div>
                <div class="range-controls">
                    <div class="range-input-group">
                        <label>Start Byte:</label>
                        <input type="number" id="rangeStart" min="0" placeholder="0">
                    </div>
                    <div class="range-input-group">
                        <label>End Byte:</label>
                        <input type="number" id="rangeEnd" min="0" placeholder="0">
                    </div>
                    <button class="btn-primary btn-small" onclick="highlightRange()">Highlight Range</button>
                    <button class="btn-secondary btn-small" onclick="clearHighlight()">Clear</button>
                </div>
            </div>

            <a class="toggle-preview" onclick="togglePreview()">
                <span id="previewToggleText">▶ Show Hex Preview</span>
            </a>

            <div class="preview-section" id="previewSection">
                <div class="preview-label">Clickable Hex Preview:</div>
                <div id="hexPreview" class="hex-preview"></div>
            </div>
        </div>

        <div class="button-group">
            <button class="btn-secondary" onclick="clearAll()">Clear All</button>
            <button class="btn-success" id="downloadBtn" onclick="downloadBinary()" disabled>Download Binary</button>
        </div>

        <div id="message"></div>

        <div class="output-section">
            <div class="section-title">Output</div>
            <textarea id="output" readonly placeholder="Output will appear here..."></textarea>
            <div id="highlightDisplay" class="highlight-display">
                <div class="highlight-display-title">Highlighted Selection:</div>
                <div id="highlightContent" class="highlight-display-content"></div>
            </div>
        </div>
    </div>

    <script>
        let binaryData = null;

        // EBCDIC to ASCII conversion table (CP500)
        const EBCDIC_TO_ASCII = [
            0x00, 0x01, 0x02, 0x03, 0x9C, 0x09, 0x86, 0x7F, 0x97, 0x8D, 0x8E, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
            0x10, 0x11, 0x12, 0x13, 0x9D, 0x85, 0x08, 0x87, 0x18, 0x19, 0x92, 0x8F, 0x1C, 0x1D, 0x1E, 0x1F,
            0x80, 0x81, 0x82, 0x83, 0x84, 0x0A, 0x17, 0x1B, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x05, 0x06, 0x07,
            0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04, 0x98, 0x99, 0x9A, 0x9B, 0x14, 0x15, 0x9E, 0x1A,
            0x20, 0xA0, 0xE2, 0xE4, 0xE0, 0xE1, 0xE3, 0xE5, 0xE7, 0xF1, 0x5B, 0x2E, 0x3C, 0x28, 0x2B, 0x21,
            0x26, 0xE9, 0xEA, 0xEB, 0xE8, 0xED, 0xEE, 0xEF, 0xEC, 0xDF, 0x5D, 0x24, 0x2A, 0x29, 0x3B, 0x5E,
            0x2D, 0x2F, 0xC2, 0xC4, 0xC0, 0xC1, 0xC3, 0xC5, 0xC7, 0xD1, 0xA6, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
            0xF8, 0xC9, 0xCA, 0xCB, 0xC8, 0xCD, 0xCE, 0xCF, 0xCC, 0x60, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,
            0xD8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0xAB, 0xBB, 0xF0, 0xFD, 0xFE, 0xB1,
            0xB0, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0xAA, 0xBA, 0xE6, 0xB8, 0xC6, 0xA4,
            0xB5, 0x7E, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0xBF, 0xD0, 0xDD, 0xDE, 0xAE,
            0xA2, 0xA3, 0xA5, 0xB7, 0xA9, 0xA7, 0xB6, 0xBC, 0xBD, 0xBE, 0xAC, 0x7C, 0xAF, 0xA8, 0xB4, 0xD7,
            0x7B, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0xAD, 0xF4, 0xF6, 0xF2, 0xF3, 0xF5,
            0x7D, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0xB9, 0xFB, 0xFC, 0xF9, 0xFA, 0xFF,
            0x5C, 0xF7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0xB2, 0xD4, 0xD6, 0xD2, 0xD3, 0xD5,
            0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0xB3, 0xDB, 0xDC, 0xD9, 0xDA, 0x9F
        ];

        function ebcdicToAscii(ebcdicBytes) {
            const asciiBytes = new Uint8Array(ebcdicBytes.length);
            for (let i = 0; i < ebcdicBytes.length; i++) {
                asciiBytes[i] = EBCDIC_TO_ASCII[ebcdicBytes[i]];
            }
            return asciiBytes;
        }

        function parseHexString(hexString) {
            const hexValues = hexString.trim().split(/\s+/).filter(v => v.length > 0);
            const bytes = new Uint8Array(hexValues.length);
            const errors = [];

            for (let i = 0; i < hexValues.length; i++) {
                const hex = hexValues[i];
                const value = parseInt(hex, 16);

                if (isNaN(value) || hex.length === 0) {
                    errors.push({index: i, value: hex});
                } else if (value > 255) {
                    errors.push({index: i, value: hex, message: 'Value exceeds 255'});
                } else {
                    bytes[i] = value;
                }
            }

            return {bytes, errors, count: hexValues.length};
        }

        function bytesToHexDump(bytes, bytesPerLine = 16, highlightRange = null) {
            let result = '';
            for (let i = 0; i < bytes.length; i += bytesPerLine) {
                const offset = i.toString(16).padStart(8, '0');
                const chunk = bytes.slice(i, i + bytesPerLine);

                const hexPart = Array.from(chunk)
                    .map((b, idx) => {
                        const pos = i + idx;
                        const hexStr = b.toString(16).padStart(2, '0');

                        // Check if this byte is in the highlight range
                        if (highlightRange && pos >= highlightRange.start && pos <= highlightRange.end) {
                            return `[${pos}:${hexStr}]*`;
                        }
                        return `[${pos}:${hexStr}]`;
                    })
                    .join(' ');

                const asciiPart = Array.from(chunk)
                    .map((b, idx) => {
                        const pos = i + idx;
                        const char = (b >= 32 && b <= 126) ? String.fromCharCode(b) : '.';

                        // Mark highlighted characters
                        if (highlightRange && pos >= highlightRange.start && pos <= highlightRange.end) {
                            return `<${char}>`;
                        }
                        return char;
                    })
                    .join('');

                result += `${offset}  ${hexPart}  |${asciiPart}|\n`;
            }

            if (highlightRange) {
                result += `\n*** Highlighted bytes ${highlightRange.start} to ${highlightRange.end} (${highlightRange.end - highlightRange.start + 1} bytes) ***\n`;
            }

            return result;
        }

        function makeOutputClickable() {
            const outputEl = document.getElementById('output');
            const outputMode = document.getElementById('outputMode').value;

            // Only make clickable if showing hex dump
            if (outputMode !== 'hex' && outputMode !== 'both') {
                return;
            }

            outputEl.classList.add('output-clickable');
            outputEl.style.cursor = 'pointer';

            // Remove previous listener if exists
            outputEl.removeEventListener('click', handleOutputClick);
            outputEl.addEventListener('click', handleOutputClick);
        }

        function handleOutputClick(e) {
            const outputEl = e.target;
            const clickPos = outputEl.selectionStart;
            const text = outputEl.value;

            // Find hex value at click position using the [pos:hex] format
            const beforeClick = text.substring(0, clickPos);
            const afterClick = text.substring(clickPos);

            // Look for pattern [position:hexvalue]
            const beforeMatch = beforeClick.match(/\[(\d+):([0-9a-f]{2})\](?!.*\[)/i);
            const afterMatch = afterClick.match(/^\]|^[^\[]*\[(\d+):([0-9a-f]{2})\]/i);

            let position, hexValue;

            if (beforeMatch && beforeClick.length - beforeMatch.index < 20) {
                position = parseInt(beforeMatch[1]);
                hexValue = beforeMatch[2];
            } else if (afterMatch && afterMatch[1]) {
                position = parseInt(afterMatch[1]);
                hexValue = afterMatch[2];
            }

            if (position !== undefined && hexValue) {
                const hexInput = document.getElementById('hexInput').value;
                const hexValues = hexInput.trim().split(/\s+/).filter(v => v.length > 0);
                showPositionInfo(position, hexValue, hexValues.length);
            }
        }

        function updateStats() {
            const hexInput = document.getElementById('hexInput').value;
            const hexValues = hexInput.trim().split(/\s+/).filter(v => v.length > 0);
            const validCount = hexValues.filter(v => {
                const val = parseInt(v, 16);
                return !isNaN(val) && val <= 255;
            }).length;

            document.getElementById('byteCount').textContent = hexValues.length;
            document.getElementById('validCount').textContent = validCount;

            // Update the hex preview
            updateHexPreview(hexValues);

            // Auto-convert on input change
            convertHex();
        }

        function updateHexPreview(hexValues) {
            const previewEl = document.getElementById('hexPreview');

            if (hexValues.length === 0) {
                previewEl.innerHTML = '<span style="color: #999;">No hex values entered</span>';
                return;
            }

            previewEl.innerHTML = '';

            hexValues.forEach((hexVal, index) => {
                const span = document.createElement('span');
                span.className = 'hex-value';
                span.textContent = hexVal;
                span.dataset.position = index;
                span.dataset.value = hexVal;

                // Check if valid
                const val = parseInt(hexVal, 16);
                if (isNaN(val) || val > 255) {
                    span.classList.add('invalid');
                }

                span.addEventListener('click', function() {
                    showPositionInfo(index, hexVal, hexValues.length);

                    // Remove previous selection
                    document.querySelectorAll('.hex-value.selected').forEach(el => {
                        el.classList.remove('selected');
                    });

                    // Add selection to clicked element
                    this.classList.add('selected');
                });

                previewEl.appendChild(span);
            });
        }

        function showPositionInfo(position, hexValue, totalCount) {
            const infoEl = document.getElementById('positionInfo');
            const val = parseInt(hexValue, 16);

            let infoHTML = `<div class="position-info-title">Position Information</div>`;
            infoHTML += `<div class="position-info-detail"><strong>Position:</strong> ${position} (0-indexed) / ${position + 1} (1-indexed)</div>`;
            infoHTML += `<div class="position-info-detail"><strong>Hex Value:</strong> ${hexValue.toUpperCase()}</div>`;

            if (!isNaN(val) && val <= 255) {
                infoHTML += `<div class="position-info-detail"><strong>Decimal:</strong> ${val}</div>`;
                infoHTML += `<div class="position-info-detail"><strong>Binary:</strong> ${val.toString(2).padStart(8, '0')}</div>`;
                infoHTML += `<div class="position-info-detail"><strong>ASCII:</strong> ${val >= 32 && val <= 126 ? String.fromCharCode(val) + ' (printable)' : val < 32 ? '(control character)' : '(non-printable)'}</div>`;
            } else {
                infoHTML += `<div class="position-info-detail" style="color: #dc3545;"><strong>Status:</strong> Invalid hex value</div>`;
            }

            infoHTML += `<div class="position-info-detail"><strong>Total values:</strong> ${totalCount}</div>`;

            infoEl.innerHTML = infoHTML;
            infoEl.classList.add('visible');
        }

        let currentHighlightRange = null;

        function togglePreview() {
            const previewSection = document.getElementById('previewSection');
            const toggleText = document.getElementById('previewToggleText');

            previewSection.classList.toggle('visible');

            if (previewSection.classList.contains('visible')) {
                toggleText.textContent = '▼ Hide Hex Preview';
            } else {
                toggleText.textContent = '▶ Show Hex Preview';
            }
        }

        function getBytePositionFromCursor() {
            const hexInput = document.getElementById('hexInput');
            const text = hexInput.value;
            const cursorStart = hexInput.selectionStart;
            const cursorEnd = hexInput.selectionEnd;

            // Parse the text up to cursor position to count bytes
            const beforeCursor = text.substring(0, cursorStart);
            const hexValues = text.trim().split(/\s+/).filter(v => v.length > 0);

            // Count how many complete hex values are before the cursor
            let currentPos = 0;
            let byteIndex = 0;

            for (let i = 0; i < hexValues.length; i++) {
                const hexVal = hexValues[i];
                const nextPos = text.indexOf(hexVal, currentPos);

                if (nextPos >= cursorStart) {
                    break;
                }

                currentPos = nextPos + hexVal.length;
                if (currentPos <= cursorStart) {
                    byteIndex = i + 1;
                }
            }

            // If there's a selection, calculate the end byte too
            let endByteIndex = byteIndex;
            if (cursorEnd > cursorStart) {
                currentPos = 0;
                for (let i = 0; i < hexValues.length; i++) {
                    const hexVal = hexValues[i];
                    const nextPos = text.indexOf(hexVal, currentPos);

                    if (nextPos >= cursorEnd) {
                        break;
                    }

                    currentPos = nextPos + hexVal.length;
                    if (currentPos <= cursorEnd) {
                        endByteIndex = i + 1;
                    }
                }
            }

            return {
                start: byteIndex,
                end: endByteIndex,
                isRange: endByteIndex > byteIndex,
                hexValues: hexValues
            };
        }

        function handleTextAreaClick() {
            const hexInput = document.getElementById('hexInput');
            const infoEl = document.getElementById('positionInfo');
            const rangeSection = document.getElementById('rangeInputSection');

            if (!hexInput.value.trim()) {
                infoEl.classList.remove('visible');
                rangeSection.classList.remove('visible');
                currentHighlightRange = null;
                convertHex();
                return;
            }

            const position = getBytePositionFromCursor();

            if (position.isRange) {
                // Show range info
                let infoHTML = `<div class="position-info-title">Selection Information</div>`;
                infoHTML += `<div class="position-info-detail"><strong>Byte Range:</strong> ${position.start} to ${position.end - 1} (0-indexed) / ${position.start + 1} to ${position.end} (1-indexed)</div>`;
                infoHTML += `<div class="position-info-detail"><strong>Bytes Selected:</strong> ${position.end - position.start}</div>`;

                // Show the hex values in this range
                const selectedHex = position.hexValues.slice(position.start, position.end);
                if (selectedHex.length > 0) {
                    infoHTML += `<div class="position-info-detail"><strong>Hex Values:</strong> ${selectedHex.join(' ')}</div>`;

                    // Convert to decimal values
                    const decimalValues = selectedHex.map(h => parseInt(h, 16)).filter(v => !isNaN(v));
                    if (decimalValues.length > 0) {
                        infoHTML += `<div class="position-info-detail"><strong>Decimal Values:</strong> ${decimalValues.join(', ')}</div>`;
                    }

                    // Convert to ASCII/text representation
                    const asciiText = decimalValues.map(v => {
                        if (v >= 32 && v <= 126) {
                            return String.fromCharCode(v);
                        } else if (v < 32) {
                            return `[${v}]`; // control character
                        } else {
                            return `[${v}]`; // non-printable
                        }
                    }).join('');
                    infoHTML += `<div class="position-info-detail"><strong>Text:</strong> ${asciiText}</div>`;

                    // Show binary if reasonable number of bytes
                    if (selectedHex.length <= 8) {
                        const binaryValues = decimalValues.map(v => v.toString(2).padStart(8, '0'));
                        infoHTML += `<div class="position-info-detail"><strong>Binary:</strong> ${binaryValues.join(' ')}</div>`;
                    }
                }

                infoEl.innerHTML = infoHTML;
                infoEl.classList.add('visible');

                // Auto-fill the range inputs and highlight
                document.getElementById('rangeStart').value = position.start;
                document.getElementById('rangeEnd').value = position.end - 1;
                rangeSection.classList.add('visible');

                // Set highlight range and re-convert
                currentHighlightRange = { start: position.start, end: position.end - 1 };
                convertHex();
            } else {
                // Show single position info
                const hexValue = position.hexValues[position.start - 1];

                if (hexValue) {
                    let infoHTML = `<div class="position-info-title">Cursor Position</div>`;
                    infoHTML += `<div class="position-info-detail"><strong>Byte Position:</strong> ${position.start - 1} (0-indexed) / ${position.start} (1-indexed)</div>`;
                    infoHTML += `<div class="position-info-detail"><strong>Hex Value:</strong> ${hexValue.toUpperCase()}</div>`;

                    const val = parseInt(hexValue, 16);
                    if (!isNaN(val) && val <= 255) {
                        infoHTML += `<div class="position-info-detail"><strong>Decimal:</strong> ${val}</div>`;
                        infoHTML += `<div class="position-info-detail"><strong>Binary:</strong> ${val.toString(2).padStart(8, '0')}</div>`;
                        infoHTML += `<div class="position-info-detail"><strong>ASCII:</strong> ${val >= 32 && val <= 126 ? String.fromCharCode(val) + ' (printable)' : val < 32 ? '(control character)' : '(non-printable)'}</div>`;
                    }

                    infoHTML += `<div class="position-info-detail"><strong>Total bytes:</strong> ${position.hexValues.length}</div>`;

                    infoEl.innerHTML = infoHTML;
                    infoEl.classList.add('visible');
                    rangeSection.classList.add('visible');

                    // Highlight single byte and re-convert
                    currentHighlightRange = { start: position.start - 1, end: position.start - 1 };
                    convertHex();
                } else {
                    infoEl.classList.remove('visible');
                    currentHighlightRange = null;
                    convertHex();
                }
            }
        }

        document.getElementById('hexInput').addEventListener('input', updateStats);
        document.getElementById('hexInput').addEventListener('click', handleTextAreaClick);
        document.getElementById('hexInput').addEventListener('keyup', handleTextAreaClick);
        document.getElementById('hexInput').addEventListener('select', handleTextAreaClick);

        function convertHex() {
            const hexInput = document.getElementById('hexInput').value;
            const ebcdicMode = document.getElementById('ebcdicMode').value === 'true';
            const outputMode = document.getElementById('outputMode').value;
            const outputEl = document.getElementById('output');
            const messageEl = document.getElementById('message');
            const downloadBtn = document.getElementById('downloadBtn');
            const highlightDisplayEl = document.getElementById('highlightDisplay');
            const highlightContentEl = document.getElementById('highlightContent');

            messageEl.innerHTML = '';
            outputEl.value = '';
            binaryData = null;
            downloadBtn.disabled = true;

            if (!hexInput.trim()) {
                // Don't show error for empty input (since this runs live)
                highlightDisplayEl.classList.remove('visible');
                return;
            }

            const {bytes, errors, count} = parseHexString(hexInput);

            if (errors.length > 0) {
                const errorMsg = errors.map(e =>
                    `Invalid hex value at position ${e.index + 1}: '${e.value}'${e.message ? ' (' + e.message + ')' : ''}`
                ).join('<br>');
                messageEl.innerHTML = `<div class="error">${errorMsg}</div>`;
                highlightDisplayEl.classList.remove('visible');
                return;
            }

            binaryData = bytes;
            let processedBytes = bytes;

            if (ebcdicMode) {
                processedBytes = ebcdicToAscii(bytes);
            }

            let output = '';

            if (outputMode === 'hex' || outputMode === 'both') {
                output += bytesToHexDump(processedBytes, 16, currentHighlightRange);
                if (outputMode === 'both') output += '\n' + '='.repeat(60) + '\n\n';
            }

            if (outputMode === 'text' || outputMode === 'both') {
                try {
                    const decoder = new TextDecoder('utf-8', {fatal: false});
                    const text = decoder.decode(processedBytes);
                    output += text;
                } catch (e) {
                    output += '[Unable to decode as text]';
                }
            }

            outputEl.value = output;
            downloadBtn.disabled = false;
            messageEl.innerHTML = `<div class="success">Successfully converted ${count} hex values</div>`;

            // Update highlight display
            if (currentHighlightRange) {
                const start = currentHighlightRange.start;
                const end = currentHighlightRange.end;
                const highlightedBytes = processedBytes.slice(start, end + 1);

                try {
                    const decoder = new TextDecoder('utf-8', {fatal: false});
                    const text = decoder.decode(highlightedBytes);
                    const hexStr = Array.from(highlightedBytes)
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join(' ');

                    highlightContentEl.innerHTML = `<div><strong>Bytes ${start}-${end}:</strong> ${hexStr}</div><div><strong>Text:</strong> ${text}</div>`;
                    highlightDisplayEl.classList.add('visible');
                } catch (e) {
                    highlightDisplayEl.classList.remove('visible');
                }
            } else {
                highlightDisplayEl.classList.remove('visible');
            }

            // Make output clickable if in hex dump mode
            makeOutputClickable();
        }

        function clearAll() {
            document.getElementById('hexInput').value = '';
            document.getElementById('output').value = '';
            document.getElementById('message').innerHTML = '';
            document.getElementById('downloadBtn').disabled = true;
            document.getElementById('positionInfo').classList.remove('visible');
            document.getElementById('rangeInputSection').classList.remove('visible');
            document.getElementById('highlightDisplay').classList.remove('visible');
            currentHighlightRange = null;
            document.getElementById('rangeStart').value = '';
            document.getElementById('rangeEnd').value = '';
            binaryData = null;
            updateStats();
        }

        function downloadBinary() {
            if (!binaryData) {
                alert('No binary data to download. Please convert hex values first.');
                return;
            }

            const blob = new Blob([binaryData], {type: 'application/octet-stream'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'output.bin';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function highlightRange() {
            const startVal = parseInt(document.getElementById('rangeStart').value);
            const endVal = parseInt(document.getElementById('rangeEnd').value);

            if (isNaN(startVal) || isNaN(endVal)) {
                alert('Please enter valid start and end byte positions.');
                return;
            }

            if (startVal > endVal) {
                alert('Start byte must be less than or equal to end byte.');
                return;
            }

            const hexInput = document.getElementById('hexInput').value;
            const hexValues = hexInput.trim().split(/\s+/).filter(v => v.length > 0);

            if (endVal >= hexValues.length) {
                alert(`End byte ${endVal} exceeds total bytes (${hexValues.length - 1} max).`);
                return;
            }

            currentHighlightRange = { start: startVal, end: endVal };

            // Re-convert to show the highlight
            convertHex();
        }

        function clearHighlight() {
            currentHighlightRange = null;
            document.getElementById('rangeStart').value = '';
            document.getElementById('rangeEnd').value = '';

            // Re-convert to remove the highlight
            if (binaryData) {
                convertHex();
            }
        }

        // Initialize stats
        updateStats();
    </script>
</body>
</html>
