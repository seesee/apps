#!/usr/bin/env python3
"""
QRnator Decoder - Extract and reconstruct files from QR-encoded video

This script processes video files (MP4) containing QR codes generated by QRnator,
extracts the encoded data, deduplicates frames, verifies checksums, and reconstructs
the original file with proper metadata.
"""

import cv2
import sys
import base64
import os
from collections import defaultdict
from pathlib import Path
from urllib.parse import unquote


class QRDecoder:
    def __init__(self, video_path, output_dir='.'):
        self.video_path = video_path
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Storage for decoded chunks
        self.metadata = None
        self.data_chunks = {}
        self.seen_qr_codes = set()

        # Statistics
        self.total_frames = 0
        self.frames_with_qr = 0
        self.duplicate_qr_count = 0

    def calculate_checksum(self, data):
        """Calculate checksum matching the JavaScript implementation"""
        checksum = 0
        for char in data:
            checksum = (checksum + ord(char)) % 65536
        return format(checksum, '04x')

    def verify_checksum(self, data, expected_checksum):
        """Verify data checksum"""
        calculated = self.calculate_checksum(data)
        return calculated == expected_checksum

    def parse_metadata(self, qr_data):
        """Parse metadata QR code
        Format: META:filename:filesize:filetype:totalchunks:checksum
        """
        try:
            parts = qr_data.split(':', 5)
            if len(parts) != 6 or parts[0] != 'META':
                return None

            _, filename, filesize, filetype, total_chunks, checksum = parts

            # Verify checksum
            check_data = unquote(filename) + filesize + unquote(filetype)
            if not self.verify_checksum(check_data, checksum):
                print(f"Warning: Metadata checksum mismatch")

            metadata = {
                'filename': unquote(filename),
                'filesize': int(filesize),
                'filetype': unquote(filetype),
                'total_chunks': int(total_chunks)
            }

            print(f"\n[Metadata Decoded]")
            print(f"  Filename: {metadata['filename']}")
            print(f"  Size: {metadata['filesize']} bytes")
            print(f"  Type: {metadata['filetype']}")
            print(f"  Total chunks: {metadata['total_chunks']}")

            return metadata

        except Exception as e:
            print(f"Error parsing metadata: {e}")
            return None

    def parse_data_chunk(self, qr_data):
        """Parse data chunk QR code
        Format: DATA:SEQ:TOTAL:CHECKSUM:PAYLOAD
        """
        try:
            parts = qr_data.split(':', 4)
            if len(parts) != 5 or parts[0] != 'DATA':
                return None

            _, seq, total, checksum, payload = parts
            seq = int(seq)
            total = int(total)

            # Verify checksum
            if not self.verify_checksum(payload, checksum):
                print(f"Warning: Chunk {seq} checksum mismatch")
                return None

            return {
                'sequence': seq,
                'total': total,
                'payload': payload
            }

        except Exception as e:
            print(f"Error parsing data chunk: {e}")
            return None

    def process_qr_code(self, qr_data):
        """Process a decoded QR code"""
        # Skip if we've seen this exact QR code before
        if qr_data in self.seen_qr_codes:
            self.duplicate_qr_count += 1
            return

        self.seen_qr_codes.add(qr_data)

        # Determine type and parse
        if qr_data.startswith('META:'):
            if self.metadata is None:
                self.metadata = self.parse_metadata(qr_data)
        elif qr_data.startswith('DATA:'):
            chunk = self.parse_data_chunk(qr_data)
            if chunk:
                seq = chunk['sequence']
                if seq not in self.data_chunks:
                    self.data_chunks[seq] = chunk
                    print(f"  Chunk {seq + 1}/{chunk['total']} decoded", end='\r')

    def decode_video(self):
        """Process video file and extract QR codes"""
        print(f"Opening video: {self.video_path}")

        cap = cv2.VideoCapture(str(self.video_path))
        if not cap.isOpened():
            print(f"Error: Could not open video file")
            return False

        # Get video properties
        total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
        fps = cap.get(cv2.CAP_PROP_FPS)

        print(f"Video info: {total_frames} frames @ {fps} FPS")
        print(f"\nScanning for QR codes...")

        # Initialize QR detector
        qr_detector = cv2.QRCodeDetector()

        frame_count = 0
        last_progress = -1

        while True:
            ret, frame = cap.read()
            if not ret:
                break

            frame_count += 1
            self.total_frames = frame_count

            # Update progress
            progress = int((frame_count / total_frames) * 100)
            if progress != last_progress:
                print(f"Progress: {progress}% - Frames: {frame_count}/{total_frames} - QR codes found: {len(self.seen_qr_codes)}", end='\r')
                last_progress = progress

            # Detect and decode QR code
            data, points, straight_qrcode = qr_detector.detectAndDecode(frame)

            if data:
                self.frames_with_qr += 1
                self.process_qr_code(data)

        cap.release()

        print(f"\n\n[Scan Complete]")
        print(f"  Total frames processed: {self.total_frames}")
        print(f"  Frames with QR codes: {self.frames_with_qr}")
        print(f"  Unique QR codes found: {len(self.seen_qr_codes)}")
        print(f"  Duplicate QR codes skipped: {self.duplicate_qr_count}")

        return True

    def reconstruct_file(self):
        """Reconstruct the original file from decoded chunks"""
        if not self.metadata:
            print("\nError: No metadata found. Cannot reconstruct file.")
            return False

        expected_chunks = self.metadata['total_chunks']
        found_chunks = len(self.data_chunks)

        print(f"\n[Reconstructing File]")
        print(f"  Expected chunks: {expected_chunks}")
        print(f"  Found chunks: {found_chunks}")

        if found_chunks < expected_chunks:
            print(f"\n  Warning: Missing {expected_chunks - found_chunks} chunks!")
            missing = [i for i in range(expected_chunks) if i not in self.data_chunks]
            print(f"  Missing chunk indices: {missing[:10]}{'...' if len(missing) > 10 else ''}")

        # Reconstruct base64 data in order
        base64_parts = []
        for i in range(expected_chunks):
            if i in self.data_chunks:
                base64_parts.append(self.data_chunks[i]['payload'])
            else:
                print(f"\n  Error: Missing chunk {i}, cannot reconstruct file")
                return False

        # Combine and decode
        base64_data = ''.join(base64_parts)
        print(f"  Base64 data length: {len(base64_data)} chars")

        try:
            # Decode base64 to binary
            binary_data = base64.b64decode(base64_data)
            print(f"  Decoded binary size: {len(binary_data)} bytes")

            # Verify size matches metadata
            if len(binary_data) != self.metadata['filesize']:
                print(f"  Warning: Size mismatch! Expected {self.metadata['filesize']}, got {len(binary_data)}")

            # Write output file
            output_path = self.output_dir / self.metadata['filename']

            # Avoid overwriting existing files
            if output_path.exists():
                base_name = output_path.stem
                extension = output_path.suffix
                counter = 1
                while output_path.exists():
                    output_path = self.output_dir / f"{base_name}_{counter}{extension}"
                    counter += 1

            with open(output_path, 'wb') as f:
                f.write(binary_data)

            print(f"\n[Success!]")
            print(f"  File reconstructed: {output_path}")
            print(f"  Size: {len(binary_data)} bytes")

            return True

        except Exception as e:
            print(f"\n  Error during reconstruction: {e}")
            return False

    def decode(self):
        """Main decode process"""
        print("=" * 60)
        print("QRnator Decoder")
        print("=" * 60)

        if not Path(self.video_path).exists():
            print(f"Error: Video file not found: {self.video_path}")
            return False

        # Step 1: Scan video for QR codes
        if not self.decode_video():
            return False

        # Step 2: Reconstruct file
        if not self.reconstruct_file():
            return False

        print("\nDecoding complete!")
        return True


def main():
    if len(sys.argv) < 2:
        print("Usage: python decode.py <video_file.mp4> [output_directory]")
        print("\nExample:")
        print("  python decode.py recording.mp4")
        print("  python decode.py recording.mp4 ./output")
        sys.exit(1)

    video_path = sys.argv[1]
    output_dir = sys.argv[2] if len(sys.argv) > 2 else '.'

    decoder = QRDecoder(video_path, output_dir)
    success = decoder.decode()

    sys.exit(0 if success else 1)


if __name__ == '__main__':
    main()
