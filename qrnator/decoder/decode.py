#!/usr/bin/env python3
"""
QRnator Decoder - Extract and reconstruct files from QR-encoded video

This script processes video files (MP4) containing QR codes generated by QRnator,
extracts the encoded data, deduplicates frames, verifies checksums, and reconstructs
the original file(s) with proper metadata.

Supports:
- Multiple video files as input
- Multiple files encoded in a single video stream
- Comprehensive error reporting and logging
"""

import cv2
import sys
import base64
import os
from collections import defaultdict
from pathlib import Path
from urllib.parse import unquote
from datetime import datetime


class FileStream:
    """Represents a single file being decoded from QR codes"""

    def __init__(self, file_id, metadata):
        self.file_id = file_id
        self.metadata = metadata
        self.data_chunks = {}
        self.errors = []
        self.warnings = []

    def add_chunk(self, chunk):
        """Add a data chunk to this file stream"""
        seq = chunk['sequence']
        if seq in self.data_chunks:
            # Duplicate chunk - verify it matches
            if self.data_chunks[seq]['payload'] != chunk['payload']:
                self.warnings.append(f"Chunk {seq}: duplicate with different data")
        else:
            self.data_chunks[seq] = chunk

    def is_complete(self):
        """Check if all chunks have been received"""
        expected = self.metadata['total_chunks']
        return len(self.data_chunks) == expected

    def get_missing_chunks(self):
        """Return list of missing chunk indices"""
        expected = self.metadata['total_chunks']
        return [i for i in range(expected) if i not in self.data_chunks]

    def reconstruct(self):
        """Reconstruct the file from chunks"""
        if not self.is_complete():
            missing = self.get_missing_chunks()
            self.errors.append(f"Cannot reconstruct: missing {len(missing)} chunks: {missing[:10]}...")
            return None

        # Reconstruct base64 data in order
        base64_parts = []
        for i in range(self.metadata['total_chunks']):
            base64_parts.append(self.data_chunks[i]['payload'])

        base64_data = ''.join(base64_parts)

        try:
            # Decode base64 to binary
            binary_data = base64.b64decode(base64_data)

            # Verify size matches metadata
            if len(binary_data) != self.metadata['filesize']:
                self.warnings.append(
                    f"Size mismatch: expected {self.metadata['filesize']}, got {len(binary_data)}"
                )

            return binary_data

        except Exception as e:
            self.errors.append(f"Reconstruction failed: {e}")
            return None


class QRDecoder:
    def __init__(self, video_paths, output_dir='.', verbose=False):
        self.video_paths = video_paths if isinstance(video_paths, list) else [video_paths]
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.verbose = verbose

        # Storage for file streams (keyed by file_id)
        self.file_streams = {}

        # Global statistics
        self.stats = {
            'total_videos': len(self.video_paths),
            'total_frames': 0,
            'frames_with_qr': 0,
            'unique_qr_codes': 0,
            'duplicate_qr_codes': 0,
            'files_found': 0,
            'files_complete': 0,
            'files_reconstructed': 0
        }

        # Track all seen QR codes across all videos
        self.seen_qr_codes = set()

    def log(self, message, level='INFO'):
        """Log a message with timestamp"""
        timestamp = datetime.now().strftime('%H:%M:%S')
        prefix = {
            'INFO': '  ',
            'SUCCESS': '✓ ',
            'WARNING': '⚠ ',
            'ERROR': '✗ '
        }.get(level, '  ')
        print(f"[{timestamp}] {prefix}{message}")

    def debug(self, message):
        """Log debug message if verbose mode is enabled"""
        if self.verbose:
            self.log(message, 'DEBUG')

    def calculate_checksum(self, data):
        """Calculate checksum matching the JavaScript implementation"""
        checksum = 0
        for char in data:
            checksum = (checksum + ord(char)) % 65536
        return format(checksum, '04x')

    def verify_checksum(self, data, expected_checksum):
        """Verify data checksum"""
        calculated = self.calculate_checksum(data)
        return calculated == expected_checksum

    def parse_metadata(self, qr_data):
        """Parse metadata QR code
        Format: META:FILE_ID:filename:filesize:filetype:totalchunks:checksum
        """
        try:
            parts = qr_data.split(':', 6)
            if len(parts) != 7 or parts[0] != 'META':
                return None

            _, file_id, filename, filesize, filetype, total_chunks, checksum = parts

            # Verify checksum
            check_data = unquote(filename) + filesize + unquote(filetype)
            if not self.verify_checksum(check_data, checksum):
                self.log(f"Metadata checksum mismatch for file ID {file_id}", 'WARNING')

            metadata = {
                'file_id': file_id,
                'filename': unquote(filename),
                'filesize': int(filesize),
                'filetype': unquote(filetype),
                'total_chunks': int(total_chunks)
            }

            return metadata

        except Exception as e:
            self.log(f"Error parsing metadata: {e}", 'ERROR')
            return None

    def parse_data_chunk(self, qr_data):
        """Parse data chunk QR code
        Format: DATA:FILE_ID:SEQ:TOTAL:CHECKSUM:PAYLOAD
        """
        try:
            parts = qr_data.split(':', 5)
            if len(parts) != 6 or parts[0] != 'DATA':
                return None

            _, file_id, seq, total, checksum, payload = parts
            seq = int(seq)
            total = int(total)

            # Verify checksum
            if not self.verify_checksum(payload, checksum):
                self.log(f"Chunk checksum mismatch: File {file_id}, Seq {seq}", 'WARNING')
                return None

            return {
                'file_id': file_id,
                'sequence': seq,
                'total': total,
                'payload': payload
            }

        except Exception as e:
            self.log(f"Error parsing data chunk: {e}", 'ERROR')
            return None

    def process_qr_code(self, qr_data):
        """Process a decoded QR code"""
        # Skip if we've seen this exact QR code before (across all videos)
        if qr_data in self.seen_qr_codes:
            self.stats['duplicate_qr_codes'] += 1
            return

        self.seen_qr_codes.add(qr_data)
        self.stats['unique_qr_codes'] += 1

        # Determine type and parse
        if qr_data.startswith('META:'):
            metadata = self.parse_metadata(qr_data)
            if metadata:
                file_id = metadata['file_id']
                if file_id not in self.file_streams:
                    self.file_streams[file_id] = FileStream(file_id, metadata)
                    self.stats['files_found'] += 1
                    self.log(f"Found file: {metadata['filename']} (ID: {file_id[:8]})", 'SUCCESS')
                    self.log(f"  Size: {metadata['filesize']} bytes, Chunks: {metadata['total_chunks']}")

        elif qr_data.startswith('DATA:'):
            chunk = self.parse_data_chunk(qr_data)
            if chunk:
                file_id = chunk['file_id']
                if file_id in self.file_streams:
                    self.file_streams[file_id].add_chunk(chunk)
                    self.debug(f"Chunk received: File {file_id[:8]}, Seq {chunk['sequence']}/{chunk['total']}")
                else:
                    self.log(f"Data chunk for unknown file ID: {file_id[:8]}", 'WARNING')

    def decode_video(self, video_path):
        """Process a single video file and extract QR codes"""
        self.log(f"Processing video: {video_path}")

        if not Path(video_path).exists():
            self.log(f"Video file not found: {video_path}", 'ERROR')
            return False

        cap = cv2.VideoCapture(str(video_path))
        if not cap.isOpened():
            self.log(f"Could not open video file: {video_path}", 'ERROR')
            return False

        # Get video properties
        total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
        fps = cap.get(cv2.CAP_PROP_FPS)

        self.log(f"  Video info: {total_frames} frames @ {fps:.1f} FPS")

        # Initialize QR detector
        qr_detector = cv2.QRCodeDetector()

        frame_count = 0
        video_qr_count = 0
        last_progress = -1

        while True:
            ret, frame = cap.read()
            if not ret:
                break

            frame_count += 1
            self.stats['total_frames'] += 1

            # Update progress
            progress = int((frame_count / total_frames) * 100)
            if progress != last_progress and progress % 10 == 0:
                print(f"  Progress: {progress}% ({frame_count}/{total_frames} frames)", end='\r')
                last_progress = progress

            # Detect and decode QR code
            data, points, straight_qrcode = qr_detector.detectAndDecode(frame)

            if data:
                self.stats['frames_with_qr'] += 1
                video_qr_count += 1
                self.process_qr_code(data)

        cap.release()
        print()  # New line after progress

        self.log(f"  Found {video_qr_count} QR codes in this video")

        return True

    def write_file(self, file_stream, binary_data):
        """Write reconstructed file to disk"""
        filename = file_stream.metadata['filename']
        output_path = self.output_dir / filename

        # Avoid overwriting existing files
        if output_path.exists():
            base_name = output_path.stem
            extension = output_path.suffix
            counter = 1
            while output_path.exists():
                output_path = self.output_dir / f"{base_name}_{counter}{extension}"
                counter += 1

        try:
            with open(output_path, 'wb') as f:
                f.write(binary_data)

            self.log(f"File written: {output_path} ({len(binary_data)} bytes)", 'SUCCESS')
            return True

        except Exception as e:
            self.log(f"Failed to write file: {e}", 'ERROR')
            return False

    def reconstruct_files(self):
        """Reconstruct all detected files"""
        if not self.file_streams:
            self.log("No files found in video stream(s)", 'ERROR')
            return False

        self.log(f"\nReconstructing {len(self.file_streams)} file(s)...")

        success = True

        for file_id, file_stream in self.file_streams.items():
            metadata = file_stream.metadata
            self.log(f"\nFile: {metadata['filename']} (ID: {file_id[:8]})")

            # Check completeness
            expected = metadata['total_chunks']
            found = len(file_stream.data_chunks)
            self.log(f"  Chunks: {found}/{expected} ({found*100//expected if expected > 0 else 0}%)")

            if file_stream.is_complete():
                self.stats['files_complete'] += 1

                # Reconstruct
                binary_data = file_stream.reconstruct()
                if binary_data:
                    if self.write_file(file_stream, binary_data):
                        self.stats['files_reconstructed'] += 1
                    else:
                        success = False
                else:
                    success = False
                    for error in file_stream.errors:
                        self.log(f"  {error}", 'ERROR')

            else:
                success = False
                missing = file_stream.get_missing_chunks()
                self.log(f"  Missing {len(missing)} chunks", 'ERROR')
                if len(missing) <= 20:
                    self.log(f"  Missing indices: {missing}")
                else:
                    self.log(f"  Missing indices: {missing[:20]}... (showing first 20)")

            # Show warnings
            for warning in file_stream.warnings:
                self.log(f"  {warning}", 'WARNING')

        return success

    def print_summary(self):
        """Print decoding summary statistics"""
        print("\n" + "=" * 70)
        print("DECODING SUMMARY")
        print("=" * 70)

        s = self.stats

        print(f"\nVideos Processed:        {s['total_videos']}")
        print(f"Total Frames:            {s['total_frames']:,}")
        print(f"Frames with QR:          {s['frames_with_qr']:,}")
        print(f"Unique QR Codes:         {s['unique_qr_codes']:,}")
        print(f"Duplicate QR Codes:      {s['duplicate_qr_codes']:,}")
        print(f"\nFiles Detected:          {s['files_found']}")
        print(f"Files Complete:          {s['files_complete']}")
        print(f"Files Reconstructed:     {s['files_reconstructed']}")

        print("\nFile Details:")
        if self.file_streams:
            for file_id, fs in self.file_streams.items():
                m = fs.metadata
                complete = "✓" if fs.is_complete() else "✗"
                chunks = f"{len(fs.data_chunks)}/{m['total_chunks']}"
                print(f"  {complete} {m['filename']:<40} {chunks:>10} chunks")
        else:
            print("  (no files detected)")

        print("=" * 70)

    def decode(self):
        """Main decode process"""
        print("=" * 70)
        print("QRnator Decoder")
        print("=" * 70)
        print()

        # Process all video files
        for video_path in self.video_paths:
            if not self.decode_video(video_path):
                self.log(f"Failed to process: {video_path}", 'ERROR')

        # Reconstruct files
        success = self.reconstruct_files()

        # Print summary
        self.print_summary()

        if success and self.stats['files_reconstructed'] > 0:
            print(f"\n✓ Successfully reconstructed {self.stats['files_reconstructed']} file(s)")
            return True
        else:
            print(f"\n✗ Decoding incomplete or failed")
            return False


def main():
    if len(sys.argv) < 2:
        print("QRnator Decoder - Extract files from QR-encoded videos")
        print("\nUsage:")
        print("  python decode.py <video_file> [video_file2 ...] [OPTIONS]")
        print("\nOptions:")
        print("  -o, --output DIR    Output directory (default: current directory)")
        print("  -v, --verbose       Enable verbose logging")
        print("\nExamples:")
        print("  python decode.py recording.mp4")
        print("  python decode.py video1.mp4 video2.mp4 -o ./output")
        print("  python decode.py recording.mp4 --verbose")
        print("\nThe decoder will:")
        print("  • Process one or more video files")
        print("  • Extract all QR codes and deduplicate")
        print("  • Handle multiple files encoded in the same video")
        print("  • Use the original filename from metadata")
        print("  • Verify checksums for all chunks")
        sys.exit(1)

    # Parse arguments
    video_paths = []
    output_dir = '.'
    verbose = False

    i = 1
    while i < len(sys.argv):
        arg = sys.argv[i]
        if arg in ['-o', '--output']:
            if i + 1 < len(sys.argv):
                output_dir = sys.argv[i + 1]
                i += 2
            else:
                print("Error: -o/--output requires a directory argument")
                sys.exit(1)
        elif arg in ['-v', '--verbose']:
            verbose = True
            i += 1
        elif arg.startswith('-'):
            print(f"Error: Unknown option: {arg}")
            sys.exit(1)
        else:
            video_paths.append(arg)
            i += 1

    if not video_paths:
        print("Error: No video files specified")
        sys.exit(1)

    # Validate video files exist
    missing = [p for p in video_paths if not Path(p).exists()]
    if missing:
        print(f"Error: Video file(s) not found:")
        for p in missing:
            print(f"  {p}")
        sys.exit(1)

    # Run decoder
    decoder = QRDecoder(video_paths, output_dir, verbose)
    success = decoder.decode()

    sys.exit(0 if success else 1)


if __name__ == '__main__':
    main()
