<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QRnator - File to QR Code Encoder</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
            padding: 40px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        .drop-zone {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 60px 20px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
            background: #f8f9fa;
            margin-bottom: 30px;
        }

        .drop-zone.drag-over {
            background: #e7eaff;
            border-color: #764ba2;
            transform: scale(1.02);
        }

        .drop-zone:hover {
            background: #f0f2ff;
        }

        .drop-zone-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .drop-zone-text {
            font-size: 1.2em;
            color: #555;
            margin-bottom: 10px;
        }

        .drop-zone-subtext {
            font-size: 0.9em;
            color: #888;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }

        select, input[type="number"] {
            padding: 10px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        select:hover, input[type="number"]:hover {
            border-color: #667eea;
        }

        select:focus, input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #218838;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #c82333;
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .info {
            color: #004085;
            background: #cce5ff;
            border: 1px solid #b8daff;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        .status {
            background: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .status-label {
            color: #666;
            font-weight: 600;
        }

        .status-value {
            color: #333;
            font-family: 'Courier New', monospace;
        }

        .qr-display {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
            background: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 20px;
            position: relative;
        }

        .qr-canvas {
            border: 4px solid white;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            background: white;
        }

        .qr-info {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 0.85em;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .qr-info-label {
            font-weight: 600;
            color: #667eea;
            margin-bottom: 4px;
        }

        .qr-placeholder {
            color: #999;
            font-size: 1.2em;
            text-align: center;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            border-radius: 4px;
        }

        .hidden {
            display: none;
        }

        .file-info {
            background: #e7f3ff;
            border: 2px solid #2196F3;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .file-info-title {
            font-weight: 600;
            color: #1976D2;
            margin-bottom: 8px;
        }

        .file-info-detail {
            font-size: 0.9em;
            color: #555;
            margin: 4px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>QRnator</h1>
        <p class="subtitle">Encode files into sequential QR codes with checksums</p>

        <div class="info">
            Drag and drop a file onto the area below. The file will be base64-encoded, split into chunks, and each chunk will be encoded as a QR code with sequence number and checksum. Configure the settings before starting playback.
        </div>

        <div class="drop-zone" id="dropZone">
            <div class="drop-zone-icon">üìÅ</div>
            <div class="drop-zone-text">Drag & Drop a file here</div>
            <div class="drop-zone-subtext">or click to browse</div>
            <input type="file" id="fileInput" style="display: none;">
        </div>

        <div id="fileInfo" class="file-info hidden">
            <div class="file-info-title">File Information</div>
            <div class="file-info-detail"><strong>Name:</strong> <span id="fileName"></span></div>
            <div class="file-info-detail"><strong>Size:</strong> <span id="fileSize"></span></div>
            <div class="file-info-detail"><strong>Type:</strong> <span id="fileType"></span></div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="qrSize">QR Code Size:</label>
                <select id="qrSize">
                    <option value="200">Small (200px)</option>
                    <option value="300" selected>Medium (300px)</option>
                    <option value="400">Large (400px)</option>
                    <option value="500">Extra Large (500px)</option>
                </select>
            </div>

            <div class="control-group">
                <label for="qrErrorCorrection">Error Correction:</label>
                <select id="qrErrorCorrection">
                    <option value="L">Low (7%)</option>
                    <option value="M" selected>Medium (15%)</option>
                    <option value="Q">Quartile (25%)</option>
                    <option value="H">High (30%)</option>
                </select>
            </div>

            <div class="control-group">
                <label for="chunkSize">Chunk Size (bytes):</label>
                <select id="chunkSize">
                    <option value="100">100 bytes</option>
                    <option value="200">200 bytes</option>
                    <option value="500" selected>500 bytes</option>
                    <option value="1000">1000 bytes</option>
                    <option value="2000">2000 bytes</option>
                </select>
            </div>

            <div class="control-group">
                <label for="playbackSpeed">Playback Speed:</label>
                <select id="playbackSpeed">
                    <option value="500">Very Fast (0.5s)</option>
                    <option value="1000">Fast (1s)</option>
                    <option value="2000" selected>Normal (2s)</option>
                    <option value="3000">Slow (3s)</option>
                    <option value="5000">Very Slow (5s)</option>
                </select>
            </div>
        </div>

        <div class="button-group">
            <button class="btn-primary" id="generateBtn" disabled>Generate QR Codes</button>
            <button class="btn-success" id="playBtn" disabled>Play Sequence</button>
            <button class="btn-danger" id="stopBtn" disabled>Stop</button>
            <button class="btn-secondary" id="resetBtn" disabled>Reset</button>
        </div>

        <div id="status" class="status hidden">
            <div class="status-row">
                <span class="status-label">Total Chunks:</span>
                <span class="status-value" id="totalChunks">0</span>
            </div>
            <div class="status-row">
                <span class="status-label">Current Chunk:</span>
                <span class="status-value" id="currentChunk">0</span>
            </div>
            <div class="status-row">
                <span class="status-label">Base64 Size:</span>
                <span class="status-value" id="base64Size">0</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
        </div>

        <div class="qr-display" id="qrDisplay">
            <div class="qr-placeholder">Drop a file to get started</div>
        </div>
    </div>

    <script>
        // QR Code Generator using QRious-style library (self-contained)
        // Based on https://github.com/davidshimjs/qrcodejs
        const QRCode = (function() {
            'use strict';

            function QR8bitByte(data) {
                this.mode = 4; // MODE_8BIT_BYTE
                this.data = data;
            }

            QR8bitByte.prototype = {
                getLength: function() {
                    return this.data.length;
                },
                write: function(buffer) {
                    for (var i = 0; i < this.data.length; i++) {
                        buffer.put(this.data.charCodeAt(i), 8);
                    }
                }
            };

            function QRCodeModel(typeNumber, errorCorrectLevel) {
                this.typeNumber = typeNumber;
                this.errorCorrectLevel = errorCorrectLevel;
                this.modules = null;
                this.moduleCount = 0;
                this.dataCache = null;
                this.dataList = [];
            }

            QRCodeModel.prototype = {
                addData: function(data) {
                    var newData = new QR8bitByte(data);
                    this.dataList.push(newData);
                    this.dataCache = null;
                },
                make: function() {
                    this.makeImpl(false, this.getBestMaskPattern());
                },
                getBestMaskPattern: function() {
                    // For simplicity, just use pattern 0
                    return 0;
                },
                makeImpl: function(test, maskPattern) {
                    this.moduleCount = this.typeNumber * 4 + 17;
                    this.modules = new Array(this.moduleCount);
                    for (var row = 0; row < this.moduleCount; row++) {
                        this.modules[row] = new Array(this.moduleCount);
                    }
                    this.setupPositionProbePattern(0, 0);
                    this.setupPositionProbePattern(this.moduleCount - 7, 0);
                    this.setupPositionProbePattern(0, this.moduleCount - 7);
                    this.setupPositionAdjustPattern();
                    this.setupTimingPattern();
                    this.setupTypeInfo(test, maskPattern);
                    if (this.typeNumber >= 7) {
                        this.setupTypeNumber(test);
                    }
                    if (this.dataCache == null) {
                        this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
                    }
                    this.mapData(this.dataCache, maskPattern);
                },
                setupPositionProbePattern: function(row, col) {
                    for (var r = -1; r <= 7; r++) {
                        if (row + r <= -1 || this.moduleCount <= row + r) continue;
                        for (var c = -1; c <= 7; c++) {
                            if (col + c <= -1 || this.moduleCount <= col + c) continue;
                            if ((0 <= r && r <= 6 && (c == 0 || c == 6)) || (0 <= c && c <= 6 && (r == 0 || r == 6)) || (2 <= r && r <= 4 && 2 <= c && c <= 4)) {
                                this.modules[row + r][col + c] = true;
                            } else {
                                this.modules[row + r][col + c] = false;
                            }
                        }
                    }
                },
                setupPositionAdjustPattern: function() {
                    // Simplified - skip for now
                },
                setupTimingPattern: function() {
                    for (var r = 8; r < this.moduleCount - 8; r++) {
                        if (this.modules[r][6] != null) continue;
                        this.modules[r][6] = (r % 2 == 0);
                    }
                    for (var c = 8; c < this.moduleCount - 8; c++) {
                        if (this.modules[6][c] != null) continue;
                        this.modules[6][c] = (c % 2 == 0);
                    }
                },
                setupTypeNumber: function(test) {
                    // Skip for simplicity
                },
                setupTypeInfo: function(test, maskPattern) {
                    // Simplified
                    var data = (this.errorCorrectLevel << 3) | maskPattern;
                    var bits = QRUtil.getBCHTypeInfo(data);
                    for (var i = 0; i < 15; i++) {
                        var mod = (!test && ((bits >> i) & 1) == 1);
                        if (i < 6) {
                            this.modules[i][8] = mod;
                        } else if (i < 8) {
                            this.modules[i + 1][8] = mod;
                        } else {
                            this.modules[this.moduleCount - 15 + i][8] = mod;
                        }
                    }
                    for (var i = 0; i < 15; i++) {
                        var mod = (!test && ((bits >> i) & 1) == 1);
                        if (i < 8) {
                            this.modules[8][this.moduleCount - i - 1] = mod;
                        } else if (i < 9) {
                            this.modules[8][15 - i - 1 + 1] = mod;
                        } else {
                            this.modules[8][15 - i - 1] = mod;
                        }
                    }
                    this.modules[this.moduleCount - 8][8] = (!test);
                },
                mapData: function(data, maskPattern) {
                    var inc = -1;
                    var row = this.moduleCount - 1;
                    var bitIndex = 7;
                    var byteIndex = 0;
                    for (var col = this.moduleCount - 1; col > 0; col -= 2) {
                        if (col == 6) col--;
                        while (true) {
                            for (var c = 0; c < 2; c++) {
                                if (this.modules[row][col - c] == null) {
                                    var dark = false;
                                    if (byteIndex < data.length) {
                                        dark = (((data[byteIndex] >>> bitIndex) & 1) == 1);
                                    }
                                    var mask = QRUtil.getMask(maskPattern, row, col - c);
                                    if (mask) {
                                        dark = !dark;
                                    }
                                    this.modules[row][col - c] = dark;
                                    bitIndex--;
                                    if (bitIndex == -1) {
                                        byteIndex++;
                                        bitIndex = 7;
                                    }
                                }
                            }
                            row += inc;
                            if (row < 0 || this.moduleCount <= row) {
                                row -= inc;
                                inc = -inc;
                                break;
                            }
                        }
                    }
                }
            };

            QRCodeModel.createData = function(typeNumber, errorCorrectLevel, dataList) {
                var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
                var buffer = new QRBitBuffer();
                for (var i = 0; i < dataList.length; i++) {
                    var data = dataList[i];
                    buffer.put(data.mode, 4);
                    buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
                    data.write(buffer);
                }
                var totalDataCount = 0;
                for (var i = 0; i < rsBlocks.length; i++) {
                    totalDataCount += rsBlocks[i].dataCount;
                }
                if (buffer.getLengthInBits() > totalDataCount * 8) {
                    throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")");
                }
                if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
                    buffer.put(0, 4);
                }
                while (buffer.getLengthInBits() % 8 != 0) {
                    buffer.putBit(false);
                }
                while (true) {
                    if (buffer.getLengthInBits() >= totalDataCount * 8) {
                        break;
                    }
                    buffer.put(0xEC, 8);
                    if (buffer.getLengthInBits() >= totalDataCount * 8) {
                        break;
                    }
                    buffer.put(0x11, 8);
                }
                return QRCodeModel.createBytes(buffer, rsBlocks);
            };

            QRCodeModel.createBytes = function(buffer, rsBlocks) {
                var offset = 0;
                var maxDcCount = 0;
                var maxEcCount = 0;
                var dcdata = new Array(rsBlocks.length);
                var ecdata = new Array(rsBlocks.length);
                for (var r = 0; r < rsBlocks.length; r++) {
                    var dcCount = rsBlocks[r].dataCount;
                    var ecCount = rsBlocks[r].totalCount - dcCount;
                    maxDcCount = Math.max(maxDcCount, dcCount);
                    maxEcCount = Math.max(maxEcCount, ecCount);
                    dcdata[r] = new Array(dcCount);
                    for (var i = 0; i < dcdata[r].length; i++) {
                        dcdata[r][i] = 0xff & buffer.buffer[i + offset];
                    }
                    offset += dcCount;
                    var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
                    var rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);
                    var modPoly = rawPoly.mod(rsPoly);
                    ecdata[r] = new Array(rsPoly.getLength() - 1);
                    for (var i = 0; i < ecdata[r].length; i++) {
                        var modIndex = i + modPoly.getLength() - ecdata[r].length;
                        ecdata[r][i] = (modIndex >= 0) ? modPoly.get(modIndex) : 0;
                    }
                }
                var totalCodeCount = 0;
                for (var i = 0; i < rsBlocks.length; i++) {
                    totalCodeCount += rsBlocks[i].totalCount;
                }
                var data = new Array(totalCodeCount);
                var index = 0;
                for (var i = 0; i < maxDcCount; i++) {
                    for (var r = 0; r < rsBlocks.length; r++) {
                        if (i < dcdata[r].length) {
                            data[index++] = dcdata[r][i];
                        }
                    }
                }
                for (var i = 0; i < maxEcCount; i++) {
                    for (var r = 0; r < rsBlocks.length; r++) {
                        if (i < ecdata[r].length) {
                            data[index++] = ecdata[r][i];
                        }
                    }
                }
                return data;
            };

            // QRRSBlock, QRBitBuffer, QRMath, QRPolynomial, QRUtil helper classes
            function QRRSBlock(totalCount, dataCount) {
                this.totalCount = totalCount;
                this.dataCount = dataCount;
            }

            QRRSBlock.RS_BLOCK_TABLE = [
                [1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9],
                [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16],
                [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13],
                [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9],
                [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12],
                [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15],
                [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14],
                [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15],
                [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13],
                [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16]
            ];

            QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
                var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
                if (rsBlock == undefined) {
                    throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
                }
                var length = rsBlock.length / 3;
                var list = [];
                for (var i = 0; i < length; i++) {
                    var count = rsBlock[i * 3 + 0];
                    var totalCount = rsBlock[i * 3 + 1];
                    var dataCount = rsBlock[i * 3 + 2];
                    for (var j = 0; j < count; j++) {
                        list.push(new QRRSBlock(totalCount, dataCount));
                    }
                }
                return list;
            };

            QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
                switch (errorCorrectLevel) {
                    case 1: return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
                    case 0: return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
                    case 3: return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
                    case 2: return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
                    default: return undefined;
                }
            };

            function QRBitBuffer() {
                this.buffer = [];
                this.length = 0;
            }

            QRBitBuffer.prototype = {
                get: function(index) {
                    var bufIndex = Math.floor(index / 8);
                    return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) == 1;
                },
                put: function(num, length) {
                    for (var i = 0; i < length; i++) {
                        this.putBit(((num >>> (length - i - 1)) & 1) == 1);
                    }
                },
                getLengthInBits: function() {
                    return this.length;
                },
                putBit: function(bit) {
                    var bufIndex = Math.floor(this.length / 8);
                    if (this.buffer.length <= bufIndex) {
                        this.buffer.push(0);
                    }
                    if (bit) {
                        this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
                    }
                    this.length++;
                }
            };

            var QRMath = {
                glog: function(n) {
                    if (n < 1) {
                        throw new Error("glog(" + n + ")");
                    }
                    return QRMath.LOG_TABLE[n];
                },
                gexp: function(n) {
                    while (n < 0) {
                        n += 255;
                    }
                    while (n >= 256) {
                        n -= 255;
                    }
                    return QRMath.EXP_TABLE[n];
                },
                EXP_TABLE: new Array(256),
                LOG_TABLE: new Array(256)
            };

            for (var i = 0; i < 8; i++) {
                QRMath.EXP_TABLE[i] = 1 << i;
            }
            for (var i = 8; i < 256; i++) {
                QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
            }
            for (var i = 0; i < 255; i++) {
                QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
            }

            function QRPolynomial(num, shift) {
                if (num.length == undefined) {
                    throw new Error(num.length + "/" + shift);
                }
                var offset = 0;
                while (offset < num.length && num[offset] == 0) {
                    offset++;
                }
                this.num = new Array(num.length - offset + shift);
                for (var i = 0; i < num.length - offset; i++) {
                    this.num[i] = num[i + offset];
                }
            }

            QRPolynomial.prototype = {
                get: function(index) {
                    return this.num[index];
                },
                getLength: function() {
                    return this.num.length;
                },
                multiply: function(e) {
                    var num = new Array(this.getLength() + e.getLength() - 1);
                    for (var i = 0; i < this.getLength(); i++) {
                        for (var j = 0; j < e.getLength(); j++) {
                            num[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
                        }
                    }
                    return new QRPolynomial(num, 0);
                },
                mod: function(e) {
                    if (this.getLength() - e.getLength() < 0) {
                        return this;
                    }
                    var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
                    var num = new Array(this.getLength());
                    for (var i = 0; i < this.getLength(); i++) {
                        num[i] = this.get(i);
                    }
                    for (var i = 0; i < e.getLength(); i++) {
                        num[i] ^= QRMath.gexp(QRMath.glog(e.get(i)) + ratio);
                    }
                    return new QRPolynomial(num, 0).mod(e);
                }
            };

            var QRUtil = {
                PATTERN_POSITION_TABLE: [
                    [],
                    [6, 18],
                    [6, 22],
                    [6, 26],
                    [6, 30],
                    [6, 34],
                    [6, 22, 38],
                    [6, 24, 42],
                    [6, 26, 46],
                    [6, 28, 50]
                ],
                G15: (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0),
                G18: (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0),
                G15_MASK: (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1),
                getBCHTypeInfo: function(data) {
                    var d = data << 10;
                    while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
                        d ^= (QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15)));
                    }
                    return ((data << 10) | d) ^ QRUtil.G15_MASK;
                },
                getBCHDigit: function(data) {
                    var digit = 0;
                    while (data != 0) {
                        digit++;
                        data >>>= 1;
                    }
                    return digit;
                },
                getMask: function(maskPattern, i, j) {
                    switch (maskPattern) {
                        case 0: return ((i + j) % 2 == 0);
                        case 1: return (i % 2 == 0);
                        case 2: return (j % 3 == 0);
                        case 3: return ((i + j) % 3 == 0);
                        case 4: return (((i / 2) + (j / 3)) % 2 == 0);
                        case 5: return (((i * j) % 2) + ((i * j) % 3) == 0);
                        case 6: return ((((i * j) % 2) + ((i * j) % 3)) % 2 == 0);
                        case 7: return ((((i * j) % 3) + ((i + j) % 2)) % 2 == 0);
                        default: throw new Error("bad maskPattern:" + maskPattern);
                    }
                },
                getErrorCorrectPolynomial: function(errorCorrectLength) {
                    var a = new QRPolynomial([1], 0);
                    for (var i = 0; i < errorCorrectLength; i++) {
                        a = a.multiply(new QRPolynomial([1, QRMath.gexp(i)], 0));
                    }
                    return a;
                },
                getLengthInBits: function(mode, type) {
                    if (1 <= type && type < 10) {
                        switch (mode) {
                            case 1: return 10;
                            case 2: return 9;
                            case 4: return 8;
                            case 8: return 8;
                            default: throw new Error("mode:" + mode);
                        }
                    } else if (type < 27) {
                        switch (mode) {
                            case 1: return 12;
                            case 2: return 11;
                            case 4: return 16;
                            case 8: return 10;
                            default: throw new Error("mode:" + mode);
                        }
                    } else if (type < 41) {
                        switch (mode) {
                            case 1: return 14;
                            case 2: return 13;
                            case 4: return 16;
                            case 8: return 12;
                            default: throw new Error("mode:" + mode);
                        }
                    } else {
                        throw new Error("type:" + type);
                    }
                }
            };

            // Map error correction level names to numeric codes
            var ECLevelMap = {
                'L': 1,
                'M': 0,
                'Q': 3,
                'H': 2
            };

            // Auto-determine optimal type number (version)
            function getTypeNumber(text, errorCorrectLevel) {
                var numericEC = ECLevelMap[errorCorrectLevel] || 0;
                for (var typeNumber = 1; typeNumber <= 10; typeNumber++) {
                    try {
                        var qr = new QRCodeModel(typeNumber, numericEC);
                        qr.addData(text);
                        qr.make();
                        return typeNumber;
                    } catch (e) {
                        // Try next version
                    }
                }
                return 10; // Fallback to max
            }

            return {
                generate: function(canvas, text, options) {
                    options = options || {};
                    var errorCorrectLevel = options.errorCorrection || 'M';
                    var size = options.size || 300;

                    // Auto-select type number
                    var typeNumber = getTypeNumber(text, errorCorrectLevel);
                    var numericEC = ECLevelMap[errorCorrectLevel] || 0;

                    var qr = new QRCodeModel(typeNumber, numericEC);
                    qr.addData(text);
                    qr.make();

                    var moduleCount = qr.moduleCount;
                    var cellSize = Math.floor(size / (moduleCount + 2));
                    var offset = Math.floor((size - cellSize * moduleCount) / 2);

                    canvas.width = size;
                    canvas.height = size;

                    var ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, size, size);

                    ctx.fillStyle = '#000000';
                    for (var row = 0; row < moduleCount; row++) {
                        for (var col = 0; col < moduleCount; col++) {
                            if (qr.modules[row][col]) {
                                ctx.fillRect(
                                    offset + col * cellSize,
                                    offset + row * cellSize,
                                    cellSize,
                                    cellSize
                                );
                            }
                        }
                    }
                }
            };
        })();

        // Application state
        let fileData = null;
        let base64Data = null;
        let chunks = [];
        let currentChunkIndex = 0;
        let playbackInterval = null;
        let isPlaying = false;

        // DOM elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const generateBtn = document.getElementById('generateBtn');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const resetBtn = document.getElementById('resetBtn');
        const status = document.getElementById('status');
        const qrDisplay = document.getElementById('qrDisplay');

        // Utility functions
        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        function calculateChecksum(data) {
            let checksum = 0;
            for (let i = 0; i < data.length; i++) {
                checksum = (checksum + data.charCodeAt(i)) % 65536;
            }
            return checksum.toString(16).padStart(4, '0');
        }

        function generateFileId(filename, size, type) {
            // Generate a unique file ID from metadata
            const data = `${filename}:${size}:${type}:${Date.now()}`;
            let hash = 0;
            for (let i = 0; i < data.length; i++) {
                const char = data.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return Math.abs(hash).toString(16).padStart(8, '0');
        }

        // File handling
        dropZone.addEventListener('click', () => fileInput.click());

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            const file = e.dataTransfer.files[0];
            if (file) handleFile(file);
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFile(file);
        });

        function handleFile(file) {
            fileData = file;

            // Update file info
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileSize').textContent = formatBytes(file.size);
            document.getElementById('fileType').textContent = file.type || 'unknown';
            fileInfo.classList.remove('hidden');

            // Enable generate button
            generateBtn.disabled = false;
            resetBtn.disabled = false;

            // Read file as base64
            const reader = new FileReader();
            reader.onload = function(e) {
                const arrayBuffer = e.target.result;
                const bytes = new Uint8Array(arrayBuffer);
                base64Data = btoa(String.fromCharCode.apply(null, bytes));
                document.getElementById('base64Size').textContent = formatBytes(base64Data.length);
            };
            reader.readAsArrayBuffer(file);
        }

        // Generate QR codes
        generateBtn.addEventListener('click', () => {
            if (!base64Data) {
                alert('Please select a file first');
                return;
            }

            const chunkSize = parseInt(document.getElementById('chunkSize').value);
            chunks = [];

            // Calculate total data chunks
            const totalDataChunks = Math.ceil(base64Data.length / chunkSize);

            // Generate unique file ID
            const fileId = generateFileId(fileData.name, fileData.size, fileData.type || 'application/octet-stream');

            // First chunk: Metadata
            // Format: META:FILE_ID:filename:filesize:filetype:totalchunks:checksum
            const metaChecksum = calculateChecksum(fileData.name + fileData.size + fileData.type);
            const metaPayload = `META:${fileId}:${encodeURIComponent(fileData.name)}:${fileData.size}:${encodeURIComponent(fileData.type || 'application/octet-stream')}:${totalDataChunks}:${metaChecksum}`;
            chunks.push(metaPayload);

            // Split base64 into data chunks
            for (let i = 0; i < base64Data.length; i += chunkSize) {
                const chunk = base64Data.substring(i, i + chunkSize);
                const sequence = Math.floor(i / chunkSize);
                const checksum = calculateChecksum(chunk);

                // Format: DATA:FILE_ID:SEQ:TOTAL:CHECKSUM:PAYLOAD
                const payload = `DATA:${fileId}:${sequence}:${totalDataChunks}:${checksum}:${chunk}`;
                chunks.push(payload);
            }

            // Update status (total chunks includes metadata chunk)
            document.getElementById('totalChunks').textContent = chunks.length;
            document.getElementById('currentChunk').textContent = '0';
            status.classList.remove('hidden');

            // Enable play button
            playBtn.disabled = false;
            currentChunkIndex = 0;

            // Show first QR code
            displayQRCode(0);
        });

        function displayQRCode(index) {
            if (index < 0 || index >= chunks.length) return;

            currentChunkIndex = index;
            const chunk = chunks[index];

            // Clear display
            qrDisplay.innerHTML = '';

            // Create info overlay
            const info = document.createElement('div');
            info.className = 'qr-info';
            const chunkType = chunk.startsWith('META:') ? 'Metadata' : `Data ${index}`;
            info.innerHTML = `
                <div class="qr-info-label">${chunkType} - ${index + 1} of ${chunks.length}</div>
                <div>${Math.round(((index + 1) / chunks.length) * 100)}% complete</div>
            `;
            qrDisplay.appendChild(info);

            // Create canvas for QR code
            const canvas = document.createElement('canvas');
            canvas.className = 'qr-canvas';
            qrDisplay.appendChild(canvas);

            // Generate QR code
            const size = parseInt(document.getElementById('qrSize').value);
            const errorCorrection = document.getElementById('qrErrorCorrection').value;

            try {
                QRCode.generate(canvas, chunk, {
                    size: size,
                    errorCorrection: errorCorrection
                });
            } catch (error) {
                console.error('QR generation error:', error);
                qrDisplay.innerHTML = '<div class="qr-placeholder">Error generating QR code</div>';
            }

            // Update progress
            document.getElementById('currentChunk').textContent = index + 1;
            const progress = ((index + 1) / chunks.length) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
        }

        // Playback controls
        playBtn.addEventListener('click', () => {
            if (chunks.length === 0) {
                alert('Please generate QR codes first');
                return;
            }

            isPlaying = true;
            playBtn.disabled = true;
            stopBtn.disabled = false;
            generateBtn.disabled = true;

            const speed = parseInt(document.getElementById('playbackSpeed').value);

            playbackInterval = setInterval(() => {
                displayQRCode(currentChunkIndex);
                currentChunkIndex++;

                if (currentChunkIndex >= chunks.length) {
                    currentChunkIndex = 0; // Loop
                }
            }, speed);
        });

        stopBtn.addEventListener('click', () => {
            if (playbackInterval) {
                clearInterval(playbackInterval);
                playbackInterval = null;
            }
            isPlaying = false;
            playBtn.disabled = false;
            stopBtn.disabled = true;
            generateBtn.disabled = false;
        });

        resetBtn.addEventListener('click', () => {
            // Stop playback
            if (playbackInterval) {
                clearInterval(playbackInterval);
                playbackInterval = null;
            }

            // Reset state
            fileData = null;
            base64Data = null;
            chunks = [];
            currentChunkIndex = 0;
            isPlaying = false;

            // Reset UI
            fileInfo.classList.add('hidden');
            status.classList.add('hidden');
            qrDisplay.innerHTML = '<div class="qr-placeholder">Drop a file to get started</div>';

            generateBtn.disabled = true;
            playBtn.disabled = true;
            stopBtn.disabled = true;
            resetBtn.disabled = true;

            fileInput.value = '';
        });
    </script>
</body>
</html>
