#!/usr/bin/env perl
use strict;
use warnings;
use Getopt::Long;

# Options
my @only       = ();  # repeat: --only visa --only mc
my @ignore     = ();  # repeat: --ignore amex
my $aggressive = 0;   # include 'unknown' scheme by default
my $wipe       = 0;   # zero entire PAN; default is preserve BIN+last4
my $help       = 0;   # display help
my $luhn       = 1;   # --luhn / --no-luhn toggle (default on)
my $ebcdic     = 0;   # --ebcdic mode
my $report     = 0;   # --report flag for statistics

GetOptions(
  'only=s@'    => \@only,
  'ignore=s@'  => \@ignore,
  'aggressive' => \$aggressive,
  'wipe'       => \$wipe,
  'luhn!'      => \$luhn,       
  'ebcdic'     => \$ebcdic,     
  'report'     => \$report,
  'help'       => \$help
) or die "Error parsing options\n";

if ($help) {
  print_help();
  exit 0;
}

# Canonical schemes we recognise
my @KNOWN_SCHEMES = qw(visa mastercard amex discover);
my @ALL_SCHEMES   = (@KNOWN_SCHEMES, 'unknown');

# Statistics tracking
my %STATS = ();
for my $s (@KNOWN_SCHEMES, 'unknown') {
  $STATS{$s} = 0;
}

# Binary-safe I/O
binmode(STDIN);
binmode(STDOUT);
binmode(STDERR);

# EBCDIC to ASCII translation tables (digits and common chars)
my @EBCDIC_TO_ASCII = $ebcdic ? ((0) x 256) : undef;
my @ASCII_TO_EBCDIC = $ebcdic ? ((0) x 256) : undef;

# Initialise translation tables
init_ebcdic_tables() if $ebcdic;

sub init_ebcdic_tables {
  # EBCDIC digits (0xF0-0xF9) to ASCII (0x30-0x39)
  for my $i (0 .. 9) {
    $EBCDIC_TO_ASCII[0xF0 + $i] = 0x30 + $i;
    $ASCII_TO_EBCDIC[0x30 + $i] = 0xF0 + $i;
  }
  
  # Common separators
  $EBCDIC_TO_ASCII[0x40] = 0x20;  # space
  $ASCII_TO_EBCDIC[0x20] = 0x40;
  $EBCDIC_TO_ASCII[0x60] = 0x2D;  # hyphen
  $ASCII_TO_EBCDIC[0x2D] = 0x60;
  
  # Pass through other bytes unchanged (for mixed content)
  for my $i (0 .. 255) {
    $EBCDIC_TO_ASCII[$i] ||= $i;
    $ASCII_TO_EBCDIC[$i] ||= $i;
  }
}

sub ebcdic_to_ascii {
  my ($data) = @_;
  return join('', map { chr($EBCDIC_TO_ASCII[ord($_)]) } split //, $data);
}

sub ascii_to_ebcdic {
  my ($data) = @_;
  return join('', map { chr($ASCII_TO_EBCDIC[ord($_)]) } split //, $data);
}

# Build allow-list from flags
my %ALLOW = ();

sub normalise_scheme {
  my ($s) = @_;
  return '' unless defined $s;
  $s =~ s/^\s+|\s+$//g;
  $s = lc $s;

  return 'visa'       if $s eq 'v' || $s eq 'visa';
  return 'mastercard'
    if $s eq 'mc'
    || $s eq 'master'
    || $s eq 'mast'
    || $s eq 'mastercard';
  return 'amex'
    if $s eq 'ae'
    || $s eq 'amex'
    || $s eq 'american'
    || $s eq 'americanexpress';
  return 'discover' if $s eq 'disc' || $s eq 'discover';
  return 'unknown'  if $s eq 'unknown';
  return '';
}

# Include defaults or explicit --only
if (@only) {
  for my $tok (@only) {
    my $canon = normalise_scheme($tok);
    die "Unrecognised scheme for --only: '$tok'\n" unless $canon;
    $ALLOW{$canon} = 1;
  }
} else {
  # No --only: default to known schemes; include unknown if aggressive
  $ALLOW{$_} = 1 for @KNOWN_SCHEMES;
  $ALLOW{unknown} = 1 if $aggressive;
}

# Apply ignores (highest precedence)
for my $tok (@ignore) {
  my $canon = normalise_scheme($tok);
  die "Unrecognised scheme for --ignore: '$tok'\n" unless $canon;
  delete $ALLOW{$canon};
}

# Identify PAN-like candidate substrings:
my $PAN_REGEX = qr{
  (?<!\d)               # not preceded by a digit
  (?:\d[- ]?){12,18}    # 12–18 occurrences of digit with optional sep
  \d                    # final digit = total 13–19 digits
  (?!\d)
}x;

# Regex for long digit strings that might contain embedded PANs
my $LONG_DIGITS_REGEX = qr{\d{13,}}x;

# Stream processing parameters
my $CHUNK   = 1024 * 1024;  # 1 MiB
my $OVERLAP = 128;          # overlap to catch boundary-spanning matches

# Process files or STDIN
if (@ARGV) {
  for my $path (@ARGV) {
    open my $fh, '<', $path
      or die "Cannot open '$path' for reading: $!";
    binmode($fh);
    process_stream($fh);
    close $fh;
  }
} else {
  process_stream(*STDIN);
}

# Print report if requested
if ($report) {
  print_report();
}

sub process_stream {
  my ($fh) = @_;
  my $buffer = '';

  while (1) {
    my $chunk;
    my $read = read($fh, $chunk, $CHUNK);
    die "Read error: $!" unless defined $read;
    last if $read == 0;

    # Convert from EBCDIC if needed
    $chunk = ebcdic_to_ascii($chunk) if $ebcdic;
    
    $buffer .= $chunk;

    if (length($buffer) > $OVERLAP) {
      my $proc_len = length($buffer) - $OVERLAP;

      # Find a safe boundary - look back to avoid splitting within a digit sequence
      # We want to cut at a position that's NOT in the middle of [\d \-]
      while ($proc_len > 0 && substr($buffer, $proc_len - 1, 1) =~ /[\d \-]/) {
        $proc_len--;
      }

      # Only process if we found a safe boundary (proc_len > 0)
      if ($proc_len > 0) {
        my $segment  = substr($buffer, 0, $proc_len, '');

        # Process all potential PAN sequences (digits with optional separators)
        # Match sequences that contain at least 13 digits
        $segment =~ s/([\d \-]{13,})/scrub_sequence($1)/ge;

        # Convert back to EBCDIC if needed
        $segment = ascii_to_ebcdic($segment) if $ebcdic;
        print $segment;
      }
    }
  }

  # Flush remaining tail
  $buffer =~ s/([\d \-]{13,})/scrub_sequence($1)/ge;
  $buffer = ascii_to_ebcdic($buffer) if $ebcdic;
  print $buffer;
}

sub scheme_allowed {
  my ($scheme) = @_;
  return !!$ALLOW{$scheme};
}

sub scrub_sequence {
  my ($sequence) = @_;

  # Extract digits only to check length
  my $digit_only = $sequence;
  $digit_only =~ tr/0-9//cd;
  my $digit_count = length($digit_only);

  # If less than 13 digits, return unchanged
  return $sequence if $digit_count < 13;

  # If no separators (pure digits), use long_digits approach
  if ($sequence !~ /[ \-]/) {
    return scrub_long_digits($sequence);
  }

  # Has separators - split on spaces and process each part
  my @parts = split(/([ ]+)/, $sequence);
  my @result = ();

  for my $part (@parts) {
    if ($part =~ /^[ ]+$/) {
      # It's a space separator, keep it
      push @result, $part;
    } elsif ($part =~ /\-/) {
      # Has hyphens - single PAN with hyphen separators
      push @result, scrub_match($part);
    } elsif ($part =~ /^\d+$/) {
      # Pure digits - could be single or multiple concatenated PANs
      push @result, scrub_long_digits($part);
    } else {
      # Something else, keep it
      push @result, $part;
    }
  }

  return join('', @result);
}

sub scrub_long_digits {
  my ($digit_string) = @_;
  my $len            = length($digit_string);

  # Don't process if too short
  return $digit_string if $len < 13;

  # Step 1: Find ALL valid non-overlapping PANs in the string
  my @found_pans = ();
  my $pos = 0;

  while ($pos <= $len - 13) {
    my $found_at_pos = 0;

    for my $pan_len (reverse 13 .. 19) {
      next if $pos + $pan_len > $len;

      my $candidate = substr($digit_string, $pos, $pan_len);
      my $scheme    = detect_scheme($candidate);

      # Check if this is a valid PAN we should scrub
      next unless scheme_allowed($scheme);
      next if $luhn && !luhn_check($candidate);

      # Determine standard length for this scheme
      my $standard_len = ($scheme eq 'amex') ? 15 : 16;

      # If this match is longer than standard, check if standard length also works
      # Prefer standard length to avoid false matches from concatenated PANs
      if ($pan_len > $standard_len && $pos + $standard_len <= $len) {
        my $std_candidate = substr($digit_string, $pos, $standard_len);
        my $std_scheme = detect_scheme($std_candidate);
        if ($std_scheme eq $scheme && (!$luhn || luhn_check($std_candidate))) {
          # Standard length also valid, prefer it
          $candidate = $std_candidate;
          $pan_len = $standard_len;
        }
      }

      # Found a valid PAN - record it
      push @found_pans, {
        pos    => $pos,
        len    => $pan_len,
        scheme => $scheme
      };

      # Update statistics
      $STATS{$scheme}++;

      # Skip past this PAN to avoid overlapping matches
      $pos += $pan_len;
      $found_at_pos = 1;
      last;
    }

    # If no PAN found at this position, move forward one digit
    $pos++ unless $found_at_pos;
  }

  # If no PANs found, return original
  return $digit_string unless @found_pans;

  # Step 2: Create bitmask - which positions should be preserved vs zeroed
  # 1 = preserve (BIN or last4 of any PAN), 0 = zero (middle digits)
  my @preserve = (1) x $len;  # Default: preserve everything

  for my $pan (@found_pans) {
    my $pos = $pan->{pos};
    my $len = $pan->{len};

    # For this PAN, mark middle digits as "should zero"
    # Unless --wipe flag is set, preserve BIN (first 6) and last 4
    if ($wipe) {
      # Zero entire PAN
      for my $i ($pos .. $pos + $len - 1) {
        $preserve[$i] = 0;
      }
    } elsif ($len >= 10) {
      # Zero middle (preserve first 6 and last 4)
      for my $i ($pos + 6 .. $pos + $len - 5) {
        $preserve[$i] = 0;
      }
    } else {
      # PAN too short, zero everything
      for my $i ($pos .. $pos + $len - 1) {
        $preserve[$i] = 0;
      }
    }
  }

  # Step 3: Build result using the mask
  my $result = '';
  for my $i (0 .. $len - 1) {
    if ($preserve[$i]) {
      $result .= substr($digit_string, $i, 1);
    } else {
      $result .= '0';
    }
  }

  return $result;
}

sub scrub_match {
  my ($match) = @_;

  # Extract digits only for validation/detection
  my $digits = $match;
  $digits =~ tr/0-9//cd;
  my $len = length($digits);
  return $match if $len < 13 || $len > 19;

  my $scheme = detect_scheme($digits);
  return $match unless scheme_allowed($scheme);

  # Luhn validation (unless disabled)
  if ($luhn) {
    return $match unless luhn_check($digits);
  }

  # Update statistics
  $STATS{$scheme}++;

  my $masked = mask_digits($digits, $wipe);

  # Reinsert masked digits, preserving original separators
  my $i = 0;
  $match =~ s/\d/substr($masked, $i++, 1)/ge;
  return $match;
}

sub luhn_check {
  my ($n) = @_;
  my $sum = 0;
  my $odd = 1;  # from rightmost, odd positions added raw
  for (my $i = length($n) - 1 ; $i >= 0 ; $i--) {
    my $d = ord(substr($n, $i, 1)) - 48;  # '0' => 48
    if ($odd) {
      $sum += $d;
    } else {
      my $t = $d << 1;
      $sum += ($t > 9) ? ($t - 9) : $t;
    }
    $odd = !$odd;
  }
  return ($sum % 10) == 0;
}

sub detect_scheme {
  my ($n) = @_;
  my $len = length($n);

  # American Express: 34 or 37, 15 digits
  return 'amex' if $n =~ /^3[47]/ && $len == 15;

  # Visa: starts with 4, 13–19 digits
  return 'visa' if $n =~ /^4/ && $len >= 13 && $len <= 19;

  # Mastercard: 51–55 or 2221–2720, 16 digits
  if ($len == 16) {
    my $i2 = int(substr($n, 0, 2));
    my $i4 = int(substr($n, 0, 4));
    return 'mastercard'
      if ($i2 >= 51 && $i2 <= 55) || ($i4 >= 2221 && $i4 <= 2720);
  }

  # Discover: 6011, 622126–622925, 644–649, 65, 16–19 digits
  if ($len >= 16 && $len <= 19) {
    my $prefix4 = substr($n, 0, 4);
    my $i2      = int(substr($n, 0, 2));
    my $i3      = int(substr($n, 0, 3));
    my $i6      = ($len >= 6) ? int(substr($n, 0, 6)) : 0;
    return 'discover'
      if $prefix4 eq '6011'
      || $i2 == 65
      || ($i3 >= 644 && $i3 <= 649)
      || ($i6 >= 622126 && $i6 <= 622925);
  }

  return 'unknown';
}

sub mask_digits {
  my ($digits, $wipe_all) = @_;
  my $len = length($digits);

  if ($wipe_all) {
    return '0' x $len;
  }

  # Default: preserve BIN (first 6) and last 4; if too short, wipe all
  return '0' x $len if $len < 10;

  my $bin   = substr($digits, 0, 6);
  my $last4 = substr($digits, -4);
  my $mid   = '0' x ($len - 10);
  return $bin . $mid . $last4;
}

sub print_report {
  my $total = 0;
  
  print STDERR "\n=== PAN Scrubbing Report ===\n";
  
  for my $scheme (@KNOWN_SCHEMES, 'unknown') {
    my $count = $STATS{$scheme};
    next unless $count > 0;
    
    printf STDERR "%-12s: %d\n", ucfirst($scheme), $count;
    $total += $count;
  }
  
  print STDERR "------------------------\n";
  printf STDERR "%-12s: %d\n", 'Total', $total;
  print STDERR "\n";
}

sub print_help {
  print <<'EOF';
pan_scrubber - Remove credit card numbers from files (text or binary)

Usage:
  pan_scrubber [options] < input > output
  pan_scrubber [options] file1 [file2 ...]

Matching:
  - Detects 13–19 digits with optional single spaces or hyphens between digits.
    This covers raw digits, 4-4-4-4, and Amex-style 4-6-5 groupings.
  - Also detects PANs embedded in long strings of digits (e.g. fixed-length
    records with multiple concatenated fields).
  - By default a Luhn check is applied; use --no-luhn to disable it.

Filtering:
  --only SCHEME       Include only these scheme(s). Repeat the flag.
  --ignore SCHEME     Exclude these scheme(s). Repeat the flag.
    Schemes: visa, mastercard (mc), amex, discover, unknown
  --aggressive        Include 'unknown' by default (i.e. scrub numbers that
                      don't match known scheme prefixes), unless overridden
                      by --only/--ignore.

Validation:
  --luhn / --no-luhn  Enable or disable Luhn validation (default: enabled).

Encoding:
  --ebcdic            Process EBCDIC-encoded files (e.g. Mastercard IPM).

Masking:
  Default is to preserve BIN (first 6) and last 4 digits.
  --wipe              Zero out the entire PAN instead.

Reporting:
  --report            Print statistics to STDERR about PANs removed.

Examples:
  cat infile | pan_scrubber > outfile
  pan_scrubber --aggressive --no-luhn --wipe < infile > outfile
  pan_scrubber --only visa --only mc --report < infile > outfile
  pan_scrubber --ignore amex < infile > outfile
  pan_scrubber --ebcdic --report < ipm.dat > ipm_scrubbed.dat
EOF
}
